file: loadmeeting.php
path: loadmeeting.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Load zoom meeting.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

require(__DIR__ . '/../../config.php');
require_once(__DIR__ . '/locallib.php');

require_login();

// Course_module ID.
$id = required_param('id', PARAM_INT);
if ($id) {
    $context = context_module::instance($id);
    $PAGE->set_context($context);

    // Call load meeting function (note: this is where additional access checks happen).
    $meetinginfo = zoom_load_meeting($id, $context);

    // Redirect if available, otherwise deny access.
    if ($meetinginfo['nexturl']) {
        redirect($meetinginfo['nexturl']);
    } else {
        // Get redirect URL.
        $unavailabilityurl = new moodle_url('/mod/zoom/view.php', ['id' => $id]);

        // Redirect the user back to the activity overview page.
        redirect($unavailabilityurl, $meetinginfo['error'], null, \core\output\notification::NOTIFY_ERROR);
    }
} else {
    throw new moodle_exception('zoomerr_id_missing', 'mod_zoom');
}

====================

file: recreate.php
path: recreate.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Recreate a meeting that exists on Moodle but cannot be found on Zoom.
 *
 * @package    mod_zoom
 * @copyright  2017 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

require(__DIR__ . '/../../config.php');
require_once(__DIR__ . '/lib.php');
require_once(__DIR__ . '/locallib.php');

require_login();
// Additional access checks in zoom_get_instance_setup().
[$course, $cm, $zoom] = zoom_get_instance_setup();

require_sesskey();
$context = context_module::instance($cm->id);
// This capability is for managing Zoom instances in general.
require_capability('mod/zoom:addinstance', $context);

$PAGE->set_url('/mod/zoom/recreate.php', ['id' => $cm->id]);

// Create a new meeting with Zoom API to replace the missing one.
// We will use the logged-in user's Zoom account to recreate,
// in case the meeting's former owner no longer exists on Zoom.
$zoom->host_id = zoom_get_user_id();

$trackingfields = $DB->get_records('zoom_meeting_tracking_fields', ['meeting_id' => $zoom->id]);
foreach ($trackingfields as $trackingfield) {
    $field = $trackingfield->tracking_field;
    $zoom->$field = $trackingfield->value;
}

// Set the current zoom table entry to use the new meeting (meeting_id/etc).
$response = zoom_webservice()->create_meeting($zoom, $cm->id);
$zoom = populate_zoom_from_response($zoom, $response);
$zoom->exists_on_zoom = ZOOM_MEETING_EXISTS;
$zoom->timemodified = time();
$DB->update_record('zoom', $zoom);

// Return to Zoom page.
redirect(
    new moodle_url('/mod/zoom/view.php', ['id' => $cm->id]),
    get_string('recreatesuccessful', 'mod_zoom')
);

====================

file: upgrade.txt
path: upgrade.txt
codice:
== v5.4.0 ==

- New setting `zoom/sendicalnotifications`
- New message `mod_zoom/ical_notifications`
- New table `zoom_ical_notifications`
- New task `mod_zoom\task\send_ical_notifications`

== v5.3.0 ==

- New setting `zoom/protectedgroups`
- Optional OAuth scope `group:read:list_groups:admin` or `group:read:admin`

== v5.2.1 ==

- Document Zoom's new granular OAuth scopes.

== v5.2.0 ==

- New settings `zoom/gradingmethod`, `zoom/unamedisplay`
- New per activity setting `grading_method`

== v5.0.0 ==

- Drop support for JWT authentication
- Require PHP 7.1+ (Moodle 3.7+)
- Drop Moodle 3.4 mobile support

== v4.10.0 ==

- New setting `zoom/instanceusers`

== v4.9.0 ==

- New setting `zoom/defaultregistration`
- New per activity setting `registration`
- Removed OAuth scope: `account:read:admin`

== v4.8.0 ==

- New settings `zoom/accountid`, `zoom/clientid`, `zoom/clientsecret`
- Reminder: You must [switch from JWT to Server-to-Server OAuth by June 2023](https://developers.zoom.us/docs/internal-apps/jwt-faq/).

== v4.7.0 ==

- New settings `zoom/recordingoption`, `zoom/allowrecordingchangeoption`
- New per activity setting `option_auto_recording`

== v4.4.0 ==

- New settings `zoom/defaultshowschedule`, `zoom/defaultshowsecurity`, `zoom/defaultshowmedia`
- New per activity settings `show_schedule`, `show_security`, `show_media`
- New setting `zoom/webinardefault`

== v4.3 ==

- New setting `zoom/viewrecordings`
- New per activity setting `recordings_visible_default`

== v4.2 ==

- New setting `zoom/defaulttrackingfields`

== v4.1 ==

- New setting `zoom/apiidentifier`
- New setting `zoom/apiendpoint`

== v4.0 ==

- New setting `zoom/invitationremoveicallink`
- Backward incompatible: exported iCal events now match Moodle's uid format

== v3.7 ==

- New capabilities `mod/zoom:viewjoinurl` and `mod/zoom:viewdialin`

== v3.5 ==

- Added new settings for E2EE, Webinars, Alternative hosts, Download iCal,
  Meeting capacity warning, and Enable meeting links

== v3.4 ==

- Requiring passcodes is now a site wide configuration

== v3.1 ==

- Added site config to mask participant data from appearing in reports (useful for sites that mask participant data, e.g., for HIPAA)

== v3.0 ==

- Added more meeting options: Mute upon entry, Enable waiting room, Only authenticated users.
- Added a new setting 'proxyurl' that can be used to set a proxy as hostname:port.

== v2.0 ==

- Updated to support Zoom API V2
- Support for alternative hosts

== v1.4 ==

- Added support for webinars.

====================

file: loadrecording.php
path: loadrecording.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Load zoom meeting recording and add a record of the view.
 *
 * @package    mod_zoom
 * @copyright  2020 Nick Stefanski <nmstefanski@gmail.com>
 * @author     2021 Jwalit Shah <jwalitshah@catalyst-au.net>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

require(__DIR__ . '/../../config.php');
require_once($CFG->libdir . '/moodlelib.php');
require_once(__DIR__ . '/locallib.php');

$recordingid = required_param('recordingid', PARAM_INT);

if (!get_config('zoom', 'viewrecordings')) {
    throw new moodle_exception('recordingnotvisible', 'mod_zoom', get_string('recordingnotvisible', 'zoom'));
}

[$course, $cm, $zoom] = zoom_get_instance_setup();
require_login($course, true, $cm);

$context = context_module::instance($cm->id);
$PAGE->set_context($context);

require_capability('mod/zoom:view', $context);

// Only show recording that is visble and valid.
$params = [
    'id' => $recordingid,
    'showrecording' => 1,
    'zoomid' => $zoom->id,
];
$rec = $DB->get_record('zoom_meeting_recordings', $params);
if (empty($rec)) {
    throw new moodle_exception('recordingnotfound', 'mod_zoom', '', get_string('recordingnotfound', 'zoom'));
}

$params = ['recordingsid' => $rec->id, 'userid' => $USER->id];
$now = time();

// Keep track of whether someone has viewed the recording or not.
$view = $DB->get_record('zoom_meeting_recordings_view', $params);
if (!empty($view)) {
    if (empty($view->viewed)) {
        $view->viewed = 1;
        $view->timemodified = $now;
        $DB->update_record('zoom_meeting_recordings_view', $view);
    }
} else {
    $view = new stdClass();
    $view->recordingsid = $rec->id;
    $view->userid = $USER->id;
    $view->viewed = 1;
    $view->timemodified = $now;
    $view->id = $DB->insert_record('zoom_meeting_recordings_view', $view);
}

$nexturl = new moodle_url($rec->externalurl);

redirect($nexturl);

====================

file: icon.svg
path: pix/icon.svg
codice:
[CONTENUTO BINARIO - NON RIPORTATO]

====================

file: icon.png
path: pix/icon.png
codice:
[CONTENUTO BINARIO - NON RIPORTATO]

====================

file: monologo.svg
path: pix/monologo.svg
codice:
[CONTENUTO BINARIO - NON RIPORTATO]

====================

file: icon.gif
path: pix/icon.gif
codice:
[CONTENUTO BINARIO - NON RIPORTATO]

====================

file: calendar.svg
path: pix/i/calendar.svg
codice:
[CONTENUTO BINARIO - NON RIPORTATO]

====================

file: calendar.png
path: pix/i/calendar.png
codice:
[CONTENUTO BINARIO - NON RIPORTATO]

====================

file: services.php
path: db/services.php
codice:
<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Zoom external functions and service definitions.
 *
 * @package    mod_zoom
 * @category   external
 * @author     Nick Stefanski
 * @copyright  2017 Auguste Escoffier School of Culinary Arts {@link https://www.escoffier.edu}
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 * @since      Moodle 3.1
 */

defined('MOODLE_INTERNAL') || die;

$functions = [
    'mod_zoom_get_state' => [
        'classname' => 'mod_zoom\external',
        'methodname' => 'get_state',
        'classpath' => 'mod/zoom/classes/external.php',
        'description' => 'Determine if a zoom meeting is available, meeting '
        . 'status, and the start time, duration, and other meeting options.',
        'type' => 'read',
        'capabilities' => 'mod/zoom:view',
        'services' => [MOODLE_OFFICIAL_MOBILE_SERVICE],
    ],
    'mod_zoom_grade_item_update' => [
        'classname' => 'mod_zoom\external',
        'methodname' => 'grade_item_update',
        'classpath' => 'mod/zoom/classes/external.php',
        'description' => 'Creates or updates grade item for the given zoom instance and returns join url.',
        'type' => 'write',
        'capabilities' => 'mod/zoom:view',
        'services' => [MOODLE_OFFICIAL_MOBILE_SERVICE],
    ],
];

====================

file: caches.php
path: db/caches.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Zoom cache definitions.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die;

$definitions = [
    'zoomid' => [
        'mode' => cache_store::MODE_SESSION,
    ],
    'zoommeetingsecurity' => [
        'mode' => cache_store::MODE_APPLICATION,
    ],
    'oauth' => [
        'mode' => cache_store::MODE_APPLICATION,
        'simplekeys' => true,
        'simpledata' => true,
    ],
];

====================

file: install.php
path: db/install.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Provides code to be executed during the module installation.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

/**
 * Post installation procedure
 *
 * @see upgrade_plugins_modules()
 */
function xmldb_zoom_install() {
}

/**
 * Post installation recovery procedure
 *
 * @see upgrade_plugins_modules()
 */
function xmldb_zoom_install_recovery() {
}

====================

file: uninstall.php
path: db/uninstall.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Provides code to be executed during the module uninstallation
 *
 * @see uninstall_plugin()
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

/**
 * Custom uninstallation procedure
 */
function xmldb_zoom_uninstall() {
    return true;
}

====================

file: access.php
path: db/access.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Capability definitions for the zoom module
 *
 * The capabilities are loaded into the database table when the module is
 * installed or updated. Whenever the capability definitions are updated,
 * the module version number should be bumped up.
 *
 * The system has four possible values for a capability:
 * CAP_ALLOW, CAP_PREVENT, CAP_PROHIBIT, and inherit (not set).
 *
 * It is important that capability names are unique. The naming convention
 * for capabilities that are specific to modules and blocks is as follows:
 *   [mod/block]/<plugin_name>:<capabilityname>
 *
 * component_name should be the same as the directory name of the mod or block.
 *
 * Core moodle capabilities are defined thus:
 *    moodle/<capabilityclass>:<capabilityname>
 *
 * Examples: mod/forum:viewpost
 *           block/recent_activity:view
 *           moodle/site:deleteuser
 *
 * The variable name for the capability definitions array is $capabilities
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die();

// Modify capabilities as needed and remove this comment.
$capabilities = [
    'mod/zoom:addinstance' => [
        'riskbitmask' => RISK_XSS,
        'captype' => 'write',
        'contextlevel' => CONTEXT_COURSE,
        'archetypes' => [
            'editingteacher' => CAP_ALLOW,
            'manager' => CAP_ALLOW,
        ],
        'clonepermissionsfrom' => 'moodle/course:manageactivities',
    ],

    'mod/zoom:view' => [
        'captype' => 'read',
        'contextlevel' => CONTEXT_MODULE,
        'legacy' => [
            'guest' => CAP_ALLOW,
            'student' => CAP_ALLOW,
            'teacher' => CAP_ALLOW,
            'editingteacher' => CAP_ALLOW,
            'manager' => CAP_ALLOW,
        ],
    ],

    'mod/zoom:refreshsessions' => [
        'riskbitmask' => RISK_XSS,
        'captype' => 'write',
        'contextlevel' => CONTEXT_COURSE,
        'archetypes' => [
            'manager' => CAP_ALLOW,
        ],
    ],

    'mod/zoom:eligiblealternativehost' => [
        'riskbitmask' => RISK_PERSONAL,
        'captype' => 'read',
        'contextlevel' => CONTEXT_COURSE,
        'archetypes' => [
            'teacher' => CAP_ALLOW,
            'editingteacher' => CAP_ALLOW,
        ],
    ],

    'mod/zoom:viewjoinurl' => [
        'riskbitmask' => RISK_PERSONAL,
        'captype' => 'read',
        'contextlevel' => CONTEXT_COURSE,
        'archetypes' => [
            'teacher' => CAP_ALLOW,
            'editingteacher' => CAP_ALLOW,
            'manager' => CAP_ALLOW,
        ],
    ],

    'mod/zoom:viewdialin' => [
        'riskbitmask' => RISK_PERSONAL,
        'captype' => 'read',
        'contextlevel' => CONTEXT_COURSE,
        'archetypes' => [
            'student' => CAP_ALLOW,
            'teacher' => CAP_ALLOW,
            'editingteacher' => CAP_ALLOW,
            'manager' => CAP_ALLOW,
        ],
    ],
];

====================

file: tasks.php
path: db/tasks.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Definition of Zoom scheduled tasks.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die;

$tasks = [
    [
        'classname' => 'mod_zoom\task\update_meetings',
        'blocking' => 0,
        'minute' => '30',
        'hour' => '4',
        'day' => '*',
        'month' => '*',
        'dayofweek' => '*',
    ],
    [
        'classname' => 'mod_zoom\task\get_meeting_reports',
        'blocking' => 0,
        'minute' => '0',
        'hour' => '*/6',
        'day' => '*',
        'dayofweek' => '*',
        'month' => '*',
    ],
    [
        'classname' => 'mod_zoom\task\update_tracking_fields',
        'blocking' => 0,
        'minute' => '0',
        'hour' => '*/6',
        'day' => '*',
        'dayofweek' => '*',
        'month' => '*',
    ],
    [
        'classname' => 'mod_zoom\task\get_meeting_recordings',
        'blocking' => 0,
        'minute' => '0',
        'hour' => '*/3',
        'day' => '*',
        'dayofweek' => '*',
        'month' => '*',
    ],
    [
        'classname' => 'mod_zoom\task\delete_meeting_recordings',
        'blocking' => 0,
        'minute' => '0',
        'hour' => '0',
        'day' => '*',
        'dayofweek' => '*',
        'month' => '*',
    ],
    [
        'classname' => 'mod_zoom\task\send_ical_notifications',
        'blocking' => 0,
        'minute' => '*/5',
        'hour' => '*',
        'day' => '*',
        'dayofweek' => '*',
        'month' => '*',
    ],
];

====================

file: install.xml
path: db/install.xml
codice:
<XMLDB xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" PATH="mod/zoom/db" VERSION="20250509" COMMENT="Zoom module" xsi:noNamespaceSchemaLocation="../../../lib/xmldb/xmldb.xsd">
  <TABLES>
    <TABLE NAME="zoom" COMMENT="Zoom meetings and webinars">
      <FIELDS>
        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true"/>
        <FIELD NAME="course" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="false" COMMENT="Moodle course that this meeting belongs to."/>
        <FIELD NAME="intro" TYPE="text" NOTNULL="false" SEQUENCE="false"/>
        <FIELD NAME="introformat" TYPE="int" LENGTH="4" NOTNULL="false" SEQUENCE="false" COMMENT="Format of description field"/>
        <FIELD NAME="grade" TYPE="int" LENGTH="10" NOTNULL="false" SEQUENCE="false" COMMENT="Maximum grade (points possible) for this activity. Negative value indicates a scale being used."/>
        <FIELD NAME="grading_method" TYPE="char" LENGTH="10" NOTNULL="false" SEQUENCE="false" COMMENT="Add the grading method by entering the meeting or according the attendance duration."/>
        <FIELD NAME="meeting_id" TYPE="int" LENGTH="15" NOTNULL="true" SEQUENCE="false"/>
        <FIELD NAME="join_url" TYPE="text" NOTNULL="false" SEQUENCE="false"/>
        <FIELD NAME="created_at" TYPE="char" LENGTH="20" NOTNULL="false" SEQUENCE="false" COMMENT="ISO datetime format"/>
        <FIELD NAME="host_id" TYPE="char" LENGTH="30" NOTNULL="true" SEQUENCE="false" COMMENT="Meeting host user ID. Can be any user under this account. Cannot be updated after creation."/>
        <FIELD NAME="name" TYPE="char" LENGTH="300" NOTNULL="true" SEQUENCE="false" COMMENT="Meeting topic. Max of 300 characters."/>
        <FIELD NAME="start_time" TYPE="int" LENGTH="12" NOTNULL="false" SEQUENCE="false" COMMENT="Meeting start time (Unix timestamp, seconds). For scheduled meeting only."/>
        <FIELD NAME="timemodified" TYPE="int" LENGTH="12" NOTNULL="false" SEQUENCE="false" COMMENT="Timestamp when the instance was last modified."/>
        <FIELD NAME="recurring" TYPE="int" LENGTH="1" NOTNULL="false" DEFAULT="0" SEQUENCE="false" COMMENT="Is the meeting or webinar recurring?"/>
        <FIELD NAME="recurrence_type" TYPE="int" LENGTH="1" NOTNULL="false" SEQUENCE="false" COMMENT="Is the recurring meeting weekly, daily or monthly"/>
        <FIELD NAME="repeat_interval" TYPE="int" LENGTH="2" NOTNULL="false" SEQUENCE="false" COMMENT="Specify the repeat interval of the meeting"/>
        <FIELD NAME="weekly_days" TYPE="char" LENGTH="14" NOTNULL="false" SEQUENCE="false" COMMENT="Specify the days for weekly recurring meetings"/>
        <FIELD NAME="monthly_day" TYPE="int" LENGTH="2" NOTNULL="false" SEQUENCE="false" COMMENT="Specify the day for a recurring monthly meeting"/>
        <FIELD NAME="monthly_week" TYPE="int" LENGTH="2" NOTNULL="false" SEQUENCE="false" COMMENT="Specify the week for a recurring monthly meeting"/>
        <FIELD NAME="monthly_week_day" TYPE="int" LENGTH="1" NOTNULL="false" SEQUENCE="false" COMMENT="Specify a day of the week for a recurring monthly meeting"/>
        <FIELD NAME="monthly_repeat_option" TYPE="int" LENGTH="1" NOTNULL="false" SEQUENCE="false" COMMENT="For UI purposes. To determine which monthly repeat option is chosen"/>
        <FIELD NAME="end_times" TYPE="int" LENGTH="2" NOTNULL="false" SEQUENCE="false" COMMENT="The amount of times meeting should occur before its canceled"/>
        <FIELD NAME="end_date_time" TYPE="int" LENGTH="12" NOTNULL="false" SEQUENCE="false" COMMENT="The final date (Unix timestamp, seconds) of the meeting before its canceled"/>
        <FIELD NAME="end_date_option" TYPE="int" LENGTH="1" NOTNULL="false" SEQUENCE="false" COMMENT="For UI purposes. To determine which end date option is chosen"/>
        <FIELD NAME="webinar" TYPE="int" LENGTH="1" NOTNULL="false" DEFAULT="0" SEQUENCE="false" COMMENT="Is this a webinar?"/>
        <FIELD NAME="duration" TYPE="int" LENGTH="6" NOTNULL="false" SEQUENCE="false" COMMENT="Meeting duration (seconds). For scheduled meeting only."/>
        <FIELD NAME="timezone" TYPE="char" LENGTH="50" NOTNULL="false" SEQUENCE="false" COMMENT="Timezone to format start_time, like &quot;America/Los_Angeles&quot;. For scheduled meeting only."/>
        <FIELD NAME="password" TYPE="char" LENGTH="10" NOTNULL="false" SEQUENCE="false" COMMENT="Meeting password. Password may only contain the following characters: [a-zA-Z0-9@-_*]. Max of 10 characters"/>
        <FIELD NAME="option_jbh" TYPE="int" LENGTH="1" NOTNULL="false" DEFAULT="0" SEQUENCE="false" COMMENT="Join meeting before host start the meeting."/>
        <FIELD NAME="option_start_type" TYPE="char" LENGTH="12" NOTNULL="false" SEQUENCE="false" COMMENT="Meeting start type. Can be &quot;video&quot; or &quot;screen_share&quot;. (deprecated)"/>
        <FIELD NAME="option_host_video" TYPE="int" LENGTH="1" NOTNULL="false" DEFAULT="0" SEQUENCE="false" COMMENT="Start video when host joins meeting."/>
        <FIELD NAME="option_participants_video" TYPE="int" LENGTH="1" NOTNULL="false" DEFAULT="0" SEQUENCE="false" COMMENT="Start video when participants join meeting."/>
        <FIELD NAME="option_audio" TYPE="char" LENGTH="9" NOTNULL="false" DEFAULT="both" SEQUENCE="false" COMMENT="Meeting audio options. Can be &quot;both&quot;, &quot;telephony&quot;, &quot;voip&quot;."/>
        <FIELD NAME="option_mute_upon_entry" TYPE="int" LENGTH="1" NOTNULL="false" DEFAULT="1" SEQUENCE="false"/>
        <FIELD NAME="option_waiting_room" TYPE="int" LENGTH="1" NOTNULL="false" DEFAULT="1" SEQUENCE="false"/>
        <FIELD NAME="option_authenticated_users" TYPE="int" LENGTH="1" NOTNULL="false" DEFAULT="0" SEQUENCE="false"/>
        <FIELD NAME="option_encryption_type" TYPE="char" LENGTH="20" NOTNULL="false" DEFAULT="enhanced_encryption" SEQUENCE="false" COMMENT="Meeting encryption type. Can be &quot;enhanced_encryption&quot;, &quot;e2ee&quot;"/>
        <FIELD NAME="exists_on_zoom" TYPE="int" LENGTH="1" NOTNULL="true" DEFAULT="1" SEQUENCE="false" COMMENT="Whether the meeting can be found on Zoom servers. Usually should be true, should only be false if API call returned that meeting can't be found."/>
        <FIELD NAME="alternative_hosts" TYPE="text" NOTNULL="false" SEQUENCE="false"/>
        <FIELD NAME="recordings_visible_default" TYPE="int" LENGTH="1" NOTNULL="true" DEFAULT="1" SEQUENCE="false" COMMENT="Should the recordings for this meeting be visible by default"/>
        <FIELD NAME="show_schedule" TYPE="int" LENGTH="1" NOTNULL="true" DEFAULT="1" SEQUENCE="false" COMMENT="Show Schedule heading in activity page"/>
        <FIELD NAME="show_security" TYPE="int" LENGTH="1" NOTNULL="true" DEFAULT="1" SEQUENCE="false" COMMENT="Show Security heading in activity page"/>
        <FIELD NAME="show_media" TYPE="int" LENGTH="1" NOTNULL="true" DEFAULT="1" SEQUENCE="false" COMMENT="Show Media heading in activity page"/>
        <FIELD NAME="option_auto_recording" TYPE="char" LENGTH="5" NOTNULL="false" SEQUENCE="false" COMMENT="Auto record meeting."/>
        <FIELD NAME="registration" TYPE="int" LENGTH="1" NOTNULL="true" DEFAULT="2" SEQUENCE="false" COMMENT="Force participants to register for the meeting/webinar"/>
      </FIELDS>
      <KEYS>
        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
      </KEYS>
      <INDEXES>
        <INDEX NAME="meeting_id_idx" UNIQUE="false" FIELDS="meeting_id"/>
      </INDEXES>
    </TABLE>
    <TABLE NAME="zoom_meeting_details" COMMENT="A queue for the Cron to add meeting report info to zoom_meetings_participants table.">
      <FIELDS>
        <FIELD NAME="uuid" TYPE="char" LENGTH="30" NOTNULL="true" SEQUENCE="false" COMMENT="The meeting UUID or webinar UUID per Zoom API."/>
        <FIELD NAME="meeting_id" TYPE="int" LENGTH="15" NOTNULL="true" SEQUENCE="false" COMMENT="The meeting_id or webinar_id per Zoom API."/>
        <FIELD NAME="end_time" TYPE="int" LENGTH="12" NOTNULL="true" SEQUENCE="false" COMMENT="When the meeting ended/will end"/>
        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true" COMMENT="This field exists only because Moodle requires us to have a unique 'id' field. Other than that it's useless."/>
        <FIELD NAME="start_time" TYPE="int" LENGTH="12" NOTNULL="true" SEQUENCE="false"/>
        <FIELD NAME="duration" TYPE="int" LENGTH="12" NOTNULL="true" SEQUENCE="false"/>
        <FIELD NAME="topic" TYPE="char" LENGTH="300" NOTNULL="true" SEQUENCE="false"/>
        <FIELD NAME="total_minutes" TYPE="int" LENGTH="12" NOTNULL="false" DEFAULT="0" SEQUENCE="false" COMMENT="Total duration that the meeting actually lasted"/>
        <FIELD NAME="participants_count" TYPE="int" LENGTH="4" NOTNULL="false" DEFAULT="0" SEQUENCE="false" COMMENT="Number of participants that attended the meeting. Max number of participants is 100 so 4 digits a bit of overkill."/>
        <FIELD NAME="zoomid" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="false" COMMENT="link to mdl_zoom table"/>
      </FIELDS>
      <KEYS>
        <KEY NAME="id_primary" TYPE="primary" FIELDS="id" COMMENT="Moodle forces us to use id as a primary key. Most database actions will be performed using meeting_webinar_instance_id."/>
        <KEY NAME="uuid_unique" TYPE="unique" FIELDS="uuid"/>
        <KEY NAME="zoomid_foreign" TYPE="foreign" FIELDS="zoomid" REFTABLE="zoom" REFFIELDS="id"/>
      </KEYS>
    </TABLE>
    <TABLE NAME="zoom_meeting_participants" COMMENT="A list of each meeting existing on Moodle and when its participants entered/left.">
      <FIELDS>
        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true" COMMENT="This field exists only because Moodle requires us to have a unique 'id' field. Other than that it's useless."/>
        <FIELD NAME="userid" TYPE="int" LENGTH="10" NOTNULL="false" SEQUENCE="false" COMMENT="The user id from moodle"/>
        <FIELD NAME="zoomuserid" TYPE="char" LENGTH="35" NOTNULL="true" SEQUENCE="false" COMMENT="The user_id per Zoom API"/>
        <FIELD NAME="uuid" TYPE="char" LENGTH="30" NOTNULL="false" SEQUENCE="false" COMMENT="The participant UUID per Zoom API."/>
        <FIELD NAME="user_email" TYPE="text" NOTNULL="false" SEQUENCE="false" COMMENT="The particpant's email per Zoom API."/>
        <FIELD NAME="join_time" TYPE="int" LENGTH="12" NOTNULL="true" SEQUENCE="false" COMMENT="When the particpant joined the meeting."/>
        <FIELD NAME="leave_time" TYPE="int" LENGTH="12" NOTNULL="true" SEQUENCE="false" COMMENT="When the participant left the meeting."/>
        <FIELD NAME="duration" TYPE="int" LENGTH="12" NOTNULL="true" SEQUENCE="false" COMMENT="The time for which the participant was in the meeting."/>
        <FIELD NAME="name" TYPE="char" LENGTH="255" NOTNULL="true" SEQUENCE="false" COMMENT="user's name"/>
        <FIELD NAME="detailsid" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="false" COMMENT="link to zoom_meeting_details table"/>
      </FIELDS>
      <KEYS>
        <KEY NAME="id_primary" TYPE="primary" FIELDS="id" COMMENT="Moodle forces us to use id as a primary key. Most database actions will be performed using participant_universal_id."/>
        <KEY NAME="detailsid_foreign" TYPE="foreign" FIELDS="detailsid" REFTABLE="zoom_meeting_details" REFFIELDS="id" COMMENT="there is no index built on this because making it a foreign key does that automatically"/>
      </KEYS>
      <INDEXES>
        <INDEX NAME="userid" UNIQUE="false" FIELDS="userid"/>
        <INDEX NAME="uuid" UNIQUE="false" FIELDS="uuid"/>
      </INDEXES>
    </TABLE>
    <TABLE NAME="zoom_meeting_tracking_fields" COMMENT="A list of tracking field values for meetings in Zoom.">
      <FIELDS>
        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true"/>
        <FIELD NAME="meeting_id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="false" COMMENT="The id of the meeting from the DB table."/>
        <FIELD NAME="tracking_field" TYPE="char" LENGTH="255" NOTNULL="true" SEQUENCE="false" COMMENT="The label/name for the tracking field."/>
        <FIELD NAME="value" TYPE="text" NOTNULL="false" SEQUENCE="false" COMMENT="Configured value for tracking field."/>
      </FIELDS>
      <KEYS>
        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
      </KEYS>
      <INDEXES>
        <INDEX NAME="meeting_id" UNIQUE="false" FIELDS="meeting_id"/>
        <INDEX NAME="tracking_field" UNIQUE="false" FIELDS="tracking_field"/>
      </INDEXES>
    </TABLE>
    <TABLE NAME="zoom_meeting_recordings" COMMENT="A list of recording links for Zoom meeting activities.">
      <FIELDS>
        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true" COMMENT="This field exists only because Moodle requires us to have a unique 'id' field."/>
        <FIELD NAME="zoomid" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="false" COMMENT="link to mdl_zoom table"/>
        <FIELD NAME="meetinguuid" TYPE="char" LENGTH="30" NOTNULL="true" SEQUENCE="false"/>
        <FIELD NAME="zoomrecordingid" TYPE="char" LENGTH="36" NOTNULL="true" SEQUENCE="false"/>
        <FIELD NAME="name" TYPE="char" LENGTH="300" NOTNULL="true" SEQUENCE="false" COMMENT="Recording topic. Max of 300 characters."/>
        <FIELD NAME="externalurl" TYPE="text" NOTNULL="true" SEQUENCE="false" COMMENT="Link to view the recording."/>
        <FIELD NAME="passcode" TYPE="char" LENGTH="30" NOTNULL="false" SEQUENCE="false" COMMENT="Passcode to access the recording."/>
        <FIELD NAME="recordingtype" TYPE="char" LENGTH="50" NOTNULL="true" SEQUENCE="false" COMMENT="Type of recording."/>
        <FIELD NAME="recordingstart" TYPE="int" LENGTH="12" NOTNULL="true" SEQUENCE="false"/>
        <FIELD NAME="showrecording" TYPE="int" LENGTH="1" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
        <FIELD NAME="timecreated" TYPE="int" LENGTH="12" NOTNULL="false" SEQUENCE="false" COMMENT="Timestamp when the record was created."/>
        <FIELD NAME="timemodified" TYPE="int" LENGTH="12" NOTNULL="false" SEQUENCE="false" COMMENT="Timestamp when the record was last modified."/>
      </FIELDS>
      <KEYS>
        <KEY NAME="id_primary" TYPE="primary" FIELDS="id" COMMENT="Moodle forces us to use id as a primary key."/>
        <KEY NAME="zoomid_foreign" TYPE="foreign" FIELDS="zoomid" REFTABLE="zoom" REFFIELDS="id"/>
      </KEYS>
    </TABLE>
    <TABLE NAME="zoom_meeting_recordings_view" COMMENT="A list to track when users view Zoom meeting recordings.">
      <FIELDS>
        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true" COMMENT="This field exists only because Moodle requires us to have a unique 'id' field."/>
        <FIELD NAME="recordingsid" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="false" COMMENT="link to zoom_meeting_recordings table"/>
        <FIELD NAME="userid" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="false" COMMENT="The user id from moodle"/>
        <FIELD NAME="viewed" TYPE="int" LENGTH="1" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="Did the user view the recording? 1 for true, 0 for false."/>
        <FIELD NAME="timemodified" TYPE="int" LENGTH="12" NOTNULL="false" SEQUENCE="false" COMMENT="Timestamp when the record was last modified."/>
      </FIELDS>
      <KEYS>
        <KEY NAME="id_primary" TYPE="primary" FIELDS="id" COMMENT="Moodle forces us to use id as a primary key."/>
        <KEY NAME="recordingsid_foreign" TYPE="foreign" FIELDS="recordingsid" REFTABLE="zoom_meeting_recordings" REFFIELDS="id"/>
      </KEYS>
      <INDEXES>
        <INDEX NAME="userid" UNIQUE="false" FIELDS="userid"/>
      </INDEXES>
    </TABLE>
    <TABLE NAME="zoom_meeting_breakout_rooms" COMMENT="A list of zoom meeting breakout rooms.">
      <FIELDS>
        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true"/>
        <FIELD NAME="name" TYPE="char" LENGTH="32" NOTNULL="false" SEQUENCE="false"/>
        <FIELD NAME="zoomid" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="false"/>
      </FIELDS>
      <KEYS>
        <KEY NAME="id_primary" TYPE="primary" FIELDS="id"/>
        <KEY NAME="fk_zoomid" TYPE="foreign" FIELDS="zoomid" REFTABLE="zoom" REFFIELDS="id"/>
      </KEYS>
    </TABLE>
    <TABLE NAME="zoom_breakout_participants" COMMENT="A list of zoom meeting breakout rooms participants.">
      <FIELDS>
        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true"/>
        <FIELD NAME="userid" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="false"/>
        <FIELD NAME="breakoutroomid" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="false"/>
      </FIELDS>
      <KEYS>
        <KEY NAME="id_primary" TYPE="primary" FIELDS="id"/>
        <KEY NAME="fk_breakoutroomid" TYPE="foreign" FIELDS="breakoutroomid" REFTABLE="zoom_meeting_breakout_rooms" REFFIELDS="id"/>
      </KEYS>
    </TABLE>
    <TABLE NAME="zoom_breakout_groups" COMMENT="A list of zoom meeting breakout rooms groups.">
      <FIELDS>
        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true"/>
        <FIELD NAME="groupid" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="false"/>
        <FIELD NAME="breakoutroomid" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="false"/>
      </FIELDS>
      <KEYS>
        <KEY NAME="id_primary" TYPE="primary" FIELDS="id"/>
        <KEY NAME="fk_breakoutroomid" TYPE="foreign" FIELDS="breakoutroomid" REFTABLE="zoom_meeting_breakout_rooms" REFFIELDS="id"/>
      </KEYS>
    </TABLE>
    <TABLE NAME="zoom_ical_notifications" COMMENT="Identifies the zoom event for which ical notifications have been emailed.">
      <FIELDS>
        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true"/>
        <FIELD NAME="zoomeventid" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="false"/>
        <FIELD NAME="notificationtime" TYPE="int" LENGTH="12" NOTNULL="true" SEQUENCE="false" COMMENT="The time when the send ical notifications task was completed successfully."/>
      </FIELDS>
      <KEYS>
        <KEY NAME="id_primary" TYPE="primary" FIELDS="id"/>
        <KEY NAME="fk_zoomeventid" TYPE="foreign-unique" FIELDS="zoomeventid" REFTABLE="event" REFFIELDS="id"/>
      </KEYS>
    </TABLE>
  </TABLES>
</XMLDB>
====================

file: upgrade.php
path: db/upgrade.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * This file keeps track of upgrades to the zoom module
 *
 * Sometimes, changes between versions involve alterations to database
 * structures and other major things that may break installations. The upgrade
 * function in this file will attempt to perform all the necessary actions to
 * upgrade your older installation to the current version. If there's something
 * it cannot do itself, it will tell you what you need to do.  The commands in
 * here will all be database-neutral, using the functions defined in DLL libraries.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

/**
 * Execute zoom upgrade from the given old version
 *
 * @param int $oldversion
 * @return bool
 */
function xmldb_zoom_upgrade($oldversion) {
    global $DB;

    $dbman = $DB->get_manager(); // Loads ddl manager and xmldb classes.
    $table = new xmldb_table('zoom');

    if ($oldversion < 2015071000) {
        // Add updated_at.
        $field = new xmldb_field('updated_at', XMLDB_TYPE_CHAR, '20', null, null, null, null, 'created_at');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Add ended_at.
        $field = new xmldb_field('ended_at', XMLDB_TYPE_CHAR, '20', null, null, null, null, 'updated_at');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        upgrade_mod_savepoint(true, 2015071000, 'zoom');
    }

    if ($oldversion < 2015071500) {
        // Rename option_no_video_host to option_host_video; change default to 1; invert values.
        $field = new xmldb_field('option_no_video_host', XMLDB_TYPE_INTEGER, '1', null, null, null, '1', 'option_start_type');
        // Invert option_no_video_host.
        $DB->set_field('UPDATE {zoom} SET option_no_video_host = 1 - option_no_video_host');
        $dbman->change_field_default($table, $field);
        $dbman->rename_field($table, $field, 'option_host_video');

        // Rename option_no_video_participants to option_participants_video; change default to 1; invert values.
        $field = new xmldb_field(
            'option_no_video_participants',
            XMLDB_TYPE_INTEGER,
            '1',
            null,
            null,
            null,
            '1',
            'option_host_video'
        );
        // Invert option_no_video_participants.
        $DB->set_field('UPDATE {zoom} SET option_no_video_participants = 1 - option_no_video_participants');
        $dbman->change_field_default($table, $field);
        $dbman->rename_field($table, $field, 'option_participants_video');

        // Change start_time to int (timestamp).
        $field = new xmldb_field('start_time', XMLDB_TYPE_INTEGER, '12', null, null, null, null, 'name');
        $starttimes = $DB->get_recordset('zoom');
        foreach ($starttimes as $time) {
            $time->start_time = strtotime($time->start_time);
            $DB->update_record('zoom', $time);
        }

        $starttimes->close();
        $dbman->change_field_type($table, $field);

        // Change precision/length of duration to 6 digits.
        $field = new xmldb_field('duration', XMLDB_TYPE_INTEGER, '6', null, null, null, null, 'type');
        $dbman->change_field_precision($table, $field);
        $DB->set_field('UPDATE {zoom} SET duration = duration*60');

        upgrade_mod_savepoint(true, 2015071500, 'zoom');
    }

    if ($oldversion < 2015071600) {
        // Add intro.
        $field = new xmldb_field('intro', XMLDB_TYPE_TEXT, null, null, null, null, null, 'course');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Add introformat.
        $field = new xmldb_field('introformat', XMLDB_TYPE_INTEGER, '4', null, null, null, null, 'intro');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        upgrade_mod_savepoint(true, 2015071600, 'zoom');
    }

    if ($oldversion < 2015072000) {
        // Drop updated_at.
        $field = new xmldb_field('updated_at');
        if ($dbman->field_exists($table, $field)) {
            $dbman->drop_field($table, $field);
        }

        // Drop ended_at.
        $field = new xmldb_field('ended_at');
        if ($dbman->field_exists($table, $field)) {
            $dbman->drop_field($table, $field);
        }

        // Add timemodified.
        $field = new xmldb_field('timemodified', XMLDB_TYPE_INTEGER, '12', null, null, null, null, 'start_time');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Add grade.
        $field = new xmldb_field('grade', XMLDB_TYPE_INTEGER, '10', null, null, null, null, 'introformat');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2015072000, 'zoom');
    }

    if ($oldversion < 2016040100) {
        // Add webinar.
        $field = new xmldb_field('webinar', XMLDB_TYPE_INTEGER, '1', null, null, null, '0', 'type');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Change type to recurring.
        $field = new xmldb_field('type', XMLDB_TYPE_INTEGER, '1', null, null, null, '0', 'timemodified');
        $dbman->change_field_notnull($table, $field);
        $dbman->change_field_default($table, $field);
        // Meeting is recurring if type is 3.
        $DB->set_field_select('zoom', 'type', 0, 'type <> 3');
        $DB->set_field('zoom', 'type', 1, ['type' => 3]);
        $dbman->rename_field($table, $field, 'recurring');

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2016040100, 'zoom');
    }

    if ($oldversion < 2018091200) {
        // Removed apiurl option from settings.
        set_config('apiurl', null, 'mod_zoom');

        // Set the starting number of API calls.
        set_config('calls_left', 2000, 'mod_zoom');

        // Set the time at which to start looking for meeting reports.
        set_config('last_call_made_at', time() - (60 * 60 * 12), 'mod_zoom');

        // Start zoom table modifications.
        $table = new xmldb_table('zoom');

        // Define field status to be dropped from zoom.
        $field = new xmldb_field('status');

        // Conditionally launch drop field status.
        if ($dbman->field_exists($table, $field)) {
            $dbman->drop_field($table, $field);
        }

        // Define field exists_on_zoom to be added to zoom.
        $field = new xmldb_field('exists_on_zoom', XMLDB_TYPE_INTEGER, '1', null, XMLDB_NOTNULL, null, '1', 'option_audio');

        // Conditionally launch add field exists_on_zoom.
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Define field uuid to be dropped from zoom.
        $field = new xmldb_field('uuid');

        // Conditionally launch drop field uuid.
        if ($dbman->field_exists($table, $field)) {
            $dbman->drop_field($table, $field);
        }

        // Define table zoom_meeting_details to be created.
        $table = new xmldb_table('zoom_meeting_details');

        // Adding fields to table zoom_meeting_details.
        $table->add_field('id', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
        $table->add_field('uuid', XMLDB_TYPE_CHAR, '30', null, XMLDB_NOTNULL, null, null);
        $table->add_field('meeting_id', XMLDB_TYPE_INTEGER, '11', null, XMLDB_NOTNULL, null, null);
        $table->add_field('end_time', XMLDB_TYPE_INTEGER, '12', null, XMLDB_NOTNULL, null, null);
        $table->add_field('duration', XMLDB_TYPE_INTEGER, '12', null, XMLDB_NOTNULL, null, null);
        $table->add_field('start_time', XMLDB_TYPE_INTEGER, '12', null, null, null, null);
        $table->add_field('topic', XMLDB_TYPE_CHAR, '300', null, XMLDB_NOTNULL, null, null);
        $table->add_field('total_minutes', XMLDB_TYPE_INTEGER, '12', null, null, null, '0');
        $table->add_field('participants_count', XMLDB_TYPE_INTEGER, '4', null, null, null, '0');
        $table->add_field('zoomid', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, null);

        // Adding keys to table zoom_meeting_details.
        $table->add_key('uuid_unique', XMLDB_KEY_UNIQUE, ['uuid']);
        $table->add_key('id_primary', XMLDB_KEY_PRIMARY, ['id']);
        $table->add_key('zoomid_foreign', XMLDB_KEY_FOREIGN, ['zoomid'], 'zoom', ['id']);
        $table->add_key('meeting_unique', XMLDB_KEY_UNIQUE, ['meeting_id', 'uuid']);

        // Conditionally launch create table for zoom_meeting_details.
        if (!$dbman->table_exists($table)) {
            $dbman->create_table($table);
        }

        // Define table zoom_meeting_participants to be created.
        $table = new xmldb_table('zoom_meeting_participants');

        // Adding fields to table zoom_meeting_participants.
        $table->add_field('id', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
        $table->add_field('zoomuserid', XMLDB_TYPE_INTEGER, '11', null, XMLDB_NOTNULL, null, null);
        $table->add_field('uuid', XMLDB_TYPE_CHAR, '30', null, null, null, null);
        $table->add_field('user_email', XMLDB_TYPE_TEXT, null, null, null, null, null);
        $table->add_field('join_time', XMLDB_TYPE_INTEGER, '12', null, XMLDB_NOTNULL, null, null);
        $table->add_field('leave_time', XMLDB_TYPE_INTEGER, '12', null, XMLDB_NOTNULL, null, null);
        $table->add_field('duration', XMLDB_TYPE_INTEGER, '12', null, XMLDB_NOTNULL, null, null);
        $table->add_field('attentiveness_score', XMLDB_TYPE_CHAR, '7', null, XMLDB_NOTNULL, null, null);
        $table->add_field('userid', XMLDB_TYPE_CHAR, '255', null, null, null, null);
        $table->add_field('name', XMLDB_TYPE_CHAR, '255', null, XMLDB_NOTNULL, null, null);
        $table->add_field('detailsid', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, null, 'name');

        // Adding keys to table zoom_meeting_participants.
        $table->add_key('id_primary', XMLDB_KEY_PRIMARY, ['id']);
        $table->add_key('user_by_meeting_key', XMLDB_KEY_UNIQUE, ['detailsid', 'zoomuserid']);
        $table->add_key('detailsid_foreign', XMLDB_KEY_FOREIGN, ['detailsid'], 'zoom_meeting_details', ['id']);

        // Adding indexes to table zoom_meeting_participants.
        $table->add_index('userid', XMLDB_INDEX_NOTUNIQUE, ['userid']);

        // Conditionally launch create table for zoom_meeting_participants.
        if (!$dbman->table_exists($table)) {
            $dbman->create_table($table);
        }

        upgrade_mod_savepoint(true, 2018091200, 'zoom');
    }

    if ($oldversion < 2018091400) {
        // Define field alternative_hosts to be added to zoom.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field('alternative_hosts', XMLDB_TYPE_CHAR, '255', null, null, null, null, 'exists_on_zoom');

        // Conditionally launch add field alternative_hosts.
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2018091400, 'zoom');
    }

    if ($oldversion < 2018092201) {
        // Changing type of field userid on table zoom_meeting_participants to int.
        $table = new xmldb_table('zoom_meeting_participants');

        $index = new xmldb_index('userid', XMLDB_INDEX_NOTUNIQUE, ['userid']);

        // Conditionally launch drop index userid.
        if ($dbman->index_exists($table, $index)) {
            $dbman->drop_index($table, $index);
        }

        $field = new xmldb_field('userid', XMLDB_TYPE_INTEGER, '10', null, null, null, null, 'id');

        // Launch change of type for field userid.
        $dbman->change_field_type($table, $field);

        $index = new xmldb_index('userid', XMLDB_INDEX_NOTUNIQUE, ['userid']);

        // Conditionally launch add index userid.
        if (!$dbman->index_exists($table, $index)) {
            $dbman->add_index($table, $index);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2018092201, 'zoom');
    }

    if ($oldversion < 2019061800) {
        // Make sure start_time is not null to match install.xml.
        $table = new xmldb_table('zoom_meeting_details');
        $field = new xmldb_field('start_time', XMLDB_TYPE_INTEGER, '12', null, XMLDB_NOTNULL, null, null);
        if ($dbman->field_exists($table, $field)) {
            $dbman->change_field_notnull($table, $field);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2019061800, 'zoom');
    }

    if ($oldversion < 2019091200) {
        // Change field alternative_hosts from type char(255) to text.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field('alternative_hosts', XMLDB_TYPE_TEXT, null, null, null, null, null, 'exists_on_zoom');
        $dbman->change_field_type($table, $field);

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2019091200, 'zoom');
    }

    if ($oldversion < 2020042600) {
        // Change field zoom_meeting_participants from type int(11) to char(35),
        // because sometimes zoomuserid is concatenated with a timestamp.
        // See https://devforum.zoom.us/t/meeting-participant-user-id-value/7886/2.
        $table = new xmldb_table('zoom_meeting_participants');

        // First drop key, not needed anymore.
        $key = new xmldb_key('user_by_meeting_key', XMLDB_KEY_UNIQUE, ['detailsid', 'zoomuserid']);
        $dbman->drop_key($table, $key);

        // Change of type for field zoomuserid to char(35).
        $field = new xmldb_field('zoomuserid', XMLDB_TYPE_CHAR, '35', null, XMLDB_NOTNULL, null, null, 'userid');
        $dbman->change_field_type($table, $field);

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2020042600, 'zoom');
    }

    if ($oldversion < 2020042700) {
        // Define field attentiveness_score to be dropped from zoom_meeting_participants.
        $table = new xmldb_table('zoom_meeting_participants');
        $field = new xmldb_field('attentiveness_score');

        // Conditionally launch drop field attentiveness_score.
        if ($dbman->field_exists($table, $field)) {
            $dbman->drop_field($table, $field);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2020042700, 'zoom');
    }

    if ($oldversion < 2020051800) {
        // Define field option_mute_upon_entry to be added to zoom.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field('option_mute_upon_entry', XMLDB_TYPE_INTEGER, '1', null, null, null, '1', 'option_audio');

        // Conditionally launch add field option_mute_upon_entry.
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Define field option_waiting_room to be added to zoom.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field('option_waiting_room', XMLDB_TYPE_INTEGER, '1', null, null, null, '1', 'option_mute_upon_entry');

        // Conditionally launch add field option_waiting_room.
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Define field authenticated_users to be added to zoom.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field(
            'option_authenticated_users',
            XMLDB_TYPE_INTEGER,
            '1',
            null,
            null,
            null,
            '0',
            'option_waiting_room'
        );

        // Conditionally launch add field authenticated_users.
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Changing the default of field option_host_video on table zoom to 0.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field('option_host_video', XMLDB_TYPE_INTEGER, '1', null, null, null, '0', 'option_start_type');

        // Launch change of default for field option_host_video.
        $dbman->change_field_default($table, $field);

        // Changing the default of field option_participants_video on table zoom to 0.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field('option_participants_video', XMLDB_TYPE_INTEGER, '1', null, null, null, '0', 'option_host_video');

        // Launch change of default for field option_participants_video.
        $dbman->change_field_default($table, $field);

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2020051800, 'zoom');
    }

    if ($oldversion < 2020052100) {
        // Increase meeting_id since Zoom increased the size from 10 to 11.

        // First need to drop index.
        $table = new xmldb_table('zoom');
        $index = new xmldb_index('meeting_id_idx', XMLDB_INDEX_NOTUNIQUE, ['meeting_id']);
        if ($dbman->index_exists($table, $index)) {
            $dbman->drop_index($table, $index);
        }

        // Increase size to 15 for future proofing.
        $field = new xmldb_field('meeting_id', XMLDB_TYPE_INTEGER, '15', null, XMLDB_NOTNULL, null, null, 'grade');
        $dbman->change_field_precision($table, $field);

        // Add index back.
        $dbman->add_index($table, $index);

        // First need to drop key.
        $table = new xmldb_table('zoom_meeting_details');
        $key = new xmldb_key('meeting_unique', XMLDB_KEY_UNIQUE, ['meeting_id', 'uuid']);
        $dbman->drop_key($table, $key);

        // Increase size to 15 for future proofing.
        $field = new xmldb_field('meeting_id', XMLDB_TYPE_INTEGER, '15', null, XMLDB_NOTNULL, null, null, 'uuid');
        $dbman->change_field_precision($table, $field);

        // Add key back.
        $dbman->add_key($table, $key);

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2020052100, 'zoom');
    }

    if ($oldversion < 2020100800) {
        // Changing the default of field option_host_video on table zoom to 0.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field('option_host_video', XMLDB_TYPE_INTEGER, '1', null, null, null, '0', 'option_start_type');

        // Launch change of default for field option_host_video.
        $dbman->change_field_default($table, $field);

        // Changing the default of field option_participants_video on table zoom to 0.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field('option_participants_video', XMLDB_TYPE_INTEGER, '1', null, null, null, '0', 'option_host_video');

        // Launch change of default for field option_participants_video.
        $dbman->change_field_default($table, $field);

        // Changing the default of field option_mute_upon_entry on table zoom to 1.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field('option_mute_upon_entry', XMLDB_TYPE_INTEGER, '1', null, null, null, '1', 'option_audio');

        // Launch change of default for field option_participants_video.
        $dbman->change_field_default($table, $field);

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2020100800, 'zoom');
    }

    if ($oldversion < 2020120800) {
        // Delete config no longer used.
        set_config('calls_left', null, 'mod_zoom');
        upgrade_mod_savepoint(true, 2020120800, 'zoom');
    }

    if ($oldversion < 2021012902) {
        // Define field option_encryption_type to be added to zoom.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field(
            'option_encryption_type',
            XMLDB_TYPE_CHAR,
            '20',
            null,
            null,
            null,
            'enhanced_encryption',
            'option_authenticated_users'
        );

        // Conditionally launch add field option_encryption_type.
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2021012902, 'zoom');
    }

    if ($oldversion < 2021012903) {
        // Quite all settings in settings.php had the 'mod_zoom' prefix while it should have had a 'zoom' prefix.
        // After the prefix has been modified in settings.php, the existing settings in DB have to be modified as well.

        // Get the existing settings with the old prefix from the DB,
        // but don't get the 'version' setting as this one has to have the 'mod_zoom' prefix.
        $oldsettingsql = 'SELECT name
                          FROM {config_plugins}
                          WHERE plugin = :plugin AND name != :name';
        $oldsettingparams = ['plugin' => 'mod_zoom', 'name' => 'version'];
        $oldsettingkeys = $DB->get_fieldset_sql($oldsettingsql, $oldsettingparams);

        // Change the prefix of each setting.
        foreach ($oldsettingkeys as $oldsettingkey) {
            // Get the value of the existing setting with the old prefix.
            $oldsettingvalue = get_config('mod_zoom', $oldsettingkey);
            // Set the value of the setting with the new prefix.
            set_config($oldsettingkey, $oldsettingvalue, 'zoom');
            // Drop the setting with the old prefix.
            set_config($oldsettingkey, null, 'mod_zoom');
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2021012903, 'zoom');
    }

    if ($oldversion < 2021030300) {
        // Define index uuid (not unique) to be added to zoom_meeting_participants.
        $table = new xmldb_table('zoom_meeting_participants');
        $index = new xmldb_index('uuid', XMLDB_INDEX_NOTUNIQUE, ['uuid']);

        // Conditionally launch add index uuid.
        if (!$dbman->index_exists($table, $index)) {
            $dbman->add_index($table, $index);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2021030300, 'zoom');
    }

    if ($oldversion < 2021081900) {
        $table = new xmldb_table('zoom');

        // Define and conditionally add field recurrence_type.
        $field = new xmldb_field('recurrence_type', XMLDB_TYPE_INTEGER, '1', null, null, null, null, 'recurring');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Define and conditionally add field repeat_interval.
        $field = new xmldb_field('repeat_interval', XMLDB_TYPE_INTEGER, '2', null, null, null, null, 'recurrence_type');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Define and conditionally add field weekly_days.
        $field = new xmldb_field('weekly_days', XMLDB_TYPE_CHAR, '14', null, null, null, null, 'repeat_interval');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Define and conditionally add field monthly_day.
        $field = new xmldb_field('monthly_day', XMLDB_TYPE_INTEGER, '2', null, null, null, null, 'weekly_days');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Define and conditionally add field monthly_week.
        $field = new xmldb_field('monthly_week', XMLDB_TYPE_INTEGER, '2', null, null, null, null, 'monthly_day');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Define and conditionally add field monthly_week_day.
        $field = new xmldb_field('monthly_week_day', XMLDB_TYPE_INTEGER, '1', null, null, null, null, 'monthly_week');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Define and conditionally add field monthly_repeat_option.
        $field = new xmldb_field('monthly_repeat_option', XMLDB_TYPE_INTEGER, '1', null, null, null, null, 'monthly_week_day');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Define and conditionally add field end_times.
        $field = new xmldb_field('end_times', XMLDB_TYPE_INTEGER, '1', null, null, null, null, 'monthly_week_day');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Define and conditionally add field end_date_time.
        $field = new xmldb_field('end_date_time', XMLDB_TYPE_INTEGER, '12', null, null, null, null, 'end_times');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Define and conditionally add field end_date_option.
        $field = new xmldb_field('end_date_option', XMLDB_TYPE_INTEGER, '1', null, null, null, null, 'end_date_time');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // For a time these defaults were not being updated but needed to be. This should catch them up.

        // Changing the default of field option_host_video on table zoom to 0.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field('option_host_video', XMLDB_TYPE_INTEGER, '1', null, null, null, '0', 'option_start_type');

        // Launch change of default for field option_host_video.
        $dbman->change_field_default($table, $field);

        // Changing the default of field option_participants_video on table zoom to 0.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field('option_participants_video', XMLDB_TYPE_INTEGER, '1', null, null, null, '0', 'option_host_video');

        // Launch change of default for field option_participants_video.
        $dbman->change_field_default($table, $field);

        // Changing the default of field option_mute_upon_entry on table zoom to 1.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field('option_mute_upon_entry', XMLDB_TYPE_INTEGER, '1', null, null, null, '1', 'option_audio');

        // Launch change of default for field option_participants_video.
        $dbman->change_field_default($table, $field);

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2021081900, 'zoom');
    }

    if ($oldversion < 2021111100) {
        // Define table zoom_meeting_tracking_fields to be created.
        $table = new xmldb_table('zoom_meeting_tracking_fields');

        // Adding fields to table zoom_meeting_tracking_fields.
        $table->add_field('id', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
        $table->add_field('meeting_id', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, null);
        $table->add_field('tracking_field', XMLDB_TYPE_CHAR, '255', null, XMLDB_NOTNULL, null, null);
        $table->add_field('value', XMLDB_TYPE_TEXT, null, null, null, null, null);

        // Adding keys to table zoom_meeting_tracking_fields.
        $table->add_key('id_primary', XMLDB_KEY_PRIMARY, ['id']);

        // Adding indexes to table zoom_meeting_tracking_fields.
        $table->add_index('meeting_id', XMLDB_INDEX_NOTUNIQUE, ['meeting_id']);
        $table->add_index('tracking_field', XMLDB_INDEX_NOTUNIQUE, ['tracking_field']);

        // Conditionally launch create table for zoom_meeting_tracking_fields.
        if (!$dbman->table_exists($table)) {
            $dbman->create_table($table);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2021111100, 'zoom');
    }

    if ($oldversion < 2021111800) {
        // Define table zoom_meeting_recordings to be created.
        $table = new xmldb_table('zoom_meeting_recordings');

        // Adding fields to table zoom_meeting_recordings.
        $table->add_field('id', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
        $table->add_field('zoomid', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, null);
        $table->add_field('meetinguuid', XMLDB_TYPE_CHAR, '30', null, XMLDB_NOTNULL, null, null);
        $table->add_field('zoomrecordingid', XMLDB_TYPE_CHAR, '36', null, XMLDB_NOTNULL, null, null);
        $table->add_field('name', XMLDB_TYPE_CHAR, '300', null, XMLDB_NOTNULL, null, null);
        $table->add_field('externalurl', XMLDB_TYPE_TEXT, null, null, XMLDB_NOTNULL, null, null);
        $table->add_field('passcode', XMLDB_TYPE_CHAR, '30', null, null, null, null);
        $table->add_field('recordingtype', XMLDB_TYPE_CHAR, '30', null, XMLDB_NOTNULL, null, null);
        $table->add_field('recordingstart', XMLDB_TYPE_INTEGER, '12', null, XMLDB_NOTNULL, null, null);
        $table->add_field('showrecording', XMLDB_TYPE_INTEGER, '1', null, XMLDB_NOTNULL, null, '0');
        $table->add_field('timecreated', XMLDB_TYPE_INTEGER, '12', null, null, null, null);
        $table->add_field('timemodified', XMLDB_TYPE_INTEGER, '12', null, null, null, null);

        // Adding keys to table zoom_meeting_recordings.
        $table->add_key('id_primary', XMLDB_KEY_PRIMARY, ['id']);
        $table->add_key('zoomid_foreign', XMLDB_KEY_FOREIGN, ['zoomid'], 'zoom', ['id']);

        // Conditionally launch create table for zoom_meeting_recordings.
        if (!$dbman->table_exists($table)) {
            $dbman->create_table($table);
        }

        // Define table zoom_meeting_recordings_view to be created.
        $table = new xmldb_table('zoom_meeting_recordings_view');

        // Adding fields to table zoom_meeting_recordings_view.
        $table->add_field('id', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
        $table->add_field('recordingsid', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, null);
        $table->add_field('userid', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, null);
        $table->add_field('viewed', XMLDB_TYPE_INTEGER, '1', null, XMLDB_NOTNULL, null, '0');
        $table->add_field('timemodified', XMLDB_TYPE_INTEGER, '12', null, null, null, null);

        // Adding keys to table zoom_meeting_recordings_view.
        $table->add_key('id_primary', XMLDB_KEY_PRIMARY, ['id']);
        $table->add_key('recordingsid_foreign', XMLDB_KEY_FOREIGN, ['recordingsid'], 'zoom_meeting_recordings', ['id']);

        // Adding indexes to table zoom_meeting_recordings_view.
        $table->add_index('userid', XMLDB_INDEX_NOTUNIQUE, ['userid']);

        // Conditionally launch create table for zoom_meeting_recordings_view.
        if (!$dbman->table_exists($table)) {
            $dbman->create_table($table);
        }

        // Add new field for recordings_visible_default.
        $table = new xmldb_table('zoom');
        // Define field recordings_visible_default to be added to zoom.
        $field = new xmldb_field(
            'recordings_visible_default',
            XMLDB_TYPE_INTEGER,
            '1',
            null,
            XMLDB_NOTNULL,
            null,
            '1',
            'alternative_hosts'
        );

        // Conditionally launch add field recordings_visible_default.
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2021111800, 'zoom');
    }

    if ($oldversion < 2021112900) {
        // Define table zoom_meeting_details to be created.
        $table = new xmldb_table('zoom_meeting_details');
        // Conditionally launch add key uuid_unique.
        if (!$table->getKey('uuid_unique')) {
            $key = new xmldb_key('uuid_unique', XMLDB_KEY_UNIQUE, ['uuid']);
            $dbman->add_key($table, $key);
        }

        // Launch drop key meeting_unique.
        $key = new xmldb_key('meeting_unique', XMLDB_KEY_UNIQUE, ['meeting_id', 'uuid']);
        $dbman->drop_key($table, $key);

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2021112900, 'zoom');
    }

    if ($oldversion < 2022022400) {
        // Change the recordings_visible_default field in the zoom table.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field(
            'recordings_visible_default',
            XMLDB_TYPE_INTEGER,
            '1',
            null,
            XMLDB_NOTNULL,
            null,
            '1',
            'alternative_hosts'
        );
        $dbman->change_field_default($table, $field);

        // Change the showrecording field in the zoom table.
        $table = new xmldb_table('zoom_meeting_recordings');
        $field = new xmldb_field('showrecording', XMLDB_TYPE_INTEGER, '1', null, XMLDB_NOTNULL, null, '0');
        $dbman->change_field_default($table, $field);

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2022022400, 'zoom');
    }

    if ($oldversion < 2022031600) {
        $table = new xmldb_table('zoom');

        // Define and conditionally add field show_schedule.
        $field = new xmldb_field(
            'show_schedule',
            XMLDB_TYPE_INTEGER,
            '1',
            null,
            XMLDB_NOTNULL,
            null,
            '1',
            'recordings_visible_default'
        );
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Define and conditionally add field show_security.
        $field = new xmldb_field('show_security', XMLDB_TYPE_INTEGER, '1', null, XMLDB_NOTNULL, null, '1', 'show_schedule');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Define and conditionally add field show_media.
        $field = new xmldb_field('show_media', XMLDB_TYPE_INTEGER, '1', null, XMLDB_NOTNULL, null, '1', 'show_security');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2022031600, 'zoom');
    }

    if ($oldversion < 2022071500) {
        // Define table zoom_meeting_breakout_rooms to be created.
        $table = new xmldb_table('zoom_meeting_breakout_rooms');

        // Adding fields to table zoom_meeting_breakout_rooms.
        $table->add_field('id', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
        $table->add_field('name', XMLDB_TYPE_CHAR, '32', null, null, null, null);
        $table->add_field('zoomid', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, null);

        // Adding keys to table zoom_meeting_breakout_rooms.
        $table->add_key('primary', XMLDB_KEY_PRIMARY, ['id']);
        $table->add_key('fk_zoomid', XMLDB_KEY_FOREIGN, ['zoomid'], 'zoom', ['id']);

        // Conditionally launch create table for customfield_category.
        if (!$dbman->table_exists($table)) {
            $dbman->create_table($table);
        }

        // Define table zoom_rooms_participants to be created.
        $table = new xmldb_table('zoom_breakout_participants');

        // Adding fields to table zoom_rooms_participants.
        $table->add_field('id', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
        $table->add_field('userid', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, null);
        $table->add_field('breakoutroomid', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, null);

        // Adding keys to table zoom_rooms_participants.
        $table->add_key('primary', XMLDB_KEY_PRIMARY, ['id']);
        $table->add_key('fk_breakoutroomid', XMLDB_KEY_FOREIGN, ['breakoutroomid'], 'zoom_meeting_breakout_rooms', ['id']);

        // Conditionally launch create table for customfield_category.
        if (!$dbman->table_exists($table)) {
            $dbman->create_table($table);
        }

        // Define table zoom_rooms_groups to be created.
        $table = new xmldb_table('zoom_breakout_groups');

        // Adding fields to table zoom_rooms_groups.
        $table->add_field('id', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
        $table->add_field('groupid', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, null);
        $table->add_field('breakoutroomid', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, null);

        // Adding keys to table zoom_rooms_groups.
        $table->add_key('primary', XMLDB_KEY_PRIMARY, ['id']);
        $table->add_key('fk_breakoutroomid', XMLDB_KEY_FOREIGN, ['breakoutroomid'], 'zoom_meeting_breakout_rooms', ['id']);

        // Conditionally launch create table for customfield_category.
        if (!$dbman->table_exists($table)) {
            $dbman->create_table($table);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2022071500, 'zoom');
    }

    if ($oldversion < 2022082500) {
        $table = new xmldb_table('zoom');

        // Define and conditionally add field option_auto_recording.
        $field = new xmldb_field('option_auto_recording', XMLDB_TYPE_CHAR, '5', null, null, null, null, 'show_media');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2022082500, 'zoom');
    }

    if ($oldversion < 2022102700) {
        $table = new xmldb_table('zoom');

        // Define and conditionally add field registration.
        $field = new xmldb_field('registration', XMLDB_TYPE_INTEGER, '1', null, XMLDB_NOTNULL, null, '2', 'option_auto_recording');
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2022102700, 'zoom');
    }

    if ($oldversion < 2023080202) {
        // Issue #432: Inconsistency between the DB and schema, this is to verify everything matches.
        // Verify show_schedule, show_security, and show_media are all set to NOTNULL.
        // Verify option_auto_record is set to NOTNULL and defaults to "none".
        $table = new xmldb_table('zoom');

        // Launch change of nullability for show schedule.
        $field = new xmldb_field(
            'show_schedule',
            XMLDB_TYPE_INTEGER,
            '1',
            null,
            XMLDB_NOTNULL,
            null,
            '1',
            'recordings_visible_default'
        );
        $dbman->change_field_notnull($table, $field);

        $field = new xmldb_field('show_security', XMLDB_TYPE_INTEGER, '1', null, XMLDB_NOTNULL, null, '1', 'show_schedule');
        $dbman->change_field_notnull($table, $field);

        $field = new xmldb_field('show_media', XMLDB_TYPE_INTEGER, '1', null, XMLDB_NOTNULL, null, '1', 'show_security');
        $dbman->change_field_notnull($table, $field);

        $field = new xmldb_field('option_auto_recording', XMLDB_TYPE_CHAR, '5', null, null, null, null, 'show_media');
        $dbman->change_field_type($table, $field);

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2023080202, 'zoom');
    }

    if ($oldversion < 2023111600) {
        // Issue #326: Drop start_url from database.

        // Start zoom table modifications.
        $table = new xmldb_table('zoom');

        // Define field status to be dropped from zoom.
        $field = new xmldb_field('start_url');

        // Conditionally launch drop field status.
        if ($dbman->field_exists($table, $field)) {
            $dbman->drop_field($table, $field);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2023111600, 'zoom');
    }

    if ($oldversion < 2024012500) {
        // Version 5.1.0 incorrectly upgraded the zoom table's registration field. It should not be null and should default to 2.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field('registration', XMLDB_TYPE_INTEGER, '1', null, XMLDB_NOTNULL, null, '2', 'option_auto_recording');

        // Set any null values to the new default: 2.
        $DB->set_field_select('zoom', 'registration', '2', 'registration IS NULL');

        // Launch change of nullability for field registration.
        $dbman->change_field_notnull($table, $field);

        // Launch change of default for field registration.
        $dbman->change_field_default($table, $field);

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2024012500, 'zoom');
    }

    if ($oldversion < 2024030100) {
        // Define field grading_method to be added to zoom.
        $table = new xmldb_table('zoom');
        $field = new xmldb_field('grading_method', XMLDB_TYPE_CHAR, '10', null, null, null, null, 'grade');

        // Conditionally launch add field grading_method.
        if (!$dbman->field_exists($table, $field)) {
            $dbman->add_field($table, $field);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2024030100, 'zoom');
    }

    if ($oldversion < 2024041900) {
        // Update existing recording names to default for translatable recordingtype strings.
        $meetings = $DB->get_records('zoom');

        foreach ($meetings as $meeting) {
            $DB->set_field_select('zoom_meeting_recordings', 'name', $meeting->name, 'zoomid = ?', [$meeting->id]);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2024041900, 'zoom');
    }

    if ($oldversion < 2024070300) {
        // Update existing meeting occurrence duration to seconds.
        $occurrences = $DB->get_records('zoom_meeting_details');

        foreach ($occurrences as $occurrence) {
            $duration = $occurrence->end_time - $occurrence->start_time;
            $DB->set_field_select('zoom_meeting_details', 'duration', $duration, 'id = ?', [$occurrence->id]);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2024070300, 'zoom');
    }

    if ($oldversion < 2024072500) {
        // Changing precision of field recordingtype on table zoom_meeting_recordings to (50).
        $table = new xmldb_table('zoom_meeting_recordings');
        $field = new xmldb_field('recordingtype', XMLDB_TYPE_CHAR, '50', null, XMLDB_NOTNULL, null, null, 'passcode');

        // Launch change of precision for field recordingtype.
        $dbman->change_field_precision($table, $field);

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2024072500, 'zoom');
    }

    if ($oldversion < 2025050900) {
        // Define table zoom_ical_notifications to be created.
        $table = new xmldb_table('zoom_ical_notifications');

        // Adding fields to table zoom_ical_notifications.
        $table->add_field('id', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
        $table->add_field('zoomeventid', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, null);
        $table->add_field('notificationtime', XMLDB_TYPE_INTEGER, '12', null, XMLDB_NOTNULL, null, null);

        // Adding keys to table zoom_ical_notifications.
        $table->add_key('id_primary', XMLDB_KEY_PRIMARY, ['id']);
        $table->add_key('fk_zoomeventid', XMLDB_KEY_FOREIGN_UNIQUE, ['zoomeventid'], 'event', ['id']);

        // Conditionally launch create table for zoom_ical_notifications.
        if (!$dbman->table_exists($table)) {
            $dbman->create_table($table);
        }

        // Zoom savepoint reached.
        upgrade_mod_savepoint(true, 2025050900, 'zoom');
    }

    return true;
}

====================

file: messages.php
path: db/messages.php
codice:
<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Defines message providers for mod_zoom.
 *
 * @package    mod_zoom
 * @copyright  2023 Mo Farouk <phun.for.physics@gmail.com>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die();

$messageproviders = [
    'teacher_notification' => [],
    // The ical notifications task messages.
    'ical_notifications' => [
        'defaults' => [
            'popup' => MESSAGE_DISALLOWED,
            'email' => MESSAGE_PERMITTED + (defined('MESSAGE_DEFAULT_ENABLED') ?
                MESSAGE_DEFAULT_ENABLED : MESSAGE_DEFAULT_LOGGEDIN + MESSAGE_DEFAULT_LOGGEDOFF),
            'airnotifier' => MESSAGE_DISALLOWED,
        ],
    ],
];

====================

file: mobile.php
path: db/mobile.php
codice:
<?php
// This file is part of the Zoom module for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Zoom module capability definition
 *
 * @package    mod_zoom
 * @copyright  2018 Nick Stefanski <nmstefanski@gmail.com>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die;

$addons = [
    "mod_zoom" => [
        "handlers" => [
            'zoommeetingdetails' => [
                'displaydata' => [
                'title' => 'pluginname',
                    'icon' => $CFG->wwwroot . '/mod/zoom/pix/icon.gif',
                    'class' => '',
                ],

                'delegate' => 'CoreCourseModuleDelegate',
                'method' => 'mobile_course_view', // Main function in \mod_zoom\output\mobile.
                'offlinefunctions' => [
                    'mobile_course_view' => [],
                ],
            ],
        ],
        'lang' => [
            ['pluginname', 'zoom'],
            ['join_meeting', 'zoom'],
            ['unavailable', 'zoom'],
            ['meeting_time', 'zoom'],
            ['duration', 'zoom'],
            ['passwordprotected', 'zoom'],
            ['password', 'zoom'],
            ['joinlink', 'zoom'],
            ['joinbeforehost', 'zoom'],
            ['starthostjoins', 'zoom'],
            ['startpartjoins', 'zoom'],
            ['option_audio', 'zoom'],
            ['status', 'zoom'],
            ['recurringmeetinglong', 'zoom'],
        ],
    ],
];

====================

file: CHANGES.md
path: CHANGES.md
codice:
### Releases ###

#### v5.4.5 ####

- Bugfix: Case-insensitive comparisons for alternative host emails #677
- Hardening: Verify zoomid when toggling recording visibility #681
- CI: add Moodle 5.1 checks #679

#### v5.4.4 ####

- Hardening: Shell arguments should always be escaped #671 (thanks @OshratLuski, @nadavkav)

#### v5.4.3 ####

- Bugfix: Rename string to avoid flawed database upgrade step #668 (thanks @samwitzig)

#### v5.4.2 ####

- Bugfix: Fix SQL compatibility in upgrade step #664 (thanks @izendegi, @SimonThornett)

#### v5.4.1 ####

- Bugfix: Fix stringid capitalization in upgrade step #659 (thanks @Ethan-DevIT)
- Bugfix: Dashboard API was not working for get_meeting_reports #662 (thanks @Caspiofri)
- Code quality: Apply moodle-cs for line wrapping in send_ical_notifications

#### v5.4.0 ####

- Feature: Send iCal Notifications #623 (thanks @paulandm, @OpenCollabZA)
  - New setting `zoom/sendicalnotifications`
  - New message `mod_zoom/ical_notifications`
  - New table `zoom_ical_notifications`
  - New task `mod_zoom\task\send_ical_notifications`
- Bugfix: Create Zoom user webservice method used outdated action. #655 (thanks @yedidiaklein)
- Bugfix: Detailed error messages when editing activities #656 (thanks @Chatharina)
- Code quality: Check Moodle 5.0 #654

#### v5.3.1 ####

- Regression: Tracking fields task missing variable #648 (thanks @lorenzogreco, @phette23, @izendegi)
  - Introduced in v5.3.0 when checking necessary scopes for tasks.

#### v5.3.0 ####

- Feature: Protect groups from license reassignment #630 (thanks @izendegi, @tsostef, @lcollong)
  - New setting `zoom/protectedgroups`
  - Optional OAuth scope `group:read:list_groups:admin` or `group:read:admin`
- Bugfix: Incorrect rendering of HTML characters in recording passcodes #637 (thanks @FrancescoTerrosi)
- Bugfix: More detailed error messages #639 (thanks @ahmadalwa)
- Bugfix: Check a task's necessary scopes prior to API calls #642 (thanks @syedaawais)
- Bugfix: Remove calendar events for deleted meeting occurrences #645 (thanks @mei-cberry)
- Code quality: Forward compatibility for PHPUnit #640
- Regression: Moodle 3.7 support #638 (thanks @gzvol)
  - Introduced in v5.2.0 when adding attendance-based grading.
- Regression: Moodle 3.8+ support #644 (thanks @cybernotic, @bobopinna)
  - Introduced in unreleased code when fixing Moodle 3.7 support.

#### v5.2.5 ####

- Bugfix: Validation for registration #622 (thanks @paulandm)
- Code quality: Check Moodle 4.5; skip Moodle 4.2 #631
- Code quality: Remove legacy reference to local_mobile service #632

#### v5.2.4 ####

- Bugfix: Apply Moodle filters to the Zoom topic and description #615 (thanks @behanw)
- Bugfix: Temporarily use string 'null' when `recording_type` is null #620 (thanks @smangancap)
- Accessibility: Migrate Bootstrap `.label` to `.badge` (Bootstrap 3 -> 4/5) #608 (thanks @sgrandh3)
- Accessibility: Add table headers and IDs to activity details sections and rows #612 (thanks @a-kempka)
- Code quality: Check Moodle 4.4 and PHP 8.3 #611

#### v5.2.3 ####

- Bugfix: Duration language string was incorrectly specifying units #250 (thanks @abias)
- Bugfix: Stop using deprecated core-course-module-description for mobile app v4.4.0 #602 (thanks @dpalou)
- Code quality: Align with moodle-cs v3.4.9 #605
- Regression: `recordingtype` column was too small for some type strings #605 (thanks @samwitzig, @acquaalta)
  - Introduced in v5.2.1 when fixing recording type language strings.

#### v5.2.2 ####

- Bugfix: Keep recordings even if the API errors #593 (thanks @LGPoly, @mjleblanc)

#### v5.2.1 ####

- Bugfix: Set icon size to something reasonable on Moodle 4.3 #581 (thanks @haietza)
- Bugfix: Save Zoom data (e.g. join_url) when updating instance #585 (thanks @selimmeziti)
- Bugfix: Form sections can now toggle independently #587 (thanks @kiratskitizing)
- Bugfix: Differentiate between multiple recording types #578 (thanks @welegionsr)
- Bugfix: Granular OAuth scopes work now #590 (thanks @amendezinserver, @jport500, @haietza, Kohei SHIRAHAMA)
- Code quality: Move function from view page to locallib #584
- Code quality: Freshen GitHub Action to match moodle-plugin-ci #584
- Code quality: Align with moodle-cs v3.4.6 #584

#### v5.2.0 ####

- Feature: Grading based on attendance duration #477 (thanks @fmido88)
  - New settings `zoom/gradingmethod`, `zoom/unamedisplay`
  - New per activity setting `grading_method`

#### v5.1.6 ####

- Bugfix: Update NULL registration values to fix upgrade step #574 (thanks @michael-milette)
- Code quality: Move changelog to CHANGES.md and upgrade.txt #572

#### v5.1.5 ####

- Bugfix: Add PNG/SVG calendar icon for Moodle 4.3 #558 (thanks @ScottVerbeek)
- Bugfix: Display user fullname in breakout room participant list #562 (thanks @mofetdanielsmolkin)
- Bugfix: Sort session report by start time #567
- Code quality: Namespace CSS identifiers #560 (thanks @danielcifuentesopen)
- Code quality: Optimize SVGs #561 (thanks @jakearchibald for SVGOMG)
- Code quality: Remove long-forgotten todo PHPDoc tags causing warnings in moodle-cs v3.3.13
- Regression: Registration field default was accidentally upgrading to null #565 (thanks @michael-milette)
  - Introduced in v5.1.0 when fixing recording field definition.

#### v5.1.4 ####

- Bugfix: Avoid breaking completion defaults form in Moodle 4.3 #555 (thanks @opitz)
- Regression: 'Use' missing classes required for Moodle app #554 (thanks ramprakash k)
  - Introduced in v5.1.1 when moving classes into namespaces.

#### v5.1.3 ####

- Bugfix: Allow editing a past Zoom meeting without changing the time #545 (thanks @davefoord, @tlock)
- Bugfix: Remove unused start_url field from the database #546 (thanks @ShilVita)
- Regression: "Recurring No Time" admin setting was defaulting to "Daily" #544 (thanks @easegill)
  - Introduced in v4.9.0 when adding support for meeting registration.

#### v5.1.2 ####

- Bugfix: Skip redundant calendar permissions check #535 (thanks @danowar2k)
- Bugfix: Initialize scopes from cache to avoid TypeError #542 (thanks @foxlapinou)
- Regression: Restore exceptions were not being caught #537
  - Introduced in v5.1.1 when moving classes into namespaces.
- Code quality: Void test return types in moodle-cs v3.3.10 #536

#### v5.1.1 ####

- Bugfix: Get all meeting recordings, not just the last occurrence #517 (thanks @LGPoly)
- Bugfix: Choose meeting reports API based on OAuth permissions #525 (thanks @xmontana)
- Bugfix: Get meeting reports based on end time #514 (thanks @xmontana)
- Bugfix: Stop showing dates for 'No Fixed Time' meetings #529 (thanks @Melle-Amu)
- Bugfix: Fix external class namespace #530 (thanks @danmarsden)
- Bugfix: Store recording types as language keys, not translated strings #516
- Bugfix: Define testcase class properties (PHP 8.2) #522
- Code quality: Align with Moodle's new moodle-extra ruleset #521
- Code quality: Array syntax updates in moodle-cs v3.3.7 #524
- Code quality: Test against Moodle 4.3 and PHP 8.2 #531

#### v5.1.0 ####

- Feature: Show activity date/time directly on course page #509 (thanks @cdipe)
- Regression: Auto recording was forced off by default #505 (thanks @emmarichardson)
  - Introduced in v4.7.0 when adding automatic recording settings.
- Bugfix: Validate meeting name length using Zoom's 200 character limit #512 (thanks @lcollong)
- Bugfix: Resolve database inconsistencies #505 (thanks @fabianbatioja, @foxlapinou)
- Bugfix: Skip grading/completion during pre-registration #507 (thanks @tbeachy)
- Bugfix: Correct error message handling #503 (thanks @jwalits)
- Bugfix: Provide prescribed Promise parameters #499 (thanks @fmido88)

#### v5.0.0 ####

- Backward incompatible: Drop support for JWT authentication (thanks @aspark21)
  - Zoom requires everyone to use Server-to-Server OAuth by September 1, 2023
- Backward incompatible: Require PHP 7.1+ (Moodle 3.7+) (thanks @rlaneIT)
- Backward incompatible: Drop Moodle 3.4 mobile support

#### v4.10.3 ####

- Bugfix: Also use proxy settings for OAuth token request #494 (thanks @adnbes)
- Bugfix: Clean up exception handling to avoid notice #482 (thanks @andremenrath)
- Bugfix: Avoid course/activity completion form overhead #481 (thanks @phette23)
- Regression: PHP 7.0 class constant visibility errors #495 (thanks @rlaneIT)
  - Introduced in v4.10.1 when aligning with PSR-12 coding standards.

#### v4.10.2 ####

- Regression: Instructors were unable to edit Zoom activity completion defaults #479 (thanks @phette23)
  - Introduced in v4.6.0 when adding breakout room support.
- Bugfix: Course reset now verifies that the Zoom checkbox is checked #483 (thanks @carlosalal)

#### v4.10.1 ####

- Bugfix: Stop showing finished events in My Overview block #451 (thanks @nstefanski)
- Bugfix: Automatically retry on TLS connection error #466 (thanks @lcollong)
- Bugfix: Allow restoring activiting that are missing `option_auto_recording` #470 (thanks @lexxkoto)
- Bugfix: Document that each Moodle install needs its own OAuth app #475 (thanks @DLM-unipd, @haietza)
- Bugfix: Check required scopes before caching OAuth token #475 (thanks @tbeachy)
- Code quality: Align with Moodle-compatible PSR-1 and PSR-12 rules #465
- Special thanks to @rickbeasley for his contributions to this plugin and to the team.

#### v4.10.0 ####

- Feature: Option for redefine licenses to only affect users on 'this' Moodle server #436 (thanks @KepaUrzelai)
  - New setting `zoom/instanceusers`
- Bugfix: Process recordings deletes one meeting at a time #439 (thanks @juanbrunetmf)
- Code quality: Use short array syntax (MDLSITE-4776) #447
- Code quality: One space around assignment operators (MDLSITE-6594) #457

#### v4.9.2 ####

- Bugfix: New meetings did not know which user to check for security settings #438 (thanks @haietza)
- Bugfix: Use select field so registration option saves correctly #448 (thanks @paulandm)
- Compatibility: grunt rebuild against Moodle 4.1 #446

#### v4.9.1 ####

- Regression: Administrators without Zoom account were unable to edit #422 (thanks @juanbrunetmf)
  - Introduced in v4.7.0 when adding automatic recording options.
- Bugfix: Respect host settings for meeting options and reduce unnecessary API calls #422
- Bugfix: Always request JSON API responses and show error details #426 (thanks @sascha-serwe)
- Bugfix: Default start time should be in the future and be a multiple of 5 minutes #427

#### v4.9.0 ####

- Feature: Allow Registration #412 (thanks @paulandm, @haietza, @MoleLR, @lcollong, @louisaoc)
  - New setting `zoom/defaultregistration`
  - New per activity setting `registration`
- Bugfix: Update meetings task was throwing an exception #421 (thanks @lexxkoto)
- Bugfix: Add missing cache definition language string #408 (thanks @aspark21)
- Bugfix: Use user-level meeting security configuration #408
  - Removed OAuth scope: `account:read:admin`
- Regression: Moodle < 3.4 does not support hideIf()
  - Introduced in v3.5 of this plugin while tidying the form UI.
  - Minimum required Moodle version officially increased to 3.4.

#### v4.8.1 ####

- Bugfix: Moodle 4 was displaying the activity description twice #417 (thanks @Laur0r, @haietza)
- Bugfix: Avoid HTTP/2 error when using Server-to-Server OAuth #418 (thanks @phette23)

#### v4.8.0 ####

- Feature: Support Server-to-Server OAuth app #387 (thanks @haietza, @mhughes2k)
  - New settings `zoom/accountid`, `zoom/clientid`, `zoom/clientsecret`
  - Reminder: You must [switch from JWT to Server-to-Server OAuth by June 2023](https://developers.zoom.us/docs/internal-apps/jwt-faq/).
- Regression: Locked settings were not being applied #407 (thanks @krab-stik)
  - Introduced in v4.7.0 while adding support for automatic recording.

#### v4.7.0 ####

- Feature: Allow automatic recording #390 (thanks @aduranterres, @lcollong)
  - New settings `zoom/recordingoption`, `zoom/allowrecordingchangeoption`
  - New per activity setting `option_auto_recording`
  - Known issue: Causes pre-existing events to turn off automatic recording when edited.
- Performance: Static caching of repeated API calls #402 (thanks @aduranterres)

#### v4.6.2 ####

- Regression: Rename mustache templates for backward compatibility #398 (thanks @PhilipBeacon)
  - Introduced in v4.6.0 by new mustache templates in sub-directories (a Moodle 3.8 feature).
- Bugfix: Recognize the Webinar capabilities of a Zoom Events license #338 (thanks @dottbarbieri)
- Bugfix: Avoid PHP Warning when restoring Zoom activities without breakout room data #399

#### v4.6.1 ####

- Bugfix: Avoid JavaScript error when 'Show More' button does not exist #392 (thanks @mwithheld)
- Bugfix: Add missing privacy coverage for breakout rooms; fix privacy data deletion #395 (thanks @hdagheda)

#### v4.6.0 ####

- Feature: Pre-assign Breakout Rooms #371 (thanks @annouarf, @levemar, University of Montreal, @mhughes2k)
- Bugfix: Validate start times and duration for timed recurring meetings #389 (thanks @nchan31, @jwalits)

#### v4.5.3 ####

- Bugfix: Allow plugin settings to update without a configuration exception #386 (thanks @acquaalta)

#### v4.5.2 ####

- Regression: Avoid requiring paid accounts for meeting default settings #383 (thanks @nstefanski, @nickchen, @valeriy67, @obook)
  - Introduced in v3.5 to determine passcode requirements.
- Bugfix: Allow course restore to complete even when Zoom is not fully configured #378
- Code quality: Require PHPUnit to pass without warnings #379

#### v4.5.1 ####

- Regression: Fix Zoom activity icon visibility #375 (thanks @foxlapinou)
- Compatibility: Fix PHPUnit deprecation warnings #373

#### v4.5.0 ####

- Feature: Support for Reset course functionality #370 (thanks @izendegi)
- Compatibility: Improved support for Moodle 4.0 #369

#### v4.4.0 ####

- Feature: Allow configuration of section visibility on the view page #363 (thanks @aduranterres, @rayjbarrett1)
  - New settings `zoom/defaultshowschedule`, `zoom/defaultshowsecurity`, `zoom/defaultshowmedia`
  - New per activity settings `show_schedule`, `show_security`, `show_media`
- Feature: Allow administrator to set webinar by default (when available) #367 (thanks @marcellobarile)
  - New setting `zoom/webinardefault`
- Code quality: specify code coverage for tests #367

#### v4.3.4 ####

- Privacy: Add tests, support recordings, fix existing code #345 (thanks @jwalits, @tuanngocnguyen, @mattporritt, @marcghaly)
- Compatibility: grunt rebuild for MDL-73915 #364

#### v4.3.3 ####

- Fix recording table database schema definitions #358 (thanks @jwalits)
- Compatibility: Moodle upstream upgraded to php-jwt v6.0 #359
- Renamed primary branch in GitHub to `main` #353

#### v4.3.2 ####

- Only cache successful Zoom user ID values #350 (thanks @merrill-oakland)
- Code quality: Align with moodle-local_codechecker v3.0.5 #351

#### v4.3.1 ####

- Fix database schema alignment and associated code #335 (thanks @TomoTsuyuki)
- Run "Update Meetings" task once per day by default #342 (thanks @deraadt for reporting)
  - Note: You may need to manually adjust your task schedule on existing installs.

#### v4.3 ####

- Add support for Zoom Cloud Recordings #292 (thanks @jwalits, @nstefanski, @abias, ETH Zrich)
  - New setting `zoom/viewrecordings`
  - New per activity setting `recordings_visible_default`
- Fix tracking field PHP notices #337 (thanks @alina-kiz, @ndunand, @haietza)

#### v4.2.1 ####

- Fix PHP 8 deprecation warning #332 (thanks @ndunand)
- Fix duplicate column name on "All Meetings" page #330

#### v4.2 ####

- Add support for Zoom Tracking Fields #308 (thanks @haietza, @porcospino)
  - New setting `zoom/defaulttrackingfields`
- Send plaintext version of Moodle intro to Zoom #290 (thanks @Ottendahl, @abias, @yanus for reporting)
  - Note: To avoid losing Moodle's rich text, we no longer synchronize Zoom's topic back to Moodle.
- Reduce zoom_refresh_events overreach; fix 'quick edit' issue #320 (thanks @alina-kiz, @jwalits for testing)
- Add error handling and improve consistency in Zoom activity restore #328 (thanks @jonof)

#### v4.1.3 ####

- Always use a fresh copy of start_url #316 (thanks @ShilVita for reporting)
- Synchronize calendar events consistently #319 (thanks @martinoesterreicher for reporting)
- Update JWT library to v5.4.0 #312

#### v4.1.2 ####

- Make loadmeeting consistent via web and mobile (event, completion, grade, etc) #307 (thanks @nstefanski)

#### v4.1.1 ####

- Fix invitation class not found exception #296 (thanks @byvamo for reporting)

#### v4.1 ####

- Allow configuration of Zoom identifier #280 (thanks @jwalits, @abias, @jonlan)
  - New setting `zoom/apiidentifier`
- Allow configuration of Zoom API endpoint #293 (thanks @abias, @didier63)
  - New setting `zoom/apiendpoint`
- Use case-insensitive email comparison for schedule_for #295 (thanks @stopfstedt, @briannwar)

#### v4.0 ####

- Fully support recurring meetings #258 (thanks @abias, @jwalits, ETH Zrich)
  - New setting `zoom/invitationremoveicallink`
  - Backward incompatible change: exported iCal events now match Moodle's uid format
- Retroactively fix database schema defaults #291 (thanks @foxlapinou for reporting)

#### v3.8.1 ####

- Only allow real host to use start_url #285 (thanks @abias for reporting)

#### v3.8 ####

- Add support for Ionic 5 #269 (thanks @dpalou)
- Improve update_meetings scheduled task #263 (thanks @abias)
- Re-enable mustache continuous integration #276
- Treat alternative hosts as a possible host #275
- Update `exists_on_zoom` consistently #273 (thanks @abias for reporting)
- Update `timemodified` only when needed #279 (thanks @abias for reporting)
- Fix meeting invitation issues #267, #274 (thanks @abias, @nstefanski, @andrewmadden for feedback)

#### v3.7 ####

- Allow administrators to selectively remove Meeting Invitation details #235 (thanks @andrewmadden)
  - New capabilities `mod/zoom:viewjoinurl` and `mod/zoom:viewdialin`
- Track completion for mobile users #238 (thanks @nstefanski, @tzerafnx)
- Fix backup and restore of several zoom activity-level fields #247 (thanks @abias)
- Fix meeting reports task for some already-numeric end times #236 (thanks @lcollong)
- Fix list of alternative hosts to only include active users #252 (thanks @abias)
- Fix PHP 7.1 compatibility issue #243
- Fix encryption type validation #232 (thanks @abias)
- Clean up error messages / efficiency on the view page #245 (thanks @abias)

#### v3.6 ####

- Fixed fatal regression on settings.php for Moodle < 3.7 (Thanks abias)
- Fixed debugging messages that occur for users without webinar licenses
- Various string improvements

#### v3.5 ####

- Removed language translations. Please submit language translations to AMOS (https://lang.moodle.org/)
- Fixed bug causing downloading of meeting participation reports to fail
- Added new settings for E2EE, Webinars, Alternative hosts, Download iCal,
  Meeting capacity warning, and Enable meeting links (Thanks abias)
- Improved UI for admin and module settings (Thanks abias)
- Support for admins to update Zoom meeting participation reports
- Quick editing Zoom meeting name will now update calendar event
- Support for more advanced passcode requirements
- This will be the last supported release by UCLA. This plugin will now be maintained by jrchamp and NC State DELTA.

#### v3.4 ####

- Used Dashboard API to improve get_meeting_reports task
- Added meeting invite text to calendar and meeting page to provide phone details
- Zoom meetings now appear in Timeline block (Thanks nstefanski)
- Added basic Analytic indicators (Thanks danmarsden)
- Fixed calendar icon not showing up for non-Boost themes (Thanks danowar2k)
- Added support for Moodle 3.10
- Allow privileged users without Zoom to edit meetings (Thanks jrchamp)
- Fixed bugs related to scheduler support (Thanks jrchamp)
- Fixed participant count for meeting sessions so it only counts unique users
- Zoom descriptions keep HTML formatting (Thanks mhughes2k)
- Fixed failing DB schema checks (Thanks dvdcastro)
- Requiring passcodes is now a site wide configuration

#### v3.3 ####

- Fixed problems with error handling (Thanks kbowlerarden and jrchamp)
- Added language translations for uk, pl, and ru (Thanks mkikets99)
- Thanks to kubilayagi for all his work on the Zoom plugin these past 2.5 years and good luck on future endeavors

#### v3.2 ####

- Password/Passcode changes
  - Renamed passwords to passcodes
  - Added passcodes to Webinars (Thanks jrchamp)
  - Passcodes are now required
- Implement completion viewed when user joins meeting (Thanks nstefanski)
- License recycling improvement (Thanks mrvinceo)
- Added scheduler support (Thanks mhughes2k)
- Added support for Zoom API changes related to next_page_token and rate limiting
- Fixed error handling for non-English Zoom deployments
- Added Travis CI support

#### v3.1 ####

- Added site config to mask participant data form appearing in reports (useful for sites that mask participant data, e.g., for HIPAA) (Thanks stopfstedt)

#### v3.0 ####

- Support Retry-After header in Zoom API
- Supports longer Zoom meeting ids
- Added more meeting options: Mute upon entry, Enable waiting room, Only authenticated users.
- Changed to be Host/Participant video to off by default
- Meeting have passwords set by default
- Improvements to "Get meeting report" task to better handle data errors
- Removed "Attendee attention" column in participant report, because it has been removed by Zoom
- Added a new setting 'proxyurl' that can be used to set a proxy as hostname:port. This will be used for communication with the Zoom API (but not anywhere else in Moodle). (Thanks pefeigl)
- Fixed meeting dates during restore (Thanks nstefanski)
- Added German translation (Thanks pefeigl)

#### v2.2 ####

- Resized svg icon (Thanks stopfstedt)
- Fixed error handling for 'User not found on this account' (Thanks nstefanski and tzerafnx)
- Incorrect return value for zoom_update_instance (Thanks jrchamp)
- Added global search support
- Fixed inconsistent "start_time" column (Thanks tuanngocnguyen)

#### v2.1 ####

- Moodle 3.7 support (Thanks danmarsden)
- Privacy API support
- Moodle mobile support fixed for 3.5 (Thanks nstefanski)
- iCal generation
- Various bug fixes/improvements.

#### v2.0.1 ####

- Fixing conflicts with Firebase\JWT library. If more conflicts are found,
  please contact plugin maintainer to add to list in classes/webservice.php.

#### v2.0 ####

- Updated to support Zoom API V2
- Added SVG icon for resolution independence (Thanks rrusso)
- Additional logging
- License recycling (Thanks tigusigalpa)
- Participant reports improved (local storage and added attentiveness score)
- GDPR compliance
- Support for alternative hosts

#### v1.7 ####

- Lang string BOM fix (Thanks roperto/tonyjbutler)
- Support for proxy servers (Thanks jonof)
- Improved handling of meetings not found on Zoom
- Exporting of session participants to xls
- Improved participants report
- Fixing coding issues

#### v1.6 ####

- Addressed coding issues brought up by a MoodleRooms review done for CSUN.

#### v1.5 ####

- Fixed upgrade issues with PostgreSQL

#### v1.4 ####

- Added missing lang string for cache.
- Updated activity chooser help text.
- Added support for webinars.
- Fixing Unicode issues.

#### v1.3 ####

- Fixed join before host option.
- Added Zoom user reports.
- Added connection status checking on settings page.

#### v1.2 ####

- Allowing Zoom users to be found by other login types than just SSO.

#### v1.1 ####

- Issue #1: allow underscores in API key and secret.
- Issue #2: Fix language strings to not use concatenation.
- Added support for "group members only".

#### v1.0 ####

- Initial release

====================

file: showrecording.php
path: showrecording.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Toggle the visibility of zoom meeting recordings.
 *
 * @package    mod_zoom
 * @copyright  2020 Nick Stefanski <nmstefanski@gmail.com>
 * @author     2021 Jwalit Shah <jwalitshah@catalyst-au.net>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

require(__DIR__ . '/../../config.php');
require_once($CFG->libdir . '/moodlelib.php');
require_once(__DIR__ . '/locallib.php');

$meetinguuid = required_param('meetinguuid', PARAM_TEXT);
$recordingstart = required_param('recordingstart', PARAM_INT);
$showrecording = required_param('showrecording', PARAM_INT);

if (!get_config('zoom', 'viewrecordings')) {
    throw new moodle_exception('recordingnotvisible', 'mod_zoom', get_string('recordingnotvisible', 'zoom'));
}

[$course, $cm, $zoom] = zoom_get_instance_setup();
require_login($course, true, $cm);

$context = context_module::instance($cm->id);
$PAGE->set_context($context);
require_capability('mod/zoom:addinstance', $context);

$urlparams = ['id' => $cm->id];
$url = new moodle_url('/mod/zoom/recordings.php', $urlparams);
if (!confirm_sesskey()) {
    redirect($url, get_string('sesskeyinvalid', 'mod_zoom'));
}

// Find the video recording and audio only recording pair that matches the criteria.
$recordings = $DB->get_records(
    'zoom_meeting_recordings',
    [
        'zoomid' => $zoom->id,
        'meetinguuid' => $meetinguuid,
        'recordingstart' => $recordingstart,
    ]
);
if (empty($recordings)) {
    throw new moodle_exception('recordingnotfound', 'mod_zoom', '', get_string('recordingnotfound', 'zoom'));
}

$now = time();

// Toggle the showrecording value.
if ($showrecording === 1 || $showrecording === 0) {
    foreach ($recordings as $rec) {
        $rec->showrecording = $showrecording;
        $rec->timemodified = $now;
        $DB->update_record('zoom_meeting_recordings', $rec);
    }
}

redirect($url);

====================

file: mod_form.php
path: mod_form.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * The main zoom configuration form
 *
 * It uses the standard core Moodle formslib. For more info about them, please
 * visit: http://docs.moodle.org/en/Development:lib/formslib.php
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot . '/course/moodleform_mod.php');
require_once($CFG->dirroot . '/mod/zoom/lib.php');
require_once($CFG->dirroot . '/mod/zoom/locallib.php');

/**
 * Module instance settings form
 */
class mod_zoom_mod_form extends moodleform_mod {
    /**
     * Helper property for showing the scheduling privilege options.
     *
     * @var bool
     */
    private $showschedulingprivilege;

    /**
     * Defines forms elements
     */
    public function definition() {
        global $PAGE, $USER, $OUTPUT;

        // We don't do anything custom with completion data, so avoid doing any unnecessary work.
        $completionpagetypes = [
            'course-defaultcompletion' => 'Edit completion default settings (Moodle >= 4.3)',
            'course-editbulkcompletion' => 'Edit completion settings in bulk for a single course',
            'course-editdefaultcompletion' => 'Edit completion default settings (Moodle < 4.3)',
        ];
        if (isset($completionpagetypes[$PAGE->pagetype])) {
            return;
        }

        $config = get_config('zoom');
        $PAGE->requires->js_call_amd("mod_zoom/form", 'init');

        $isnew = empty($this->_cm);

        $zoomuserid = zoom_get_user_id(false);

        // If creating a new instance, but the Zoom user does not exist.
        if ($isnew && $zoomuserid === false) {
            // Assume user is using Zoom for the first time.
            $errstring = 'zoomerr_usernotfound';
            // After they set up their account, the user should continue to the page they were on.
            $nexturl = $PAGE->url;
            zoom_fatal_error($errstring, 'mod_zoom', $nexturl, $config->zoomurl);
        }

        // Array of emails and proper names of Moodle users in this course that
        // can add Zoom meetings, and the user can schedule.
        $scheduleusers = [];

        $canschedule = false;
        if ($zoomuserid !== false) {
            // Get the array of users they can schedule.
            $canschedule = zoom_webservice()->get_schedule_for_users($zoomuserid);
        }

        if (!empty($canschedule)) {
            // Add the current user.
            $canschedule[$zoomuserid] = new stdClass();
            $canschedule[$zoomuserid]->email = $USER->email;

            // If the activity exists and the current user is not the current host.
            if (!$isnew && $zoomuserid !== $this->current->host_id) {
                // Get intersection of current host's schedulers and $USER's schedulers to prevent zoom errors.
                $currenthostschedulers = zoom_webservice()->get_schedule_for_users($this->current->host_id);
                if (!empty($currenthostschedulers)) {
                    // Since this is the second argument to array_intersect_key,
                    // the entry from $canschedule will be used, so we can just
                    // use true to avoid a service call.
                    $currenthostschedulers[$this->current->host_id] = true;
                }

                $canschedule = array_intersect_key($canschedule, $currenthostschedulers);
            }

            // Get list of users who can add Zoom activities in this context.
            $moodleusers = get_enrolled_users($this->context, 'mod/zoom:addinstance', 0, 'u.*', 'lastname');

            // Check each potential host to see if they are a valid host.
            foreach ($canschedule as $zoomuserinfo) {
                $zoomemail = strtolower($zoomuserinfo->email);
                if (isset($scheduleusers[$zoomemail])) {
                    continue;
                }

                if ($zoomemail === strtolower($USER->email)) {
                    $scheduleusers[$zoomemail] = get_string('scheduleforself', 'zoom');
                    continue;
                }

                foreach ($moodleusers as $muser) {
                    if ($zoomemail === strtolower($muser->email)) {
                        $scheduleusers[$zoomemail] = fullname($muser);
                        break;
                    }
                }
            }
        }

        if (!$isnew) {
            try {
                zoom_webservice()->get_meeting_webinar_info($this->current->meeting_id, $this->current->webinar);
            } catch (\mod_zoom\webservice_exception $error) {
                // If the meeting can't be found, offer to recreate the meeting on Zoom.
                if (zoom_is_meeting_gone_error($error)) {
                    $errstring = 'zoomerr_meetingnotfound';
                    $param = zoom_meetingnotfound_param($this->_cm->id);
                    $nexturl = "/mod/zoom/view.php?id=" . $this->_cm->id;
                    zoom_fatal_error($errstring, 'mod_zoom', $nexturl, $param, "meeting/get : $error");
                } else {
                    throw $error;
                }
            }
        }

        // If the current editing user has the host saved in the db for this meeting on their list
        // of people that they can schedule for, allow them to change the host, otherwise don't.
        $allowschedule = false;
        if (!$isnew) {
            // Only need to check if there are scheduling options available.
            if (!empty($scheduleusers)) {
                try {
                    $founduser = zoom_get_user($this->current->host_id);
                    if ($founduser && array_key_exists($founduser->email, $scheduleusers)) {
                        $allowschedule = true;
                    }
                } catch (moodle_exception $error) {
                    // Don't need to throw an error, just leave allowschedule as false.
                    $allowschedule = false;
                }
            }
        } else {
            $allowschedule = true;
        }

        // Start of form definition.
        $mform = $this->_form;

        // Adding the "general" fieldset, where all the common settings are showed.
        $mform->addElement('header', 'general', get_string('general', 'form'));

        // Add title (stored in database as 'name').
        $mform->addElement('text', 'name', get_string('title', 'zoom'), ['size' => '64']);
        $mform->setType('name', PARAM_TEXT);
        $mform->addRule('name', null, 'required', null, 'client');
        $mform->addRule('name', get_string('maximumchars', '', 200), 'maxlength', 200, 'client');

        // Add description 'intro' and 'introformat'.
        $this->standard_intro_elements();

        // Adding the "schedule" fieldset, where all settings relating to date and time are shown.
        $mform->addElement('header', 'schedule', get_string('schedule', 'mod_zoom'));
        $mform->setExpanded('schedule');

        // Add date/time. Validation in validation().
        $starttimeoptions = [
            'step' => 5,
            'defaulttime' => time() + 3600,
        ];
        $mform->addElement('date_time_selector', 'start_time', get_string('start_time', 'zoom'), $starttimeoptions);
        // Start time needs to be enabled/disabled based on recurring checkbox as well recurrence_type.
        // Moved this control to javascript, rather than using disabledIf.

        // Add duration.
        $mform->addElement('duration', 'duration', get_string('duration', 'zoom'), ['optional' => false]);
        // Validation in validation(). Default to one hour.
        $mform->setDefault('duration', ['number' => 1, 'timeunit' => 3600]);
        // Duration needs to be enabled/disabled based on recurring checkbox as well recurrence_type.
        // Moved this control to javascript, rather than using disabledIf.

        // Add recurring widget.
        $mform->addElement(
            'advcheckbox',
            'recurring',
            get_string('recurringmeeting', 'zoom'),
            get_string('recurringmeetingthisis', 'zoom')
        );
        $mform->setDefault('recurring', $config->defaultrecurring);
        $mform->addHelpButton('recurring', 'recurringmeeting', 'zoom');

        // Add options for recurring meeting.
        $recurrencetype = [
            ZOOM_RECURRINGTYPE_DAILY => get_string('recurrence_option_daily', 'zoom'),
            ZOOM_RECURRINGTYPE_WEEKLY => get_string('recurrence_option_weekly', 'zoom'),
            ZOOM_RECURRINGTYPE_MONTHLY => get_string('recurrence_option_monthly', 'zoom'),
            ZOOM_RECURRINGTYPE_NOTIME => get_string('recurrence_option_no_time', 'zoom'),
        ];
        $mform->addElement('select', 'recurrence_type', get_string('recurrencetype', 'zoom'), $recurrencetype);
        // If the defaultrecurring option is active, set default recurrence_type to be No Fixed Time.
        if ($config->defaultrecurring == 1) {
            $mform->setDefault('recurrence_type', ZOOM_RECURRINGTYPE_NOTIME);
        }
        $mform->hideif('recurrence_type', 'recurring', 'notchecked');

        // Repeat Interval options.
        $options = [];
        for ($i = 1; $i <= 90; $i++) {
            $options[$i] = $i;
        }

        $group = [];
        $group[] = $mform->createElement('select', 'repeat_interval', '', $options);
        $htmlspantextstart = '<span class="repeat_interval" id="interval_';
        $htmlspantextend = '</span>';
        $group[] = $mform->createElement('html', $htmlspantextstart . 'daily">' . get_string('day', 'zoom') . $htmlspantextend);
        $group[] = $mform->createElement('html', $htmlspantextstart . 'weekly">' . get_string('week', 'zoom') . $htmlspantextend);
        $group[] = $mform->createElement('html', $htmlspantextstart . 'monthly">' . get_string('month', 'zoom') . $htmlspantextend);
        $mform->addGroup($group, 'repeat_group', get_string('repeatinterval', 'zoom'), null, false);
        $mform->hideif('repeat_group', 'recurrence_type', 'eq', ZOOM_RECURRINGTYPE_NOTIME);
        $mform->hideif('repeat_group', 'recurring', 'notchecked');

        // Weekly options.
        $weekdayoptions = zoom_get_weekday_options();
        $group = [];
        foreach ($weekdayoptions as $key => $weekday) {
            $weekdayid = 'weekly_days_' . $key;
            $attributes = [];
            $group[] = $mform->createElement('advcheckbox', $weekdayid, '', $weekday, null, [0, $key]);
        }

        $mform->addGroup($group, 'weekly_days_group', get_string('occurson', 'zoom'), ' ', false);
        $mform->hideif('weekly_days_group', 'recurrence_type', 'noteq', ZOOM_RECURRINGTYPE_WEEKLY);
        $mform->hideif('weekly_days_group', 'recurring', 'notchecked');
        if (!empty($this->current->weekly_days)) {
            $weekdaynumbers = explode(',', $this->current->weekly_days);
            foreach ($weekdaynumbers as $daynumber) {
                $weekdayid = 'weekly_days_' . $daynumber;
                $mform->setDefault($weekdayid, $daynumber);
            }
        }

        // Monthly options.
        $monthoptions = [];
        for ($i = 1; $i <= 31; $i++) {
            $monthoptions[$i] = $i;
        }

        $monthlyweekoptions = zoom_get_monthweek_options();

        $group = [];
        $group[] = $mform->createElement(
            'radio',
            'monthly_repeat_option',
            '',
            get_string('day', 'calendar'),
            ZOOM_MONTHLY_REPEAT_OPTION_DAY
        );
        $group[] = $mform->createElement('select', 'monthly_day', '', $monthoptions);
        $group[] = $mform->createElement('static', 'month_day_text', '', get_string('month_day_text', 'zoom'));
        $group[] = $mform->createElement('radio', 'monthly_repeat_option', '', '', ZOOM_MONTHLY_REPEAT_OPTION_WEEK);
        $group[] = $mform->createElement('select', 'monthly_week', '', $monthlyweekoptions);
        $group[] = $mform->createElement('select', 'monthly_week_day', '', $weekdayoptions);
        $group[] = $mform->createElement('static', 'month_week_day_text', '', get_string('month_day_text', 'zoom'));
        $mform->addGroup($group, 'monthly_day_group', get_string('occurson', 'zoom'), null, false);
        $mform->hideif('monthly_day_group', 'recurrence_type', 'noteq', ZOOM_RECURRINGTYPE_MONTHLY);
        $mform->hideif('monthly_day_group', 'recurring', 'notchecked');
        $mform->setDefault('monthly_repeat_option', ZOOM_MONTHLY_REPEAT_OPTION_DAY);

        // End date option.
        $maxoptions = [];
        for ($i = 1; $i <= 50; $i++) {
            $maxoptions[$i] = $i;
        }

        $group = [];
        $group[] = $mform->createElement(
            'radio',
            'end_date_option',
            '',
            get_string('end_date_option_by', 'zoom'),
            ZOOM_END_DATE_OPTION_BY
        );
        $group[] = $mform->createElement('date_selector', 'end_date_time', '');
        $group[] = $mform->createElement(
            'radio',
            'end_date_option',
            '',
            get_string('end_date_option_after', 'zoom'),
            ZOOM_END_DATE_OPTION_AFTER
        );
        $group[] = $mform->createElement('select', 'end_times', '', $maxoptions);
        $group[] = $mform->createElement('static', 'end_times_text', '', get_string('end_date_option_occurrences', 'zoom'));
        $mform->addGroup($group, 'radioenddate', get_string('enddate', 'zoom'), null, false);
        $mform->hideif('radioenddate', 'recurring', 'notchecked');
        $mform->hideif('radioenddate', 'recurrence_type', 'eq', ZOOM_RECURRINGTYPE_NOTIME);
        // Set default option for end date to be "By".
        $mform->setDefault('end_date_option', ZOOM_END_DATE_OPTION_BY);
        // Set default end_date_time to be 1 week in the future.
        $mform->setDefault('end_date_time', strtotime('+1 week'));

        // Supplementary feature: Webinars.
        // Only show if the admin did not disable this feature completely.
        if ($config->showwebinars != ZOOM_WEBINAR_DISABLE) {
            // If we are creating a new instance.
            if ($isnew) {
                // Check if the user has a webinar license.
                $userfeatures = zoom_get_user_settings($zoomuserid)->feature;
                $haswebinarlicense = !empty($userfeatures->webinar) || !empty($userfeatures->zoom_events);

                // Only show if the admin always wants to show this widget or
                // if the admin wants to show this widget conditionally and the user has a valid license.
                if (
                    $config->showwebinars == ZOOM_WEBINAR_ALWAYSSHOW ||
                    ($config->showwebinars == ZOOM_WEBINAR_SHOWONLYIFLICENSE && $haswebinarlicense)
                ) {
                    // Add webinar option, disabled if the user cannot create webinars.
                    $webinarattr = null;
                    if (!$haswebinarlicense) {
                        $webinarattr = ['disabled' => true, 'group' => null];
                    }

                    $mform->addElement(
                        'advcheckbox',
                        'webinar',
                        get_string('webinar', 'zoom'),
                        get_string('webinarthisis', 'zoom'),
                        $webinarattr
                    );
                    $mform->setDefault('webinar', $config->webinardefault);
                    $mform->addHelpButton('webinar', 'webinar', 'zoom');
                }
            } else if ($this->current->webinar) {
                $mform->addElement(
                    'static',
                    'webinaralreadyset',
                    get_string('webinar', 'zoom'),
                    get_string('webinar_already_true', 'zoom')
                );
            } else {
                $mform->addElement(
                    'static',
                    'webinaralreadyset',
                    get_string('webinar', 'zoom'),
                    get_string('webinar_already_false', 'zoom')
                );
            }
        }

        // Add tracking fields, if configured in Moodle AND Zoom.
        $defaulttrackingfields = zoom_clean_tracking_fields();
        foreach ($defaulttrackingfields as $key => $defaulttrackingfield) {
            $configname = 'tf_' . $key . '_field';
            if (!empty($config->$configname)) {
                $mform->addElement('text', $key, $defaulttrackingfield);
                $mform->setType($key, PARAM_TEXT);
                $rvprop = 'tf_' . $key . '_recommended_values';
                if (!empty($config->$rvprop)) {
                    $mform->addElement(
                        'static',
                        $key . '_recommended_values',
                        null,
                        get_string('trackingfields_recommendedvalues', 'mod_zoom') . $config->$rvprop
                    );
                }

                $requiredproperty = 'tf_' . $key . '_required';
                if (!empty($config->$requiredproperty)) {
                    $mform->addRule($key, null, 'required', null, 'client');
                }
            }
        }

        // Add show widget.
        $mform->addElement(
            'advcheckbox',
            'show_schedule',
            get_string('showschedule', 'zoom'),
            get_string('showscheduleonview', 'zoom')
        );
        $mform->setDefault('show_schedule', $config->defaultshowschedule);
        $mform->addHelpButton('show_schedule', 'showschedule', 'zoom');

        // Add registration widget.
        $registrationoptions = [
            ZOOM_REGISTRATION_OFF => get_string('no'),
            ZOOM_REGISTRATION_AUTOMATIC => get_string('registration_text', 'mod_zoom'),
        ];
        $mform->addElement('select', 'registration', get_string('registration', 'mod_zoom'), $registrationoptions);
        $mform->setDefault('registration', $config->defaultregistration);
        $mform->addHelpButton('registration', 'registration', 'mod_zoom');
        $mform->hideIf('registration', 'recurrence_type', 'eq', ZOOM_RECURRINGTYPE_NOTIME);

        // Adding the "breakout rooms" fieldset.
        $mform->addElement('header', 'breakoutrooms', get_string('breakoutrooms', 'mod_zoom'));
        $mform->setExpanded('breakoutrooms');

        $courseid = $this->current->course;
        $context = context_course::instance($courseid);

        $groups = groups_get_all_groups($courseid);
        $participants = get_enrolled_users($context);

        // Getting Course participants.
        $courseparticipants = [];
        foreach ($participants as $participant) {
            $courseparticipants[] = [
                'participantid' => $participant->id,
                'participantname' => fullname($participant) . ' <' . $participant->email . '>',
            ];
        }

        // Getting Course groups.
        $coursegroups = [];
        foreach ($groups as $group) {
            $coursegroups[] = ['groupid' => $group->id, 'groupname' => $group->name];
        }

        // Building meeting breakout rooms template data.
        $templatedata = [
            'rooms' => [],
            'roomscount' => 0,
            'roomtoclone' => [
                'toclone' => 'toclone',
                'courseparticipants' => $courseparticipants,
                'coursegroups' => $coursegroups,
            ],
        ];

        $currentinstance = $this->current->instance;
        if ($currentinstance) {
            $rooms = zoom_build_instance_breakout_rooms_array_for_view($currentinstance, $courseparticipants, $coursegroups);

            $templatedata['rooms'] = $rooms;
            $templatedata['roomscount'] = count($rooms);
        }

        $mform->addElement('html', $OUTPUT->render_from_template('zoom/breakoutrooms_rooms', $templatedata));

        $mform->addElement('hidden', 'rooms', '');
        $mform->setType('rooms', PARAM_RAW);

        $mform->addElement('hidden', 'roomsparticipants', '');
        $mform->setType('roomsparticipants', PARAM_RAW);

        $mform->addElement('hidden', 'roomsgroups', '');
        $mform->setType('roomsgroups', PARAM_RAW);

        // Adding the "security" fieldset, where all settings relating to securing and protecting the meeting are shown.
        $mform->addElement('header', 'security', get_string('security', 'mod_zoom'));
        $mform->setExpanded('security');

        // Deals with password manager issues.
        if (isset($this->current->password)) {
            $this->current->meetingcode = $this->current->password;
            unset($this->current->password);
        }

        // Add password requirement prompt.
        $mform->addElement(
            'advcheckbox',
            'requirepasscode',
            get_string('password', 'zoom'),
            get_string('requirepasscode', 'zoom')
        );
        if (isset($this->current->meetingcode) && strval($this->current->meetingcode) === "") {
            $mform->setDefault('requirepasscode', 0);
        } else {
            $mform->setDefault('requirepasscode', 1);
        }

        $mform->addHelpButton('requirepasscode', 'requirepasscode', 'zoom');

        // Set default passcode and description from Zoom security settings.
        $securitysettings = zoom_get_meeting_security_settings($this->current->host_id ?? $zoomuserid);
        // Add password.
        $mform->addElement('text', 'meetingcode', get_string('setpasscode', 'zoom'), ['maxlength' => '10']);
        $mform->setType('meetingcode', PARAM_TEXT);
        // Check password uses valid characters.
        $regex = '/^[a-zA-Z0-9@_*-]{1,10}$/';
        $mform->addRule('meetingcode', get_string('err_invalid_password', 'mod_zoom'), 'regex', $regex, 'client');
        $mform->setDefault('meetingcode', zoom_create_default_passcode($securitysettings->meeting_password_requirement));
        $mform->hideIf('meetingcode', 'requirepasscode', 'notchecked');
        // Add passcode requirements note (use mform group trick from MDL-66251 to be able to conditionally hide this).
        $passwordrequirementsgroup = [];
        $passwordrequirementsgroup[] =& $mform->createElement(
            'static',
            'passwordrequirements',
            '',
            zoom_create_passcode_description($securitysettings->meeting_password_requirement)
        );
        $mform->addGroup($passwordrequirementsgroup, 'passwordrequirementsgroup', '', '', false);
        $mform->hideIf('passwordrequirementsgroup', 'requirepasscode', 'notchecked');

        // Supplementary feature: Encryption type.
        // Only show if the admin did not disable this feature completely.
        if ($config->showencryptiontype != ZOOM_ENCRYPTION_DISABLE) {
            // Check if the user can use e2e encryption.
            $e2eispossible = $securitysettings->end_to_end_encrypted_meetings;

            if ($config->showencryptiontype == ZOOM_ENCRYPTION_SHOWONLYIFPOSSIBLE && !$e2eispossible) {
                // If user cannot use e2e and option is not shown to user,
                // default to enhanced encryption.
                $mform->addElement('hidden', 'option_encryption_type', ZOOM_ENCRYPTION_TYPE_ENHANCED);
            } else if (
                $config->showencryptiontype == ZOOM_ENCRYPTION_ALWAYSSHOW ||
                ($config->showencryptiontype == ZOOM_ENCRYPTION_SHOWONLYIFPOSSIBLE && $e2eispossible)
            ) {
                // Only show if the admin always wants to show this widget or
                // if the admin wants to show this widget conditionally and the user can use e2e encryption.

                // Add encryption type option, disabled if the user can't use e2e encryption.
                $encryptionattr = null;
                $defaultencryptiontype = $config->defaultencryptiontypeoption;
                if (!$e2eispossible) {
                    $encryptionattr = ['disabled' => true];
                    $defaultencryptiontype = ZOOM_ENCRYPTION_TYPE_ENHANCED;
                }

                $mform->addGroup([
                    $mform->createElement(
                        'radio',
                        'option_encryption_type',
                        '',
                        get_string('option_encryption_type_enhancedencryption', 'zoom'),
                        ZOOM_ENCRYPTION_TYPE_ENHANCED,
                        $encryptionattr
                    ),
                    $mform->createElement(
                        'radio',
                        'option_encryption_type',
                        '',
                        get_string('option_encryption_type_endtoendencryption', 'zoom'),
                        ZOOM_ENCRYPTION_TYPE_E2EE,
                        $encryptionattr
                    ),
                ], 'option_encryption_type_group', get_string('option_encryption_type', 'zoom'), null, false);
                $mform->setDefault('option_encryption_type', $defaultencryptiontype);
                $mform->addHelpButton('option_encryption_type_group', 'option_encryption_type', 'zoom');
                $mform->disabledIf('option_encryption_type_group', 'webinar', 'checked');
            }

            $mform->setType('option_encryption_type', PARAM_ALPHANUMEXT);
        }

        // Add waiting room widget.
        $mform->addElement(
            'advcheckbox',
            'option_waiting_room',
            get_string('option_waiting_room', 'zoom'),
            get_string('waitingroomenable', 'zoom')
        );
        $mform->addHelpButton('option_waiting_room', 'option_waiting_room', 'zoom');
        $mform->setDefault('option_waiting_room', $config->defaultwaitingroomoption);
        $mform->disabledIf('option_waiting_room', 'webinar', 'checked');

        // Add join before host widget.
        $mform->addElement(
            'advcheckbox',
            'option_jbh',
            get_string('option_jbh', 'zoom'),
            get_string('joinbeforehostenable', 'zoom')
        );
        $mform->setDefault('option_jbh', $config->defaultjoinbeforehost);
        $mform->addHelpButton('option_jbh', 'option_jbh', 'zoom');
        $mform->disabledIf('option_jbh', 'webinar', 'checked');

        // Add authenticated users widget.
        $mform->addElement(
            'advcheckbox',
            'option_authenticated_users',
            get_string('authentication', 'zoom'),
            get_string('option_authenticated_users', 'zoom')
        );
        $mform->setDefault('option_authenticated_users', $config->defaultauthusersoption);
        $mform->addHelpButton('option_authenticated_users', 'option_authenticated_users', 'zoom');

        // Add show widget.
        $mform->addElement(
            'advcheckbox',
            'show_security',
            get_string('showsecurity', 'zoom'),
            get_string('showsecurityonview', 'zoom')
        );
        $mform->setDefault('show_security', $config->defaultshowsecurity);
        $mform->addHelpButton('show_security', 'showsecurity', 'zoom');

        // Adding the "media" fieldset, where all settings relating to media streams in the meeting are shown.
        $mform->addElement('header', 'media', get_string('media', 'mod_zoom'));
        $mform->setExpanded('media');

        // Add host/participants video options.
        $mform->addGroup([
            $mform->createElement('radio', 'option_host_video', '', get_string('on', 'zoom'), true),
            $mform->createElement('radio', 'option_host_video', '', get_string('off', 'zoom'), false),
        ], 'option_host_video_group', get_string('option_host_video', 'zoom'), null, false);
        $mform->setDefault('option_host_video', $config->defaulthostvideo);
        $mform->addHelpButton('option_host_video_group', 'option_host_video', 'zoom');
        $mform->disabledIf('option_host_video_group', 'webinar', 'checked');

        $mform->addGroup([
            $mform->createElement('radio', 'option_participants_video', '', get_string('on', 'zoom'), true),
            $mform->createElement('radio', 'option_participants_video', '', get_string('off', 'zoom'), false),
        ], 'option_participants_video_group', get_string('option_participants_video', 'zoom'), null, false);
        $mform->setDefault('option_participants_video', $config->defaultparticipantsvideo);
        $mform->addHelpButton('option_participants_video_group', 'option_participants_video', 'zoom');
        $mform->disabledIf('option_participants_video_group', 'webinar', 'checked');

        // Add audio options.
        $mform->addGroup([
            $mform->createElement('radio', 'option_audio', '', get_string('audio_telephony', 'zoom'), ZOOM_AUDIO_TELEPHONY),
            $mform->createElement('radio', 'option_audio', '', get_string('audio_voip', 'zoom'), ZOOM_AUDIO_VOIP),
            $mform->createElement('radio', 'option_audio', '', get_string('audio_both', 'zoom'), ZOOM_AUDIO_BOTH),
        ], 'option_audio_group', get_string('option_audio', 'zoom'), null, false);
        $mform->addHelpButton('option_audio_group', 'option_audio', 'zoom');
        $mform->setDefault('option_audio', $config->defaultaudiooption);

        // Add mute participants upon entry widget.
        $mform->addElement(
            'advcheckbox',
            'option_mute_upon_entry',
            get_string('audiodefault', 'mod_zoom'),
            get_string('option_mute_upon_entry', 'mod_zoom')
        );
        $mform->setDefault('option_mute_upon_entry', $config->defaultmuteuponentryoption);
        $mform->addHelpButton('option_mute_upon_entry', 'option_mute_upon_entry', 'mod_zoom');

        $hostuserid = $zoomuserid;
        if (!empty($this->current->host_id)) {
            $hostuserid = $this->current->host_id;
        }

        // Add autorecording option if enabled.
        $allowrecordingchangeoption = $config->allowrecordingchangeoption;
        if ($allowrecordingchangeoption) {
            // Add auto recording options according to user settings.
            $options = [
                ZOOM_AUTORECORDING_NONE => get_string('autorecording_none', 'mod_zoom'),
            ];

            if (!empty($hostuserid)) {
                $recordingsettings = zoom_get_user_settings($hostuserid)->recording;
            }

            if (!empty($recordingsettings->local_recording)) {
                $options[ZOOM_AUTORECORDING_LOCAL] = get_string('autorecording_local', 'mod_zoom');
            }

            if (!empty($recordingsettings->cloud_recording)) {
                $options[ZOOM_AUTORECORDING_CLOUD] = get_string('autorecording_cloud', 'mod_zoom');
            }

            if ($config->recordingoption === ZOOM_AUTORECORDING_USERDEFAULT) {
                $defaultsetting = $recordingsettings->auto_recording;
            } else {
                $defaultsetting = $config->recordingoption;
            }

            $mform->addElement('select', 'option_auto_recording', get_string('option_auto_recording', 'mod_zoom'), $options);
            $mform->setDefault('option_auto_recording', $defaultsetting);
            $mform->addHelpButton('option_auto_recording', 'option_auto_recording', 'mod_zoom');
        }

        // Add show widget.
        $mform->addElement(
            'advcheckbox',
            'show_media',
            get_string('showmedia', 'zoom'),
            get_string('showmediaonview', 'zoom')
        );
        $mform->setDefault('show_media', $config->defaultshowmedia);
        $mform->addHelpButton('show_media', 'showmedia', 'zoom');

        // Check if there is any setting to be shown in the "host" fieldset.
        $showschedulingprivilege = ($config->showschedulingprivilege != ZOOM_SCHEDULINGPRIVILEGE_DISABLE) &&
                count($scheduleusers) > 1 && $allowschedule; // Check if the size is greater than 1 because
                                                             // we add the editing/creating user by default.
        $this->showschedulingprivilege = $showschedulingprivilege;
        $showalternativehosts = ($config->showalternativehosts != ZOOM_ALTERNATIVEHOSTS_DISABLE);
        if ($showschedulingprivilege || $showalternativehosts) {
            // Adding the "host" fieldset, where all settings relating to defining the meeting host are shown.
            $mform->addElement('header', 'host', get_string('host', 'mod_zoom'));
            $mform->setExpanded('host');

            // Supplementary feature: Alternative hosts.
            // Only show if the admin did not disable this feature completely.
            if ($showalternativehosts) {
                // Explain alternativehosts.
                $mform->addElement('static', 'hostintro', '', get_string('hostintro', 'zoom'));

                // If the admin wants to show the plain input field.
                if ($config->showalternativehosts == ZOOM_ALTERNATIVEHOSTS_INPUTFIELD) {
                    // Add alternative hosts.
                    $mform->addElement('text', 'alternative_hosts', get_string('alternative_hosts', 'zoom'), ['size' => '64']);
                    $mform->setType('alternative_hosts', PARAM_TEXT);
                    $mform->addHelpButton('alternative_hosts', 'alternative_hosts', 'zoom');

                    // If the admin wants to show the user picker.
                } else if ($config->showalternativehosts == ZOOM_ALTERNATIVEHOSTS_PICKER) {
                    // Get selectable alternative host users based on the capability.
                    $alternativehostschoices = zoom_get_selectable_alternative_hosts_list($this->context);
                    // Create autocomplete widget.
                    $alternativehostsoptions = [
                        'multiple' => true,
                        'showsuggestions' => true,
                        'placeholder' => get_string('alternative_hosts_picker_placeholder', 'zoom'),
                        'noselectionstring' => get_string('alternative_hosts_picker_noneselected', 'zoom'),
                    ];
                    $mform->addElement(
                        'autocomplete',
                        'alternative_hosts_picker',
                        get_string('alternative_hosts', 'zoom'),
                        $alternativehostschoices,
                        $alternativehostsoptions
                    );
                    $mform->setType('alternative_hosts_picker', PARAM_EMAIL);
                    $mform->addHelpButton('alternative_hosts_picker', 'alternative_hosts_picker', 'zoom');
                }
            }

            // Supplementary feature: Scheduling privilege.
            // Only show if the admin did not disable this feature completely and if current user is able to use it.
            if ($showschedulingprivilege) {
                if ($allowrecordingchangeoption) {
                    $PAGE->requires->js_call_amd('mod_zoom/scheduleforchooser', 'init');
                    $mform->addElement('select', 'schedule_for', get_string('schedulefor', 'mod_zoom'), $scheduleusers, [
                        'data-scheduleforchooser-field' => 'selector',
                    ]);
                } else {
                    $mform->addElement('select', 'schedule_for', get_string('schedulefor', 'mod_zoom'), $scheduleusers);
                }

                $mform->setType('schedule_for', PARAM_EMAIL);
                if (!$isnew) {
                    $mform->disabledIf('schedule_for', 'change_schedule_for');
                    $mform->addElement('checkbox', 'change_schedule_for', get_string('changehost', 'zoom'));
                    $mform->setDefault('schedule_for', strtolower(zoom_get_user($this->current->host_id)->email));
                } else {
                    $mform->setDefault('schedule_for', strtolower(zoom_get_api_identifier($USER)));
                }

                $mform->addHelpButton('schedule_for', 'schedulefor', 'zoom');

                if ($allowrecordingchangeoption) {
                    // Button to update auto recording options based on the user permissions in Zoom (will be hidden by JavaScript).
                    $mform->registerNoSubmitButton('updateautorecordingoptions');
                    $mform->addElement(
                        'submit',
                        'updateautorecordingoptions',
                        get_string('autorecordingoptionsupdate', 'mod_zoom'),
                        [
                            'data-scheduleforchooser-field' => 'updateButton',
                            'class' => 'd-none',
                        ]
                    );
                }
            }
        }

        // Adding option for Recording Visiblity by default.
        if (!empty($config->viewrecordings)) {
            $mform->addElement('header', 'recording', get_string('recording', 'mod_zoom'));
            $mform->addElement(
                'advcheckbox',
                'recordings_visible_default',
                get_string('recordingvisibility', 'mod_zoom'),
                get_string('yes')
            );
            $mform->setDefault('recordings_visible_default', 1);
            $mform->addHelpButton('recordings_visible_default', 'recordingvisibility', 'mod_zoom');
        }

        // Add meeting id.
        $mform->addElement('hidden', 'meeting_id', -1);
        $mform->setType('meeting_id', PARAM_ALPHANUMEXT);

        // Add host id (will error if user does not have an account on Zoom).
        $mform->addElement('hidden', 'host_id', $hostuserid);
        $mform->setType('host_id', PARAM_ALPHANUMEXT);

        // Add standard grading elements.
        $this->standard_grading_coursemodule_elements();
        $mform->setDefault('grade', false);

        // Add standard elements, common to all modules.
        $this->standard_coursemodule_elements();
        $this->apply_admin_defaults();

        // Add standard buttons, common to all modules.
        $this->add_action_buttons();
    }

    /**
     * Add standard_grading_coursemodule_elements with grading for field.
     * @return void
     */
    public function standard_grading_coursemodule_elements() {
        parent::standard_grading_coursemodule_elements();
        $mform = $this->_form;
        $itemnumber = 0;
        $component = "mod_{$this->_modname}";
        $options = [
            'entry' => get_string('gradingentry', 'mod_zoom'), // All credit upon entry.
            'period' => get_string('gradingperiod', 'mod_zoom'), // Credit according to attend duration.
        ];
        $mform->addElement('select', 'grading_method', get_string('gradingmethod', 'mod_zoom'), $options);
        $mform->setDefault('grading_method', get_config('zoom', 'gradingmethod'));
        $mform->addHelpButton('grading_method', 'gradingmethod', 'mod_zoom');

        // Requires Moodle 3.8+. Hide field if the grade item is not graded.
        if (class_exists('\\core_grades\\component_gradeitems')) {
            $gradefieldname = \core_grades\component_gradeitems::get_field_name_for_itemnumber($component, $itemnumber, 'grade');
            $mform->hideIf('grading_method', "{$gradefieldname}[modgrade_type]", 'eq', 'none');
        }
    }

    /**
     * Fill in the current page data for this course.
     */
    public function definition_after_data() {
        parent::definition_after_data();

        // Get config.
        $config = get_config('zoom');

        if (!$config->allowrecordingchangeoption) {
            return;
        }

        $mform = $this->_form;

        if ($this->showschedulingprivilege) {
            $scheduleelement =& $mform->getElement('schedule_for');
            $values = $scheduleelement->getValue();

            if (empty($values)) {
                return;
            }

            $scheduleforuser = current($values);
            $zoomuser = zoom_get_user($scheduleforuser);
            $zoomuserid = $zoomuser->id;
        } else if (!empty($this->current->host_id)) {
            $zoomuserid = $this->current->host_id;
        } else {
            $zoomuserid = zoom_get_user_id(false);
        }

        $recordingelement =& $mform->getElement('option_auto_recording');
        $recordingelement->removeOptions();

        // Add auto recording options according to user settings.
        $options = [
            ZOOM_AUTORECORDING_NONE => get_string('autorecording_none', 'mod_zoom'),
        ];

        if ($zoomuserid !== false) {
            $recordingsettings = zoom_get_user_settings($zoomuserid)->recording;
        }

        if (!empty($recordingsettings->local_recording)) {
            $options[ZOOM_AUTORECORDING_LOCAL] = get_string('autorecording_local', 'mod_zoom');
        }

        if (!empty($recordingsettings->cloud_recording)) {
            $options[ZOOM_AUTORECORDING_CLOUD] = get_string('autorecording_cloud', 'mod_zoom');
        }

        $recordingelement->load($options);
    }

    /**
     * Allows module to modify the data returned by form get_data().
     * This method is also called in the bulk activity completion form.
     *
     * Only available on moodleform_mod.
     *
     * @param stdClass $data the form data to be modified.
     */
    public function data_postprocessing($data) {
        global $DB;

        parent::data_postprocessing($data);

        // Get config.
        $config = get_config('zoom');

        // If the admin did show the alternative hosts user picker.
        if ($config->showalternativehosts == ZOOM_ALTERNATIVEHOSTS_PICKER) {
            // If there was at least one alternative host selected, process these users.
            if (count($data->alternative_hosts_picker) > 0) {
                // Populate the alternative_hosts field with a concatenated string of email addresses.
                // This is done as this is the format which Zoom expects and alternative_hosts is the field to store the data
                // in mod_zoom.
                // The alternative host user picker is just an add-on to help teachers to fill this field.
                $data->alternative_hosts = implode(',', $data->alternative_hosts_picker);

                // If there wasn't any alternative host selected.
            } else {
                $data->alternative_hosts = '';
            }

            // Unfortunately, the host is not only able to add alternative hosts in Moodle with the user picker.
            // He is also able to add any alternative host with an email address in Zoom directly.
            // Thus, we have to get the latest list of alternative hosts from the DB again now,
            // identify the users who were not selectable at all in this form and append them to the list
            // of selected alternative hosts.

            // Get latest list of alternative hosts from the DB.
            $result = $DB->get_field('zoom', 'alternative_hosts', ['meeting_id' => $data->meeting_id], IGNORE_MISSING);

            // Proceed only if there is a field of alternative hosts already.
            if ($result !== false) {
                $alternativehostsdb = zoom_get_alternative_host_array_from_string($result);

                // Get selectable alternative host users based on the capability.
                $alternativehostschoices = zoom_get_selectable_alternative_hosts_list($this->context);

                // Iterate over the latest list of alternative hosts from the DB.
                foreach ($alternativehostsdb as $ah) {
                    // If the existing alternative host would not have been selectable.
                    if (!array_key_exists($ah, $alternativehostschoices)) {
                        // Add the alternative host to the alternative_hosts field.
                        if ($data->alternative_hosts == '') {
                            $data->alternative_hosts = $ah;
                        } else {
                            $data->alternative_hosts .= ',' . $ah;
                        }
                    }
                }
            }
        }

        // Add some postprocessing around the recurrence settings.
        if ($data->recurring) {
            // If "No fixed time" meeting selected, dont need repeat_interval and other options.
            if ($data->recurrence_type == ZOOM_RECURRINGTYPE_NOTIME) {
                unset($data->repeat_interval);
                // Unset end_times and end_date.
                unset($data->end_date_option);
                unset($data->end_times);
                unset($data->end_date_time);
            }

            // If weekly recurring is not selected, unset weekly options.
            if ($data->recurrence_type != ZOOM_RECURRINGTYPE_WEEKLY) {
                // Unset the weekly fields.
                $data = zoom_remove_weekly_options($data);
            }

            // If monthly recurring is not selected, unset monthly options.
            if ($data->recurrence_type != ZOOM_RECURRINGTYPE_MONTHLY) {
                // Unset the weekly fields.
                $data = zoom_remove_monthly_options($data);
            }
        }

        // Make sure registration is not enabled for No Fixed Time recurring meetings.
        if ($data->recurring && $data->recurrence_type == ZOOM_RECURRINGTYPE_NOTIME) {
            if (isset($data->registration) && $data->registration == ZOOM_REGISTRATION_AUTOMATIC) {
                $data->registration = ZOOM_REGISTRATION_OFF;
            }
        }
    }

    /**
     * Allows module to modify data returned by get_moduleinfo_data() or prepare_new_moduleinfo_data() before calling set_data()
     * This method is also called in the bulk activity completion form.
     *
     * Only available on moodleform_mod.
     *
     * @param array $defaultvalues passed by reference
     */
    public function data_preprocessing(&$defaultvalues) {
        global $DB;

        parent::data_preprocessing($defaultvalues);

        // Get config.
        $config = get_config('zoom');

        // If the admin wants to show the alternative hosts user picker.
        if ($config->showalternativehosts == ZOOM_ALTERNATIVEHOSTS_PICKER) {
            // If there is at least one alternative host set.
            if (isset($defaultvalues['alternative_hosts']) && strlen($defaultvalues['alternative_hosts']) > 0) {
                // Populate the alternative_hosts_picker field with an exploded array of email addresses.
                // This is done as alternative_hosts is the field to store the data in mod_zoom and
                // the alternative host user picker is just an add-on to help teachers to fill this field.

                // At this point, the alternative_hosts field might also contain users who are not selectable in the user picker
                // as they aren't a member of the course or do not have a Moodle account.
                // This does not matter as user picker default values which don't have a corresponding autocomplete suggestion
                // will be simply ignored.
                // When the form is submitted, these non-selectable alternative hosts will be added again in data_postprocessing().

                // According to the documentation, the Zoom API separates the email addresses with commas,
                // but we also want to deal with semicolon-separated lists just in case.
                $defaultvalues['alternative_hosts_picker'] = zoom_get_alternative_host_array_from_string(
                    $defaultvalues['alternative_hosts']
                );
            }
        }

        if ($config->defaulttrackingfields !== '') {
            // Populate modedit form fields with previously saved values.
            $defaulttrackingfields = zoom_clean_tracking_fields();
            $tfrows = $DB->get_records('zoom_meeting_tracking_fields', ['meeting_id' => $defaultvalues['id']]);
            foreach ($tfrows as $tfrow) {
                $tfkey = $tfrow->tracking_field;
                if (!empty($defaulttrackingfields[$tfkey])) {
                    $defaultvalues[$tfkey] = $tfrow->value;
                }
            }
        }
    }

    /**
     * More validation on form data.
     * See documentation in lib/formslib.php.
     *
     * @param array $data
     * @param array $files
     * @return array
     */
    public function validation($data, $files) {
        global $CFG, $USER;

        $errors = parent::validation($data, $files);

        $config = get_config('zoom');

        // Only check for scheduled meetings.
        if (empty($data['recurring'])) {
            // Make sure start date is in the future.
            if ($data['start_time'] < time() && $data['meeting_id'] < 0) {
                $errors['start_time'] = get_string('err_start_time_past', 'zoom');
            }

            // Make sure duration is positive and no more than 150 hours.
            if ($data['duration'] <= 0) {
                $errors['duration'] = get_string('err_duration_nonpositive', 'zoom');
            } else if ($data['duration'] > 150 * 60 * 60) {
                $errors['duration'] = get_string('err_duration_too_long', 'zoom');
            }
        } else if ($data['recurring'] == 1 && $data['recurrence_type'] != ZOOM_RECURRINGTYPE_NOTIME) {
            // Make sure start date time (first potential date of next meeting) is in the future.
            if ($data['start_time'] < time() && $data['meeting_id'] < 0) {
                $errors['start_time'] = get_string('err_start_time_past_recurring', 'zoom');
            }

            // Make sure duration is positive and no more than 150 hours.
            if ($data['duration'] <= 0) {
                $errors['duration'] = get_string('err_duration_nonpositive', 'zoom');
            } else if ($data['duration'] > 150 * 60 * 60) {
                $errors['duration'] = get_string('err_duration_too_long', 'zoom');
            }
        }

        if (!empty($data['requirepasscode']) && empty($data['meetingcode'])) {
            $errors['meetingcode'] = get_string('err_password_required', 'mod_zoom');
        }

        if (isset($data['schedule_for']) && strtolower($data['schedule_for']) !== strtolower(zoom_get_api_identifier($USER))) {
            $zoomuserid = zoom_get_user_id();
            $scheduleusers = zoom_webservice()->get_schedule_for_users($zoomuserid);
            $scheduleok = false;
            foreach ($scheduleusers as $zuser) {
                if (strtolower($zuser->email) === strtolower($data['schedule_for'])) {
                    // Found a matching email address in the Zoom users list.
                    $scheduleok = true;
                    break;
                }
            }

            if (!$scheduleok) {
                $errors['schedule_for'] = get_string('invalidscheduleuser', 'mod_zoom');
            }
        }

        // Supplementary feature: Alternative hosts.
        // Only validate if the admin did not disable this feature completely.
        if ($config->showalternativehosts != ZOOM_ALTERNATIVEHOSTS_DISABLE) {
            // If the admin did show the plain input field.
            if ($config->showalternativehosts == ZOOM_ALTERNATIVEHOSTS_INPUTFIELD) {
                // Check if the listed alternative hosts are valid users on Zoom.
                $alternativehosts = zoom_get_alternative_host_array_from_string($data['alternative_hosts']);
                foreach ($alternativehosts as $alternativehost) {
                    if (!(zoom_get_user($alternativehost))) {
                        $errors['alternative_hosts'] = get_string('zoomerr_alternativehostusernotfound', 'zoom', $alternativehost);
                        break;
                    }
                }

                // If the admin did show the user picker.
            } else if ($config->showalternativehosts == ZOOM_ALTERNATIVEHOSTS_PICKER) {
                // Check if the picked alternative hosts are valid users on Zoom.
                foreach ($data['alternative_hosts_picker'] as $alternativehost) {
                    if (!(zoom_get_user($alternativehost))) {
                        $errors['alternative_hosts_picker'] =
                                get_string('zoomerr_alternativehostusernotfound', 'zoom', $alternativehost);
                        break;
                    }
                }
            }
        }

        // Supplementary feature: Encryption type.
        // Only validate if the admin did not disable this feature completely.
        if ($config->showencryptiontype != ZOOM_ENCRYPTION_DISABLE) {
            // Check if given encryption type is valid.
            if (
                $data['option_encryption_type'] !== ZOOM_ENCRYPTION_TYPE_ENHANCED &&
                $data['option_encryption_type'] !== ZOOM_ENCRYPTION_TYPE_E2EE
            ) {
                // This will not happen unless the user tampered with the form.
                // Because of this, we skip adding this string to the language pack.
                $errors['option_encryption_type_group'] = 'The submitted encryption type is not valid.';
            }
        }

        // Add validation for recurring meeting.
        if ($data['recurring'] == 1) {
            if ($data['recurrence_type'] == ZOOM_RECURRINGTYPE_WEEKLY) {
                $weekdaynumbers = [];
                for ($i = 1; $i <= 7; $i++) {
                    $key = 'weekly_days_' . $i;
                    if (!empty($data[$key])) {
                        $weekdaynumbers[] = $i;
                    }
                }

                if (empty($weekdaynumbers)) {
                    $errors['weekly_days_group'] = get_string('err_weekly_days', 'zoom');
                }

                // For weekly, maximum is 12 weeks.
                if ($data['repeat_interval'] > 12) {
                    $errors['repeat_group'] = get_string('err_repeat_weekly_interval', 'zoom');
                }
            }

            if ($data['recurrence_type'] == ZOOM_RECURRINGTYPE_MONTHLY) {
                // For monthly, max is 3 months.
                if ($data['repeat_interval'] > 3) {
                    $errors['repeat_group'] = get_string('err_repeat_monthly_interval', 'zoom');
                }
            }

            if ($data['recurrence_type'] != ZOOM_RECURRINGTYPE_NOTIME && $data['end_date_option'] == ZOOM_END_DATE_OPTION_BY) {
                if ($data['end_date_time'] < time()) {
                    $errors['radioenddate'] = get_string('err_end_date', 'zoom');
                }

                if ($data['end_date_time'] < $data['start_time']) {
                    $errors['radioenddate'] = get_string('err_end_date_before_start', 'zoom');
                }
            }
        }

        // Validation for registration required functionality.
        if ($data['registration'] != ZOOM_REGISTRATION_OFF) {
            // Recurring meeting validation already handled by hiding registration option where required.
            // Check licensing of the user.
            if (!zoom_webservice()->is_user_permitted_to_require_registration()) {
                $errors['registration'] = get_string('err_registration', 'mod_zoom');
            }
        }

        return $errors;
    }
}

====================

file: form.js
path: amd/src/form.js
codice:
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Populates or de-populates password field based on whether the
 * password is required or not.
 *
 * @copyright  2018 UC Regents
 * @author     Kubilay Agi
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

define(['jquery', 'core/form-autocomplete', 'core/str', 'core/notification'], function($, autocomplete, str, notification) {

    /**
     * CSS selectors used throughout the file.
     *
     * @type {object}
     */
    var SELECTORS = {
        REPEAT_SELECT: 'select[name="recurrence_type"]',
        REPEAT_INTERVAL: '.repeat_interval',
        REPEAT_INTERVAL_DAILY: '#interval_daily',
        REPEAT_INTERVAL_WEEKLY: '#interval_weekly',
        REPEAT_INTERVAL_MONTHLY: '#interval_monthly',
        REPEAT_INTERVAL_OPTIONS: 'select[name="repeat_interval"] option',
        START_TIME: 'select[name*="start_time"]',
        DURATION: '*[name*="duration"]',
        RECURRING: 'input[name="recurring"][type!="hidden"]',
        OPTION_JBH: 'input[name="option_jbh"][type!="hidden"]',
        OPTION_WAITING_ROOM: 'input[name="option_waiting_room"][type!="hidden"]'
    };

    /**
     * Repeat interval options.
     *
     * @type {object}
     */
    var REPEAT_OPTIONS = {
        REPEAT_OPTION_NONE: 0,
        REPEAT_OPTION_DAILY: 1,
        REPEAT_OPTION_WEEKLY: 2,
        REPEAT_OPTION_MONTHLY: 3
    };

    /**
     * The max values for each repeat option.
     *
     * @type {object}
     */
    var REPEAT_MAX_OPTIONS = {
        REPEAT_OPTION_DAILY: 90,
        REPEAT_OPTION_WEEKLY: 12,
        REPEAT_OPTION_MONTHLY: 3
    };

    /**
     * The init function.
     */
    var init = function() {
        var optionJoinBeforeHost = $(SELECTORS.OPTION_JBH);
        var optionWaitingRoom = $(SELECTORS.OPTION_WAITING_ROOM);
        optionJoinBeforeHost.change(function() {
            if (optionJoinBeforeHost.is(':checked') === true) {
                optionWaitingRoom.prop('checked', false);
            }
        });
        optionWaitingRoom.change(function() {
            if (optionWaitingRoom.is(':checked') === true) {
                optionJoinBeforeHost.prop('checked', false);
            }
        });

        // First toggle the values based on initial selections.
        toggleStartTimeDuration();
        toggleRepeatIntervalText();
        limitRepeatValues();
        // Add listerner to "Repeat Every" drop-down.
        $(SELECTORS.REPEAT_SELECT).change(function() {
            toggleStartTimeDuration();
            toggleRepeatIntervalText();
            limitRepeatValues();
        });
        // Add listener for the "Recurring" checkbox
        $(SELECTORS.RECURRING).change(function() {
            toggleStartTimeDuration();
        });

        var breakoutroomsEditor = new BreakoutroomsEditor();
        breakoutroomsEditor.init();
    };

    /**
     * Toggle start time and duration elements.
     */
    var toggleStartTimeDuration = function() {
        // Disable start time and duration if "No Fixed Time" recurring meeting/webinar selected.
        var disabled = false;
        var repeatVal = parseInt($(SELECTORS.REPEAT_SELECT).val(), 10);
        if ($(SELECTORS.RECURRING).prop('checked') && repeatVal === REPEAT_OPTIONS.REPEAT_OPTION_NONE) {
            disabled = true;
        }
        $(SELECTORS.START_TIME).prop('disabled', disabled);
        $(SELECTORS.DURATION).prop('disabled', disabled);
    };

    /**
     * Toggle the text based on repeat type.
     * To show either Days, Weeks or Months
     */
    var toggleRepeatIntervalText = function() {
        $(SELECTORS.REPEAT_INTERVAL).hide();
        var repeatSelectVal = parseInt($(SELECTORS.REPEAT_SELECT).val(), 10);
        if (repeatSelectVal === REPEAT_OPTIONS.REPEAT_OPTION_DAILY) {
            $(SELECTORS.REPEAT_INTERVAL_DAILY).show();
        } else if (repeatSelectVal === REPEAT_OPTIONS.REPEAT_OPTION_WEEKLY) {
            $(SELECTORS.REPEAT_INTERVAL_WEEKLY).show();
        } else if (repeatSelectVal === REPEAT_OPTIONS.REPEAT_OPTION_MONTHLY) {
            $(SELECTORS.REPEAT_INTERVAL_MONTHLY).show();
        }
    };

    /**
     * Limit the options shown in the drop-down based on repeat type selected.
     * Max value for daily meeting is 90.
     * Max value for weekly meeting is 12.
     * Max value for monthly meeting is 3.
     */
    var limitRepeatValues = function() {
        var selectedValue = parseInt($(SELECTORS.REPEAT_SELECT).val(), 10);
        // Restrict options if weekly or monthly option selected.
        $(SELECTORS.REPEAT_INTERVAL_OPTIONS).each(function() {
            if (selectedValue === REPEAT_OPTIONS.REPEAT_OPTION_WEEKLY) {
                if (this.value > REPEAT_MAX_OPTIONS.REPEAT_OPTION_WEEKLY) {
                    $(this).hide();
                }
            } else if (selectedValue === REPEAT_OPTIONS.REPEAT_OPTION_MONTHLY) {
                if (this.value > REPEAT_MAX_OPTIONS.REPEAT_OPTION_MONTHLY) {
                    $(this).hide();
                }
            } else {
                $(this).show();
            }
        });
    };

    /**
     * Tabs component.
     * @param {object} tabsColumn
     * @param {object} tabsContentColumn
     * @param {int}    initialTabsCount
     * @param {object} emptyAlert
     */
    var TabsComponent = function(tabsColumn, tabsContentColumn, initialTabsCount, emptyAlert) {
        this.tabsColumn = tabsColumn;
        this.tabsContentColumn = tabsContentColumn;
        this.emptyAlert = emptyAlert;
        this.countTabs = initialTabsCount;

        /**
         * Build tab
         * @param {object} item
         * @returns {object} tab element
         */
        this.buildTab = function(item) {
            var tab = item.tab.element;
            var tabLink = $(".nav-link", tab);

            // Setting tab id.
            tab.attr('id', 'tab-' + this.countTabs);

            // Setting tab name.
            $(".tab-name", tabLink).text(item.tab.name);

            // Setting tab href.
            tabLink.attr('href', '#link' + this.countTabs);

            // Activating tab
            $("li a", this.tabsColumn).removeClass('active');
            tabLink.addClass('active');

            return tab;
        };

        /**
         * Build tab content.
         * @param {object} item
         * @returns {object} content of tab element
         */
        this.buildTabContent = function(item) {
            var tabContent = item.tabContent.element;

            // Setting tabContent id.
            tabContent.attr('id', 'link' + this.countTabs);

            // Activating tabContent.
            $(".tab-pane", this.tabsContentColumn).removeClass('active');
            tabContent.addClass('active');

            return tabContent;
        };


        /**
         * Add tab
         * @param {object} item
         * @returns {object} tab element
         */
        this.addTab = function(item) {
            var tab = this.buildTab(item);
            var tabContent = this.buildTabContent(item);

            this.emptyAlert.addClass('hidden');
            $("ul", this.tabsColumn).append(tab);
            $(".tab-content", this.tabsContentColumn).append(tabContent);

            return {"element": tab, "content": tabContent};
        };

        /**
         * Delete tab
         * @param {object} item
         */
        this.deleteTab = function(item) {
            var tab = item;
            var tabContent = $($('a', tab).attr('href'));

            tab.remove();
            tabContent.remove();

            var countTabs = $("li", this.tabsColumn).length;
            if (!countTabs) {
                this.emptyAlert.removeClass('hidden');
            } else {
                var countActiveTabs = $("li a.active", this.tabsColumn).length;
                if (!countActiveTabs) {
                    $("li:first-child a", this.tabsColumn).trigger('click');
                }
            }
        };
    };

    /**
     * Breakout rooms editor.
     */
    var BreakoutroomsEditor = function() {
        this.roomsListColumn = $("#mod-zoom-meeting-rooms-list");
        this.roomsList = $("ul", this.roomsListColumn);
        this.addBtn = $("#add-room", this.roomsListColumn);
        this.emptyAlert = $(".empty-alert", this.roomsListColumn);
        this.deleteBtn = $(".delete-room", this.roomsListColumn);
        this.roomsDataColumn = $("#mod-zoom-meeting-rooms-data");
        this.roomItemToClone = $('#rooms-list-item').html();
        this.roomItemDataToClone = $('#rooms-list-item-data').html();
        this.initialRoomsCount = parseInt(this.roomsListColumn.attr('data-initial-rooms-count'));
        this.tabsComponent = new TabsComponent(this.roomsListColumn, this.roomsDataColumn, this.initialRoomsCount, this.emptyAlert);

        // Add room event.
        this.init = function() {
            var stringkeys = [{key: 'room', component: 'zoom'}];
            str.get_strings(stringkeys).then(function() {
                return null;
            }).fail(notification.exception);

            this.addRoomEvent();
            this.deleteRoomEvent();
            var countRooms = $("li", this.roomsListColumn).length;
            if (countRooms) {
                this.changeRoomNameEvent();
                this.buildAutocompleteComponents();
            } else {
                this.emptyAlert.removeClass('hidden');
            }
        };
        // Add room event.
        this.addRoomEvent = function() {
            var thisObject = this;

            // Adding addroom button click event.
            thisObject.addBtn.click(function() {
                thisObject.tabsComponent.countTabs++;

                var newRoomName = M.util.get_string('room', 'zoom') + ' ' + thisObject.tabsComponent.countTabs;
                var newRoomElement = $(thisObject.roomItemToClone);
                var newRoomDataElement = $(thisObject.roomItemDataToClone);
                var newRoomIndex = thisObject.tabsComponent.countTabs;

                // Setting new room name.
                var roomNameInputId = 'room-name-' + newRoomIndex;
                $("input[type=text]", newRoomDataElement).prev().attr('for', roomNameInputId);
                $("input[type=text]", newRoomDataElement).attr('id', roomNameInputId);
                $("input[type=text]", newRoomDataElement).attr('name', roomNameInputId);
                $("input[type=text]", newRoomDataElement).val(newRoomName);
                $("input[type=text]", newRoomDataElement).next().attr('name', 'rooms[' + newRoomIndex + ']');
                $("input[type=text]", newRoomDataElement).next().val(newRoomName);

                // Setting new room participants select id/name.
                var roomParticipantsSelectId = 'participants-' + newRoomIndex;
                $(".room-participants", newRoomDataElement).attr('id', roomParticipantsSelectId);
                $(".room-participants", newRoomDataElement).attr('name', 'roomsparticipants[' + newRoomIndex + '][]');

                // Setting new room participant groups select id/name.
                var roomGroupsSelectId = 'groups-' + newRoomIndex;
                $(".room-groups", newRoomDataElement).attr('id', roomGroupsSelectId);
                $(".room-groups", newRoomDataElement).attr('name', 'roomsgroups[' + newRoomIndex + '][]');

                // Add new room tab
                var newRoom = {"tab": {"name": newRoomName, "element": newRoomElement},
                    "tabContent": {"element": newRoomDataElement}};

                var addedTab = thisObject.tabsComponent.addTab(newRoom);

                // Adding new room tab delete button click event.
                $("li:last .delete-room", thisObject.roomsList).click(function() {
                    var thisItem = $(this).closest('li');
                    thisObject.tabsComponent.deleteTab(thisItem);
                });

                // Adding new room change name event.
                $("input[type=text]", addedTab.content).on("change keyup paste", function() {
                    var newHiddenValue = this.value;
                    $(this).next().val(newHiddenValue);

                    $(".tab-name", addedTab.element).text(this.value);
                });

                // Convert select dropdowns to autocomplete component.
                thisObject.buildAutocompleteComponent(roomParticipantsSelectId, 'addparticipant');
                thisObject.buildAutocompleteComponent(roomGroupsSelectId, 'addparticipantgroup');
            });
        };

        // Delete room event.
        this.deleteRoomEvent = function() {
            var thisObject = this;

            // Adding deleteroom button click event.
            thisObject.deleteBtn.click(function() {
                var thisItem = $(this).closest('li');
                thisObject.tabsComponent.deleteTab(thisItem);
            });
        };

        // Change room name event.
        this.changeRoomNameEvent = function() {
            var thisObject = this;

            $("li", this.roomsListColumn).each(function() {
                var tabIdArr = $(this).attr('id').split('-');
                var tabIndex = tabIdArr[1];
                $('input[name="room-name-' + tabIndex + '"]', thisObject.roomsDataColumn).on("change keyup paste", function() {
                    var newHiddenValue = this.value;
                    $(this).next().val(newHiddenValue);

                    $("#tab-" + tabIndex + " .tab-name").text(this.value);
                });
            });
        };

        /**
         * Build autocomplete components.
         */
        this.buildAutocompleteComponents = function() {
            var thisObject = this;
            $(".room-participants", thisObject.roomsDataColumn).each(function() {
                var thisItemId = $(this).attr('id');
                thisObject.buildAutocompleteComponent(thisItemId, 'addparticipant');
            });

            $(".room-groups", thisObject.roomsDataColumn).each(function() {
                var thisItemId = $(this).attr('id');
                thisObject.buildAutocompleteComponent(thisItemId, 'addparticipantgroup');
            });
        };

        /**
         * Build autocomplete component.
         * @param {string} id
         * @param {string} placeholder
         */
        this.buildAutocompleteComponent = function(id, placeholder) {
            var stringkeys = [{key: placeholder, component: 'zoom'}, {key: 'selectionarea', component: 'zoom'}];
            str.get_strings(stringkeys).then(function(langstrings) {
                var placeholderString = langstrings[0];
                var noSelectionString = langstrings[1];

                autocomplete.enhance('#' + id, false, '', placeholderString, false, true, noSelectionString, true);
                return null;
            }).fail(notification.exception);
        };
    };

    return {
        init: init
    };
});

====================

file: scheduleforchooser.js
path: amd/src/scheduleforchooser.js
codice:
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Schedule for selection handler.
 *
 * @module     mod_zoom/scheduleforchooser
 * @copyright  2022 Antonio Duran Terres <antonio@joomdle.com>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

const Selectors = {
    fields: {
        selector: '[data-scheduleforchooser-field="selector"]',
        updateButton: '[data-scheduleforchooser-field="updateButton"]',
    },
};

/**
 * Initialise the schedule_for chooser.
 */
export const init = () => {
    document.querySelector(Selectors.fields.selector).addEventListener('change', e => {
        const form = e.target.closest('form');
        const updateButton = form.querySelector(Selectors.fields.updateButton);
        const fieldset = updateButton.closest('fieldset');

        const url = new URL(form.action);
        url.hash = fieldset.id;

        form.action = url.toString();
        updateButton.click();
    });
};

====================

file: toggle_text.js
path: amd/src/toggle_text.js
codice:
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Toggles text to be shown when a user hits 'Show More' and
 * hides text when user hits 'Show Less'
 *
 * @copyright  2020 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

import {get_string as getString} from "core/str";

export const init = () => {
  const button = document.querySelector("#show-more-button");
  if (button !== null) {
    const body = document.querySelector("#show-more-body");
    button.addEventListener("click", async() => {
      if (body.style.display === "") {
        body.style.display = "none";
        button.innerHTML = await getString("meeting_invite_show", "mod_zoom");
      } else {
        body.style.display = "";
        button.innerHTML = await getString("meeting_invite_hide", "mod_zoom");
      }
    });
  }
};

====================

file: phpcs.xml
path: phpcs.xml
codice:
<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="MoodleCore">
  <rule ref="moodle-extra">
  </rule>
</ruleset>

====================

file: settings.php
path: settings.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Settings.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot . '/mod/zoom/locallib.php');
require_once($CFG->libdir . '/environmentlib.php');

if ($ADMIN->fulltree) {
    require_once($CFG->dirroot . '/mod/zoom/classes/invitation.php');

    $moodlehashideif = version_compare(normalize_version($CFG->release), '3.7.0', '>=');

    $settings = new admin_settingpage('modsettingzoom', get_string('pluginname', 'mod_zoom'));

    // Test whether connection works and display result to user.
    if (!CLI_SCRIPT && $PAGE->url == $CFG->wwwroot . '/' . $CFG->admin . '/settings.php?section=modsettingzoom') {
        $status = 'connectionfailed';
        $notifyclass = 'notifyproblem';
        $errormessage = '';
        try {
            zoom_get_user(zoom_get_api_identifier($USER));
            $status = 'connectionok';
            $notifyclass = 'notifysuccess';
        } catch (\mod_zoom\webservice_exception $error) {
            $errormessage = $error->response;
        } catch (moodle_exception $error) {
            $errormessage = $error->a;
        }

        $statusmessage = $OUTPUT->notification(get_string('connectionstatus', 'mod_zoom') .
                ': ' . get_string($status, 'mod_zoom') . $errormessage, $notifyclass);
        $connectionstatus = new admin_setting_heading('zoom/connectionstatus', $statusmessage, '');
        $settings->add($connectionstatus);
    }

    // Connection settings.
    $settings->add(new admin_setting_heading(
        'zoom/connectionsettings',
        get_string('connectionsettings', 'mod_zoom'),
        get_string('connectionsettings_desc', 'mod_zoom')
    ));

    $accountid = new admin_setting_configtext(
        'zoom/accountid',
        get_string('accountid', 'mod_zoom'),
        get_string('accountid_desc', 'mod_zoom'),
        '',
        PARAM_ALPHANUMEXT
    );
    $settings->add($accountid);

    $clientid = new admin_setting_configtext(
        'zoom/clientid',
        get_string('clientid', 'mod_zoom'),
        get_string('clientid_desc', 'mod_zoom'),
        '',
        PARAM_ALPHANUMEXT
    );
    $settings->add($clientid);

    $clientsecret = new admin_setting_configpasswordunmask(
        'zoom/clientsecret',
        get_string('clientsecret', 'mod_zoom'),
        get_string('clientsecret_desc', 'mod_zoom'),
        ''
    );
    $settings->add($clientsecret);

    $zoomurl = new admin_setting_configtext(
        'zoom/zoomurl',
        get_string('zoomurl', 'mod_zoom'),
        get_string('zoomurl_desc', 'mod_zoom'),
        '',
        PARAM_URL
    );
    $settings->add($zoomurl);

    $apiendpointchoices = [
        ZOOM_API_ENDPOINT_GLOBAL => get_string('apiendpoint_global', 'mod_zoom'),
        ZOOM_API_ENDPOINT_EU => get_string('apiendpoint_eu', 'mod_zoom'),
    ];
    $apiendpoint = new admin_setting_configselect(
        'zoom/apiendpoint',
        get_string('apiendpoint', 'mod_zoom'),
        get_string('apiendpoint_desc', 'mod_zoom'),
        ZOOM_API_ENDPOINT_GLOBAL,
        $apiendpointchoices
    );
    $settings->add($apiendpoint);

    $proxyhost = new admin_setting_configtext(
        'zoom/proxyhost',
        get_string('option_proxyhost', 'mod_zoom'),
        get_string('option_proxyhost_desc', 'mod_zoom'),
        '',
        '/^[a-zA-Z0-9.-]+:[0-9]+$|^$/'
    );
    $settings->add($proxyhost);

    $apiidentifier = new admin_setting_configselect(
        'zoom/apiidentifier',
        get_string('apiidentifier', 'mod_zoom'),
        get_string('apiidentifier_desc', 'mod_zoom'),
        'email',
        zoom_get_api_identifier_fields()
    );
    $settings->add($apiidentifier);

    // License settings.
    $settings->add(new admin_setting_heading(
        'zoom/licensesettings',
        get_string('licensesettings', 'mod_zoom'),
        get_string('licensesettings_desc', 'mod_zoom')
    ));

    $licensescount = new admin_setting_configtext(
        'zoom/licensesnumber',
        get_string('licensesnumber', 'mod_zoom'),
        null,
        0,
        PARAM_INT
    );
    $settings->add($licensescount);

    $utmost = new admin_setting_configcheckbox(
        'zoom/utmost',
        get_string('redefinelicenses', 'mod_zoom'),
        get_string('lowlicenses', 'mod_zoom'),
        0,
        1
    );
    $settings->add($utmost);

    $instanceusers = new admin_setting_configcheckbox(
        'zoom/instanceusers',
        get_string('instanceusers', 'mod_zoom'),
        get_string('instanceusers_desc', 'mod_zoom'),
        0,
        1,
        0
    );
    $settings->add($instanceusers);

    $recycleonjoin = new admin_setting_configcheckbox(
        'zoom/recycleonjoin',
        get_string('recycleonjoin', 'mod_zoom'),
        get_string('licenseonjoin', 'mod_zoom'),
        0,
        1
    );
    $settings->add($recycleonjoin);

    // Only call to the web services and load the setting if the connection is OK.
    if (isset($status) && $status === 'connectionok') {
        $zoomgroups = [];
        $groups = zoom_webservice()->get_groups();
        foreach ($groups as $group) {
            $zoomgroups[$group->id] = $group->name;
        }

        $protectedgroups = new admin_setting_configmultiselect(
            'zoom/protectedgroups',
            get_string('protectedgroups', 'mod_zoom'),
            get_string('protectedgroups_desc', 'mod_zoom'),
            [],
            $zoomgroups
        );
        $settings->add($protectedgroups);
    }

    // Global settings.
    $settings->add(new admin_setting_heading(
        'zoom/globalsettings',
        get_string('globalsettings', 'mod_zoom'),
        get_string('globalsettings_desc', 'mod_zoom')
    ));

    $jointimechoices = [0, 5, 10, 15, 20, 30, 45, 60];
    $jointimeselect = [];
    foreach ($jointimechoices as $minutes) {
        $jointimeselect[$minutes] = $minutes . ' ' . get_string('mins');
    }

    $firstabletojoin = new admin_setting_configselect(
        'zoom/firstabletojoin',
        get_string('firstjoin', 'mod_zoom'),
        get_string('firstjoin_desc', 'mod_zoom'),
        15,
        $jointimeselect
    );
    $settings->add($firstabletojoin);

    if ($moodlehashideif) {
        $displayleadtime = new admin_setting_configcheckbox(
            'zoom/displayleadtime',
            get_string('displayleadtime', 'mod_zoom'),
            get_string('displayleadtime_desc', 'mod_zoom'),
            0,
            1,
            0
        );
        $settings->add($displayleadtime);
        $settings->hide_if('zoom/displayleadtime', 'zoom/firstabletojoin', 'eq', 0);
    } else {
        $displayleadtime = new admin_setting_configcheckbox(
            'zoom/displayleadtime',
            get_string('displayleadtime', 'mod_zoom'),
            get_string('displayleadtime_desc', 'mod_zoom') . '<br />' .
                        get_string('displayleadtime_nohideif', 'mod_zoom', get_string('firstjoin', 'mod_zoom')),
            0,
            1,
            0
        );
        $settings->add($displayleadtime);
    }

    $displaypassword = new admin_setting_configcheckbox(
        'zoom/displaypassword',
        get_string('displaypassword', 'mod_zoom'),
        get_string('displaypassword_help', 'mod_zoom'),
        0,
        1,
        0
    );
    $settings->add($displaypassword);

    $maskparticipantdata = new admin_setting_configcheckbox(
        'zoom/maskparticipantdata',
        get_string('maskparticipantdata', 'mod_zoom'),
        get_string('maskparticipantdata_help', 'mod_zoom'),
        0,
        1
    );
    $settings->add($maskparticipantdata);

    $viewrecordings = new admin_setting_configcheckbox(
        'zoom/viewrecordings',
        get_string('option_view_recordings', 'mod_zoom'),
        '',
        0,
        1,
        0
    );
    $settings->add($viewrecordings);

    // Adding options for the display name using uname parameter in zoom join_url.
    $options = [
        'fullname' => get_string('displayfullname', 'mod_zoom'),
        'firstname' => get_string('displayfirstname', 'mod_zoom'),
        'idfullname' => get_string('displayidfullname', 'mod_zoom'),
        'id' => get_string('displayid', 'mod_zoom'),
    ];
    $settings->add(new admin_setting_configselect(
        'zoom/unamedisplay',
        get_string('unamedisplay', 'mod_zoom'),
        get_string('unamedisplay_help', 'mod_zoom'),
        'fullname',
        $options
    ));

    // Supplementary features settings.
    $settings->add(new admin_setting_heading(
        'zoom/supplementaryfeaturessettings',
        get_string('supplementaryfeaturessettings', 'mod_zoom'),
        get_string('supplementaryfeaturessettings_desc', 'mod_zoom')
    ));

    $webinarchoices = [
        ZOOM_WEBINAR_DISABLE => get_string('webinar_disable', 'mod_zoom'),
        ZOOM_WEBINAR_SHOWONLYIFLICENSE => get_string('webinar_showonlyiflicense', 'mod_zoom'),
        ZOOM_WEBINAR_ALWAYSSHOW => get_string('webinar_alwaysshow', 'mod_zoom'),
    ];
    $offerwebinar = new admin_setting_configselect(
        'zoom/showwebinars',
        get_string('webinar', 'mod_zoom'),
        get_string('webinar_desc', 'mod_zoom'),
        ZOOM_WEBINAR_ALWAYSSHOW,
        $webinarchoices
    );
    $settings->add($offerwebinar);

    $webinardefault = new admin_setting_configcheckbox(
        'zoom/webinardefault',
        get_string('webinar_by_default', 'mod_zoom'),
        get_string('webinar_by_default_desc', 'mod_zoom'),
        0,
        1,
        0
    );
    $settings->add($webinardefault);

    $encryptionchoices = [
        ZOOM_ENCRYPTION_DISABLE => get_string('encryptiontype_disable', 'mod_zoom'),
        ZOOM_ENCRYPTION_SHOWONLYIFPOSSIBLE => get_string('encryptiontype_showonlyife2epossible', 'mod_zoom'),
        ZOOM_ENCRYPTION_ALWAYSSHOW => get_string('encryptiontype_alwaysshow', 'mod_zoom'),
    ];
    $offerencryption = new admin_setting_configselect(
        'zoom/showencryptiontype',
        get_string('encryptiontype', 'mod_zoom'),
        get_string('encryptiontype_desc', 'mod_zoom'),
        ZOOM_ENCRYPTION_SHOWONLYIFPOSSIBLE,
        $encryptionchoices
    );
    $settings->add($offerencryption);

    $schedulingprivilegechoices = [
        ZOOM_SCHEDULINGPRIVILEGE_DISABLE => get_string('schedulingprivilege_disable', 'mod_zoom'),
        ZOOM_SCHEDULINGPRIVILEGE_ENABLE => get_string('schedulingprivilege_enable', 'mod_zoom'),
    ];
    $offerschedulingprivilege = new admin_setting_configselect(
        'zoom/showschedulingprivilege',
        get_string('schedulingprivilege', 'mod_zoom'),
        get_string('schedulingprivilege_desc', 'mod_zoom'),
        ZOOM_SCHEDULINGPRIVILEGE_ENABLE,
        $schedulingprivilegechoices
    );
    $settings->add($offerschedulingprivilege);

    $alternativehostschoices = [
        ZOOM_ALTERNATIVEHOSTS_DISABLE => get_string('alternative_hosts_disable', 'mod_zoom'),
        ZOOM_ALTERNATIVEHOSTS_INPUTFIELD => get_string('alternative_hosts_inputfield', 'mod_zoom'),
        ZOOM_ALTERNATIVEHOSTS_PICKER => get_string('alternative_hosts_picker', 'mod_zoom'),
    ];
    $alternativehostsroles = zoom_get_selectable_alternative_hosts_rolestring(context_system::instance());
    $offeralternativehosts = new admin_setting_configselect(
        'zoom/showalternativehosts',
        get_string('alternative_hosts', 'mod_zoom'),
        get_string('alternative_hosts_desc', 'mod_zoom', ['roles' => $alternativehostsroles]),
        ZOOM_ALTERNATIVEHOSTS_INPUTFIELD,
        $alternativehostschoices
    );
    $settings->add($offeralternativehosts);

    $capacitywarningchoices = [
        ZOOM_CAPACITYWARNING_DISABLE => get_string('meetingcapacitywarning_disable', 'mod_zoom'),
        ZOOM_CAPACITYWARNING_ENABLE => get_string('meetingcapacitywarning_enable', 'mod_zoom'),
    ];
    $offercapacitywarning = new admin_setting_configselect(
        'zoom/showcapacitywarning',
        get_string('meetingcapacitywarning', 'mod_zoom'),
        get_string('meetingcapacitywarning_desc', 'mod_zoom'),
        ZOOM_CAPACITYWARNING_ENABLE,
        $capacitywarningchoices
    );
    $settings->add($offercapacitywarning);

    $allmeetingschoices = [
        ZOOM_ALLMEETINGS_DISABLE => get_string('allmeetings_disable', 'mod_zoom'),
        ZOOM_ALLMEETINGS_ENABLE => get_string('allmeetings_enable', 'mod_zoom'),
    ];
    $offerallmeetings = new admin_setting_configselect(
        'zoom/showallmeetings',
        get_string('allmeetings', 'mod_zoom'),
        get_string('allmeetings_desc', 'mod_zoom'),
        ZOOM_ALLMEETINGS_ENABLE,
        $allmeetingschoices
    );
    $settings->add($offerallmeetings);

    $downloadicalchoices = [
        ZOOM_DOWNLOADICAL_DISABLE => get_string('downloadical_disable', 'mod_zoom'),
        ZOOM_DOWNLOADICAL_ENABLE => get_string('downloadical_enable', 'mod_zoom'),
    ];
    $offerdownloadical = new admin_setting_configselect(
        'zoom/showdownloadical',
        get_string('downloadical', 'mod_zoom'),
        get_string('downloadical_desc', 'mod_zoom'),
        ZOOM_DOWNLOADICAL_ENABLE,
        $downloadicalchoices
    );
    $settings->add($offerdownloadical);

    $sendicalnotificationshelp = get_string('sendicalnotifications_help', 'mod_zoom');
    if (empty($CFG->allowattachments)) {
        $sendicalnotificationshelp .= '<div class="alert alert-block alert-warning" role="alert">'
                                      . get_string('sendicalnotifications_warning', 'mod_zoom') . '</div>';
    }

    $sendicalnotifications = new admin_setting_configcheckbox(
        'zoom/sendicalnotifications',
        get_string('sendicalnotifications', 'mod_zoom'),
        $sendicalnotificationshelp,
        0,
        1,
        0
    );
    $settings->add($sendicalnotifications);

    // Default Zoom settings.
    $settings->add(new admin_setting_heading(
        'zoom/defaultsettings',
        get_string('defaultsettings', 'mod_zoom'),
        get_string('defaultsettings_help', 'mod_zoom')
    ));

    $defaultrecurring = new admin_setting_configcheckbox(
        'zoom/defaultrecurring',
        get_string('recurringmeeting', 'mod_zoom'),
        get_string('recurringmeeting_help', 'mod_zoom'),
        0,
        1,
        0
    );
    $settings->add($defaultrecurring);

    $defaultshowschedule = new admin_setting_configcheckbox(
        'zoom/defaultshowschedule',
        get_string('showschedule', 'mod_zoom'),
        get_string('showschedule_help', 'mod_zoom'),
        1,
        1,
        0
    );
    $settings->add($defaultshowschedule);

    $defaultregistration = new admin_setting_configcheckbox(
        'zoom/defaultregistration',
        get_string('registration', 'mod_zoom'),
        get_string('registration_help', 'mod_zoom'),
        ZOOM_REGISTRATION_OFF,
        ZOOM_REGISTRATION_AUTOMATIC,
        ZOOM_REGISTRATION_OFF
    );
    $settings->add($defaultregistration);

    $defaultrequirepasscode = new admin_setting_configcheckbox(
        'zoom/requirepasscode',
        get_string('requirepasscode', 'mod_zoom'),
        get_string('requirepasscode_help', 'mod_zoom'),
        1
    );
    $defaultrequirepasscode->set_locked_flag_options(admin_setting_flag::ENABLED, true);
    $settings->add($defaultrequirepasscode);

    $encryptionchoices = [
        ZOOM_ENCRYPTION_TYPE_ENHANCED => get_string('option_encryption_type_enhancedencryption', 'mod_zoom'),
        ZOOM_ENCRYPTION_TYPE_E2EE => get_string('option_encryption_type_endtoendencryption', 'mod_zoom'),
    ];
    $defaultencryptiontypeoption = new admin_setting_configselect(
        'zoom/defaultencryptiontypeoption',
        get_string('option_encryption_type', 'mod_zoom'),
        get_string('option_encryption_type_help', 'mod_zoom'),
        ZOOM_ENCRYPTION_TYPE_ENHANCED,
        $encryptionchoices
    );
    $settings->add($defaultencryptiontypeoption);

    $defaultwaitingroomoption = new admin_setting_configcheckbox(
        'zoom/defaultwaitingroomoption',
        get_string('option_waiting_room', 'mod_zoom'),
        get_string('option_waiting_room_help', 'mod_zoom'),
        1,
        1,
        0
    );
    $settings->add($defaultwaitingroomoption);

    $defaultjoinbeforehost = new admin_setting_configcheckbox(
        'zoom/defaultjoinbeforehost',
        get_string('option_jbh', 'mod_zoom'),
        get_string('option_jbh_help', 'mod_zoom'),
        0,
        1,
        0
    );
    $settings->add($defaultjoinbeforehost);

    $defaultauthusersoption = new admin_setting_configcheckbox(
        'zoom/defaultauthusersoption',
        get_string('option_authenticated_users', 'mod_zoom'),
        get_string('option_authenticated_users_help', 'mod_zoom'),
        0,
        1,
        0
    );
    $settings->add($defaultauthusersoption);

    $defaultshowsecurity = new admin_setting_configcheckbox(
        'zoom/defaultshowsecurity',
        get_string('showsecurity', 'mod_zoom'),
        get_string('showsecurity_help', 'mod_zoom'),
        1,
        1,
        0
    );
    $settings->add($defaultshowsecurity);

    $defaulthostvideo = new admin_setting_configcheckbox(
        'zoom/defaulthostvideo',
        get_string('option_host_video', 'mod_zoom'),
        get_string('option_host_video_help', 'mod_zoom'),
        0,
        1,
        0
    );
    $settings->add($defaulthostvideo);

    $defaultparticipantsvideo = new admin_setting_configcheckbox(
        'zoom/defaultparticipantsvideo',
        get_string('option_participants_video', 'mod_zoom'),
        get_string('option_participants_video_help', 'mod_zoom'),
        0,
        1,
        0
    );
    $settings->add($defaultparticipantsvideo);

    $audiochoices = [
        ZOOM_AUDIO_TELEPHONY => get_string('audio_telephony', 'mod_zoom'),
        ZOOM_AUDIO_VOIP => get_string('audio_voip', 'mod_zoom'),
        ZOOM_AUDIO_BOTH => get_string('audio_both', 'mod_zoom'),
    ];
    $defaultaudiooption = new admin_setting_configselect(
        'zoom/defaultaudiooption',
        get_string('option_audio', 'mod_zoom'),
        get_string('option_audio_help', 'mod_zoom'),
        ZOOM_AUDIO_BOTH,
        $audiochoices
    );
    $settings->add($defaultaudiooption);

    $defaultmuteuponentryoption = new admin_setting_configcheckbox(
        'zoom/defaultmuteuponentryoption',
        get_string('option_mute_upon_entry', 'mod_zoom'),
        get_string('option_mute_upon_entry_help', 'mod_zoom'),
        1,
        1,
        0
    );
    $settings->add($defaultmuteuponentryoption);

    $autorecordingchoices = [
        ZOOM_AUTORECORDING_NONE => get_string('autorecording_none', 'mod_zoom'),
        ZOOM_AUTORECORDING_USERDEFAULT => get_string('autorecording_userdefault', 'mod_zoom'),
        ZOOM_AUTORECORDING_LOCAL => get_string('autorecording_local', 'mod_zoom'),
        ZOOM_AUTORECORDING_CLOUD => get_string('autorecording_cloud', 'mod_zoom'),
    ];
    $recordingoption = new admin_setting_configselect(
        'zoom/recordingoption',
        get_string('option_auto_recording', 'mod_zoom'),
        get_string('option_auto_recording_help', 'mod_zoom'),
        ZOOM_AUTORECORDING_USERDEFAULT,
        $autorecordingchoices
    );
    $settings->add($recordingoption);

    $allowrecordingchangeoption = new admin_setting_configcheckbox(
        'zoom/allowrecordingchangeoption',
        get_string('option_allow_recording_change', 'mod_zoom'),
        get_string('option_allow_recording_change_help', 'mod_zoom'),
        1,
        1,
        0
    );
    $settings->add($allowrecordingchangeoption);

    $defaultshowmedia = new admin_setting_configcheckbox(
        'zoom/defaultshowmedia',
        get_string('showmedia', 'mod_zoom'),
        get_string('showmedia_help', 'mod_zoom'),
        1,
        1,
        0
    );
    $settings->add($defaultshowmedia);

    $defaulttrackingfields = new admin_setting_configtextarea(
        'zoom/defaulttrackingfields',
        get_string('trackingfields', 'mod_zoom'),
        get_string('trackingfields_help', 'mod_zoom'),
        ''
    );
    $defaulttrackingfields->set_updatedcallback('mod_zoom_update_tracking_fields');
    $settings->add($defaulttrackingfields);

    $invitationregexhelp = get_string('invitationregex_help', 'mod_zoom');
    if (!$moodlehashideif) {
        $invitationregexhelp .= "\n\n" . get_string(
            'invitationregex_nohideif',
            'mod_zoom',
            get_string('invitationregexenabled', 'mod_zoom')
        );
    }

    $settings->add(new admin_setting_heading(
        'zoom/invitationregex',
        get_string('invitationregex', 'mod_zoom'),
        $invitationregexhelp
    ));

    $settings->add(new admin_setting_configcheckbox(
        'zoom/invitationregexenabled',
        get_string('invitationregexenabled', 'mod_zoom'),
        get_string('invitationregexenabled_help', 'mod_zoom'),
        0,
        1,
        0
    ));

    $settings->add(new admin_setting_configcheckbox(
        'zoom/invitationremoveinvite',
        get_string('invitationremoveinvite', 'mod_zoom'),
        get_string('invitationremoveinvite_help', 'mod_zoom'),
        0,
        1,
        0
    ));
    if ($moodlehashideif) {
        $settings->hide_if('zoom/invitationremoveinvite', 'zoom/invitationregexenabled', 'eq', 0);
    }

    $settings->add(new admin_setting_configcheckbox(
        'zoom/invitationremoveicallink',
        get_string('invitationremoveicallink', 'mod_zoom'),
        get_string('invitationremoveicallink_help', 'mod_zoom'),
        0,
        1,
        0
    ));
    if ($moodlehashideif) {
        $settings->hide_if('zoom/invitationremoveicallink', 'zoom/invitationregexenabled', 'eq', 0);
    }

    // Allow admin to modify regex for invitation parts if zoom api changes.
    foreach (\mod_zoom\invitation::get_default_invitation_regex() as $element => $pattern) {
        $name = 'zoom/' . \mod_zoom\invitation::PREFIX . $element;
        $visiblename = get_string(\mod_zoom\invitation::PREFIX . $element, 'mod_zoom');
        $description = get_string(\mod_zoom\invitation::PREFIX . $element . '_help', 'mod_zoom');
        $settings->add(new admin_setting_configtext($name, $visiblename, $description, $pattern));
        if ($moodlehashideif) {
            $settings->hide_if(
                'zoom/' . \mod_zoom\invitation::PREFIX . $element,
                'zoom/invitationregexenabled',
                'eq',
                0
            );
        }
    }

    // Extra hideif for elements which can be enabled / disabled individually.
    if ($moodlehashideif) {
        $settings->hide_if('zoom/invitation_invite', 'zoom/invitationremoveinvite', 'eq', 0);
        $settings->hide_if('zoom/invitation_icallink', 'zoom/invitationremoveicallink', 'eq', 0);
    }

    // Adding options for grading methods.
    $settings->add(new admin_setting_heading(
        'zoom/gradingmethod',
        get_string('gradingmethod_heading', 'mod_zoom'),
        get_string('gradingmethod_heading_help', 'mod_zoom')
    ));

    // Grading method upon entry: the user gets the full score when clicking to join the session through Moodle.
    // Grading method upon period: the user is graded based on how long they attended the actual session.
    $options = [
        'entry' => get_string('gradingentry', 'mod_zoom'),
        'period' => get_string('gradingperiod', 'mod_zoom'),
    ];
    $settings->add(new admin_setting_configselect(
        'zoom/gradingmethod',
        get_string('gradingmethod', 'mod_zoom'),
        get_string('gradingmethod_help', 'mod_zoom'),
        'entry',
        $options
    ));
}

====================

file: index.php
path: index.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * List all zoom meetings.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

require(__DIR__ . '/../../config.php');
require_once(__DIR__ . '/lib.php');
require_once(__DIR__ . '/locallib.php');
require_once($CFG->libdir . '/moodlelib.php');

$id = required_param('id', PARAM_INT); // Course.

$course = $DB->get_record('course', ['id' => $id], '*', MUST_EXIST);

require_course_login($course);

$context = context_course::instance($course->id);
require_capability('mod/zoom:view', $context);
$iszoommanager = has_capability('mod/zoom:addinstance', $context);

$params = [
    'context' => $context,
];
$event = \mod_zoom\event\course_module_instance_list_viewed::create($params);
$event->add_record_snapshot('course', $course);
$event->trigger();

$strname = get_string('modulenameplural', 'mod_zoom');
$strnew = get_string('newmeetings', 'mod_zoom');
$strold = get_string('oldmeetings', 'mod_zoom');

$strtitle = get_string('title', 'mod_zoom');
$strwebinar = get_string('webinar', 'mod_zoom');
$strtime = get_string('meeting_time', 'mod_zoom');
$strduration = get_string('duration', 'mod_zoom');
$stractions = get_string('actions', 'mod_zoom');
$strsessions = get_string('sessions', 'mod_zoom');

$strmeetingstarted = get_string('meeting_started', 'mod_zoom');
$strjoin = get_string('join', 'mod_zoom');

$PAGE->set_url('/mod/zoom/index.php', ['id' => $id]);
$PAGE->navbar->add($strname);
$PAGE->set_title("$course->shortname: $strname");
$PAGE->set_heading($course->fullname);
$PAGE->set_pagelayout('incourse');

echo $OUTPUT->header();

if ($CFG->branch < '400') {
    echo $OUTPUT->heading($strname);
}

if (! $zooms = get_all_instances_in_course('zoom', $course)) {
    notice(get_string('nozooms', 'mod_zoom'), new moodle_url('/course/view.php', ['id' => $course->id]));
}

$usesections = course_format_uses_sections($course->format);

$zoomuserid = zoom_get_user_id(false);

$newtable = new html_table();
$newtable->attributes['class'] = 'generaltable mod_index';
$newhead = [$strtitle, $strtime, $strduration, $stractions];
$newalign = ['left', 'left', 'left', 'left'];

$oldtable = new html_table();
$oldhead = [$strtitle, $strtime];
$oldalign = ['left', 'left'];

// Show section column if there are sections.
if ($usesections) {
    $strsectionname = get_string('sectionname', 'format_' . $course->format);
    array_unshift($newhead, $strsectionname);
    array_unshift($newalign, 'center');
    array_unshift($oldhead, $strsectionname);
    array_unshift($oldalign, 'center');
}

// Show sessions column only if user can edit Zoom meetings.
if ($iszoommanager) {
    $newhead[] = $strsessions;
    $newalign[] = 'left';
    $oldhead[] = $strsessions;
    $oldalign[] = 'left';
}

$newtable->head = $newhead;
$newtable->align = $newalign;
$oldtable->head = $oldhead;
$oldtable->align = $oldalign;

$now = time();
$modinfo = get_fast_modinfo($course);
$cms = $modinfo->instances['zoom'];
foreach ($zooms as $z) {
    $row = [];
    [$inprogress, $available, $finished] = zoom_get_state($z);

    $cm = $cms[$z->id];
    if ($usesections && isset($cm->sectionnum)) {
        $row[0] = get_section_name($course, $cm->sectionnum);
    }

    $url = new moodle_url('view.php', ['id' => $cm->id]);
    $row[1] = html_writer::link($url, $cm->get_formatted_name());
    if ($z->webinar) {
        $row[1] .= " ($strwebinar)";
    }

    // Get start time column information.
    if ($z->recurring && $z->recurrence_type == ZOOM_RECURRINGTYPE_NOTIME) {
        $displaytime = get_string('recurringmeeting', 'mod_zoom');
        $displaytime .= html_writer::empty_tag('br');
        $displaytime .= get_string('recurringmeetingexplanation', 'mod_zoom');
    } else if ($z->recurring && $z->recurrence_type != ZOOM_RECURRINGTYPE_NOTIME) {
        $displaytime = get_string('recurringmeeting', 'mod_zoom');
        $displaytime .= html_writer::empty_tag('br');
        if (($nextoccurrence = zoom_get_next_occurrence($z)) > 0) {
            $displaytime .= get_string('nextoccurrence', 'mod_zoom') . ': ' . userdate($nextoccurrence);
        } else {
            $displaytime .= get_string('nooccurrenceleft', 'mod_zoom');
        }
    } else {
        $displaytime = userdate($z->start_time);
    }

    $report = new moodle_url('report.php', ['id' => $cm->id]);
    $sessions = html_writer::link($report, $strsessions);

    if ($finished) {
        $row[2] = $displaytime;
        if ($iszoommanager) {
            $row[3] = $sessions;
        }

        $oldtable->data[] = $row;
    } else {
        if ($inprogress) {
            $label = html_writer::tag('span', $strmeetingstarted, ['class' => 'badge bg-dark badge-dark bg-text-dark']);
            $row[2] = html_writer::tag('div', $label);
        } else {
            $row[2] = $displaytime;
        }

        $row[3] = ($z->recurring && $z->recurrence_type == ZOOM_RECURRINGTYPE_NOTIME) ? '--' : format_time($z->duration);

        if ($available) {
            $buttonhtml = html_writer::tag('button', $strjoin, ['type' => 'submit', 'class' => 'btn btn-primary']);
            $aurl = new moodle_url('/mod/zoom/loadmeeting.php', ['id' => $cm->id]);
            $buttonhtml .= html_writer::input_hidden_params($aurl);
            $row[4] = html_writer::tag('form', $buttonhtml, ['action' => $aurl->out_omit_querystring(), 'target' => '_blank']);
        } else {
            $row[4] = '--';
        }

        if ($iszoommanager) {
            $row[] = $sessions;
        }

        $newtable->data[] = $row;
    }
}

echo $OUTPUT->heading($strnew, 4);
echo html_writer::table($newtable);
echo $OUTPUT->heading($strold, 4, null, 'mod-zoom-old-meetings-header');
// Show refresh meeting sessions link only if user can run the 'refresh session reports' console command.
if (has_capability('mod/zoom:refreshsessions', $context)) {
    $linkarguments = [
        'courseid' => $id,
        'start' => date('Y-m-d', strtotime('-3 days')),
        'end' => date('Y-m-d'),
    ];
    $url = new moodle_url($CFG->wwwroot . '/mod/zoom/console/get_meeting_report.php', $linkarguments);
    echo html_writer::link($url, get_string('refreshreports', 'mod_zoom'), ['target' => '_blank', 'class' => 'pl-4']);
}

echo html_writer::table($oldtable);

echo $OUTPUT->footer();

====================

file: get_meeting_reports_test.php
path: tests/get_meeting_reports_test.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Unit tests for get_meeting_reports task class.
 *
 * @package    mod_zoom
 * @copyright  2019 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

use advanced_testcase;
use context_course;
use html_writer;
use moodle_url;
use stdClass;

/**
 * PHPunit testcase class.
 * @covers \mod_zoom\task\get_meeting_reports
 */
final class get_meeting_reports_test extends advanced_testcase {
    /**
     * Scheduled task object.
     * @var \mod_zoom\task\get_meeting_reports
     */
    private $meetingtask;

    /**
     * Fake data to return for mocked get_meeting_participants() call.
     * @var array
     */
    private $mockparticipantsdata;

    /**
     * Fake data from get_meeting_participants().
     * @var object
     */
    private $zoomdata;

    /**
     * Mocks the mod_zoom\webservice->get_meeting_participants() call, so we
     * don't actually call the real Zoom API.
     *
     * @param string $meetinguuid The meeting or webinar's UUID.
     * @param bool $webinar Whether the meeting or webinar whose information you want is a webinar.
     * @return array    The specified meeting participants array for given meetinguuid.
     */
    public function mock_get_meeting_participants($meetinguuid, $webinar) {
        return $this->mockparticipantsdata[$meetinguuid] ?? null;
    }

    /**
     * Setup.
     */
    public function setUp(): void {
        parent::setUp();

        $this->resetAfterTest(true);

        $this->meetingtask = new \mod_zoom\task\get_meeting_reports();

        $data = [
            'id' => 'ARANDOMSTRINGFORUUID',
            'user_id' => 123456789,
            'name' => 'SMITH, JOE',
            'user_email' => 'joe@test.com',
            'join_time' => '2019-01-01T00:00:00Z',
            'leave_time' => '2019-01-01T00:01:00Z',
            'duration' => 60,
        ];
        $this->zoomdata = (object) $data;
    }

    /**
     * Make sure that format_participant() filters bad data from Zoom.
     */
    public function test_format_participant_filtering(): void {
        // Sometimes Zoom has a # instead of comma in the name.
        $this->zoomdata->name = 'SMITH# JOE';
        $participant = $this->meetingtask->format_participant($this->zoomdata, 1, [], []);
        $this->assertEquals('SMITH, JOE', $participant['name']);
    }

    /**
     * Make sure that format_participant() can match Moodle users.
     */
    public function test_format_participant_matching(): void {
        global $DB;
        return;

        // 1) If user does not match, verify that we are using data from Zoom.
        $participant = $this->meetingtask->format_participant($this->zoomdata, 1, [], []);
        $this->assertEquals($this->zoomdata->name, $participant['name']);
        $this->assertEquals($this->zoomdata->user_email, $participant['user_email']);
        $this->assertNull($participant['userid']);

        // 2) Try to match view via system email.

        // Add user's email to Moodle system.
        $user = $this->getDataGenerator()->create_user(
            ['email' => $this->zoomdata->user_email]
        );

        $participant = $this->meetingtask->format_participant($this->zoomdata, 1, [], []);
        $this->assertEquals($user->id, $participant['userid']);
        $this->assertEquals(strtoupper(fullname($user)), $participant['name']);
        $this->assertEquals($user->email, $participant['user_email']);

        // 3) Try to match view via enrolled name.

        // Change user's name to make sure we are matching on name.
        $user->firstname = 'Firstname';
        $user->lastname = 'Lastname';
        $DB->update_record('user', $user);
        // Set to blank so previous test does not trigger.
        $this->zoomdata->user_email = '';

        // Create course and enroll user.
        $course = $this->getDataGenerator()->create_course();
        $this->getDataGenerator()->enrol_user($user->id, $course->id);
        [$names, $emails] = $this->meetingtask->get_enrollments($course->id);

        // Before Zoom data is changed, should return nothing.
        $participant = $this->meetingtask->format_participant($this->zoomdata, 1, $names, $emails);
        $this->assertNull($participant['userid']);

        // Change Zoom data and now user should be found.
        $this->zoomdata->name = strtoupper(fullname($user));
        $participant = $this->meetingtask->format_participant($this->zoomdata, 1, $names, $emails);
        $this->assertEquals($user->id, $participant['userid']);
        $this->assertEquals($names[$participant['userid']], $participant['name']);
        // Email should match what Zoom gives us.
        $this->assertEquals($this->zoomdata->user_email, $participant['user_email']);

        // 4) Try to match view via enrolled email.

        // Change user's email to make sure we are matching on email.
        $user->email = 'smith@test.com';
        $DB->update_record('user', $user);
        // Change name so previous test does not trigger.
        $this->zoomdata->name = 'Something Else';
        // Since email changed, update enrolled user data.
        [$names, $emails] = $this->meetingtask->get_enrollments($course->id);

        // Before Zoom data is changed, should return nothing.
        $participant = $this->meetingtask->format_participant($this->zoomdata, 1, $names, $emails);
        $this->assertNull($participant['userid']);

        // Change Zoom data and now user should be found.
        $this->zoomdata->user_email = $user->email;
        $participant = $this->meetingtask->format_participant($this->zoomdata, 1, $names, $emails);
        $this->assertEquals($user->id, $participant['userid']);
        $this->assertEquals($names[$participant['userid']], $participant['name']);
        // Email should match what Zoom gives us.
        $this->assertEquals($this->zoomdata->user_email, $participant['user_email']);

        // 5) Try to match user via id (uuid).

        // Insert previously generated $participant data, but with UUID set.
        $participant['uuid'] = $this->zoomdata->id;
        // Set userid to a given value so we know we got a match.
        $participant['userid'] = 999;
        $recordid = $DB->insert_record('zoom_meeting_participants', $participant);

        // Should return the found entry in zoom_meeting_participants.
        $newparticipant = $this->meetingtask->format_participant($this->zoomdata, 1, $names, $emails);
        $this->assertEquals($participant['uuid'], $newparticipant['uuid']);
        $this->assertEquals(999, $newparticipant['userid']);
        $this->assertEquals($participant['name'], $newparticipant['name']);
        // Email should match what Zoom gives us.
        $this->assertEquals($this->zoomdata->user_email, $newparticipant['user_email']);
    }

    /**
     * Make sure that format_participant() can match Moodle users more
     * aggressively on name.
     */
    public function test_format_participant_name_matching(): void {
        // Enroll a bunch of users. Note: names were generated by
        // https://www.behindthename.com/random/ and any similarity to anyone
        // real or ficitional is concidence and not intentional.
        $users[0] = $this->getDataGenerator()->create_user([
            'lastname' => 'VAN ANTWERPEN',
            'firstname' => 'LORETO ZAHIRA',
        ]);
        $users[1] = $this->getDataGenerator()->create_user([
            'lastname' => 'POWER',
            'firstname' => 'TEIMURAZI ELLI',
        ]);
        $users[2] = $this->getDataGenerator()->create_user([
            'lastname' => 'LITTLE',
            'firstname' => 'BASEMATH ALIZA',
        ]);
        $users[3] = $this->getDataGenerator()->create_user([
            'lastname' => 'MUTTON',
            'firstname' => 'RADOVAN BRIANNA',
        ]);
        $users[4] = $this->getDataGenerator()->create_user([
            'lastname' => 'MUTTON',
            'firstname' => 'BRUNO EVGENIJA',
        ]);
        $course = $this->getDataGenerator()->create_course();
        foreach ($users as $user) {
            $this->getDataGenerator()->enrol_user($user->id, $course->id);
        }

        [$names, $emails] = $this->meetingtask->get_enrollments($course->id);

        // 1) Make sure we match someone with middle name missing.
        $users[0]->firstname = 'LORETO';
        $this->zoomdata->name = fullname($users[0]);
        $participant = $this->meetingtask->format_participant($this->zoomdata, 1, $names, $emails);
        $this->assertEquals($users[0]->id, $participant['userid']);

        // 2) Make sure that name matches even if there are no spaces.
        $users[1]->firstname = str_replace(' ', '', $users[1]->firstname);
        $this->zoomdata->name = fullname($users[1]);
        $participant = $this->meetingtask->format_participant($this->zoomdata, 1, $names, $emails);
        $this->assertEquals($users[1]->id, $participant['userid']);

        // 3) Make sure that name matches even if we have different ordering.
        $this->zoomdata->name = 'MUTTON, RADOVAN BRIANNA';
        $participant = $this->meetingtask->format_participant($this->zoomdata, 1, $names, $emails);
        $this->assertEquals($users[3]->id, $participant['userid']);

        // 4) Make sure we do not match users if just last name is the same.
        $users[2]->firstname = 'JOSH';
        $this->zoomdata->name = fullname($users[2]);
        $participant = $this->meetingtask->format_participant($this->zoomdata, 1, $names, $emails);
        $this->assertEmpty($participant['userid']);

        // 5) Make sure we do not match users if name is not similar to anything.
        $users[4]->firstname = 'JOSH';
        $users[4]->lastname = 'SMITH';
        $this->zoomdata->name = fullname($users[4]);
        $participant = $this->meetingtask->format_participant($this->zoomdata, 1, $names, $emails);
        $this->assertEmpty($participant['userid']);
    }

    /**
     * Tests that we can handle when the Zoom API sometimes returns invalid
     * userids in the report/meeting/participants call.
     */
    public function test_invalid_userids(): void {
        global $DB, $SITE;

        // Make sure we start with nothing.
        $this->assertEquals(0, $DB->count_records('zoom_meeting_details'));
        $this->assertEquals(0, $DB->count_records('zoom_meeting_participants'));
        $this->mockparticipantsdata = [];

        // First mock the webservice object, so we can inject the return values
        // for get_meeting_participants.
        $mockwwebservice = $this->createMock('\mod_zoom\webservice');

        // What we want get_meeting_participants to return.
        $participant1 = new stdClass();
        // Sometimes Zoom returns timestamps appended to user_ids.
        $participant1->id = '';
        $participant1->user_id = '02020-04-01 15:02:01:040';
        $participant1->name = 'John Smith';
        $participant1->user_email = 'john@test.com';
        $participant1->join_time = '2020-04-01T15:02:01Z';
        $participant1->leave_time = '2020-04-01T15:02:01Z';
        $participant1->duration = 0;
        $this->mockparticipantsdata['someuuid'][] = $participant1;
        // Have another participant with normal data.
        $participant2 = new stdClass();
        $participant2->id = '';
        $participant2->user_id = 123;
        $participant2->name = 'Jane Smith';
        $participant2->user_email = 'jane@test.com';
        $participant2->join_time = '2020-04-01T15:00:00Z';
        $participant2->leave_time = '2020-04-01T15:10:00Z';
        $participant2->duration = 10 * 60;
        $this->mockparticipantsdata['someuuid'][] = $participant2;

        // Make get_meeting_participants() return our results array.
        $mockwwebservice->method('get_meeting_participants')
            ->will($this->returnCallback([$this, 'mock_get_meeting_participants']));

        $this->assertEquals(
            $this->mockparticipantsdata['someuuid'],
            $mockwwebservice->get_meeting_participants('someuuid', false)
        );

        // Now fake the meeting details.
        $meeting = new stdClass();
        $meeting->id = 12345;
        $meeting->topic = 'Some meeting';
        $meeting->start_time = '2020-04-01T15:00:00Z';
        $meeting->end_time = '2020-04-01T16:00:00Z';
        $meeting->uuid = 'someuuid';
        $meeting->duration = 60 * 60;
        $meeting->participants = 3;

        // Insert stub data for zoom table.
        $DB->insert_record('zoom', [
            'course' => $SITE->id,
            'meeting_id' => $meeting->id,
            'name' => 'Zoom',
            'exists_on_zoom' => ZOOM_MEETING_EXISTS,
        ]);

        // Run task process_meeting_reports() and should insert participants.
        $this->meetingtask->service = $mockwwebservice;
        $meeting = $this->meetingtask->normalize_meeting($meeting);
        $this->assertTrue($this->meetingtask->process_meeting_reports($meeting));

        // Make sure that only one details is added and two participants.
        $this->assertEquals(1, $DB->count_records('zoom_meeting_details'));
        $this->assertEquals(2, $DB->count_records('zoom_meeting_participants'));

        // Add in one more participant, make sure we update details and added
        // one more participant.
        $participant3 = new stdClass();
        $participant3->id = 'someuseruuid';
        $participant3->user_id = 234;
        $participant3->name = 'Joe Smith';
        $participant3->user_email = 'joe@test.com';
        $participant3->join_time = '2020-04-01T15:05:00Z';
        $participant3->leave_time = '2020-04-01T15:35:00Z';
        $participant3->duration = 30 * 60;
        $this->mockparticipantsdata['someuuid'][] = $participant3;
        $this->assertTrue($this->meetingtask->process_meeting_reports($meeting));
        $this->assertEquals(1, $DB->count_records('zoom_meeting_details'));
        $this->assertEquals(3, $DB->count_records('zoom_meeting_participants'));
    }

    /**
     * Tests that normalize_meeting() can handle different meeting records from
     * Dashboard API versus the Report API.
     */
    public function test_normalize_meeting(): void {
        $dashboardmeeting = [
            'uuid' => 'sfsdfsdfc6122222d',
            'id' => 1000000,
            'topic' => 'Awesome meeting',
            'host' => 'John Doe',
            'email' => 'test@email.com',
            'user_type' => 2,
            'start_time' => '2019-07-14T09:05:19.754Z',
            'end_time' => '2019-07-14T10:26:37.754Z',
            'duration' => '01:21:18',
            'participants' => 4,
            'has_pstn' => false,
            'has_voip' => false,
            'has_3rd_party_audio' => false,
            'has_video' => false,
            'has_screen_share' => false,
            'has_recording' => false,
            'has_sip' => false,
        ];
        $meeting = $this->meetingtask->normalize_meeting((object) $dashboardmeeting);

        $this->assertEquals($dashboardmeeting['uuid'], $meeting->uuid);
        $this->assertFalse(isset($meeting->id));
        $this->assertEquals($dashboardmeeting['id'], $meeting->meeting_id);
        $this->assertEquals($dashboardmeeting['topic'], $meeting->topic);
        $this->assertIsInt($meeting->start_time);
        $this->assertIsInt($meeting->end_time);
        $this->assertEquals($meeting->duration, 1 * 3600 + 21 * 60 + 18);
        $this->assertEquals($dashboardmeeting['participants'], $meeting->participants_count);
        $this->assertNull($meeting->total_minutes);

        // Try duration under an hour.
        $dashboardmeeting['duration'] = '10:01';
        $meeting = $this->meetingtask->normalize_meeting((object) $dashboardmeeting);
        $this->assertEquals($meeting->duration, 10 * 60 + 1);

        $reportmeeting = [
            'uuid' => 'sfsdfsdfc6122222d',
            'id' => 1000000,
            'type' => 2,
            'topic' => 'Awesome meeting',
            'user_name' => 'John Doe',
            'user_email' => 'test@email.com',
            'start_time' => '2019-07-14T09:05:19.754Z',
            'end_time' => '2019-07-14T09:16:19.754Z',
            'duration' => 11 * 60,
            'total_minutes' => 11,
            'participants_count' => 4,
        ];

        $meeting = $this->meetingtask->normalize_meeting((object) $reportmeeting);

        $this->assertEquals($reportmeeting['uuid'], $meeting->uuid);
        $this->assertFalse(isset($meeting->id));
        $this->assertEquals($reportmeeting['id'], $meeting->meeting_id);
        $this->assertEquals($reportmeeting['topic'], $meeting->topic);
        $this->assertIsInt($meeting->start_time);
        $this->assertIsInt($meeting->end_time);
        $this->assertEquals($reportmeeting['participants_count'], $meeting->participants_count);
        $this->assertEquals($reportmeeting['total_minutes'], $meeting->total_minutes);
    }

    /**
     * Testing the grading method according to users duration in a meeting.
     * @return void
     */
    public function test_grading_method(): void {
        global $DB;
        $this->setAdminUser();
        // Make sure we start with nothing.
        // Deleting all records from previous tests.
        if ($DB->count_records('zoom_meeting_details') > 0) {
            $DB->delete_records('zoom_meeting_details');
        }

        if ($DB->count_records('zoom_meeting_participants') > 0) {
            $DB->delete_records('zoom_meeting_participants');
        }

        // Generate fake course.
        $course = $this->getDataGenerator()->create_course();
        $teacher = $this->getDataGenerator()->create_and_enrol($course, 'editingteacher');

        // Check that this teacher has the required capability to receive notification.
        $context = context_course::instance($course->id);
        $graders = get_users_by_capability($context, 'moodle/grade:edit');
        $this->assertEquals(1, count($graders));
        $firstkey = key($graders);
        $this->assertEquals($graders[$firstkey]->id, $teacher->id);
        // Now fake the meeting details.
        $meeting = new stdClass();
        $meeting->id = 456123;
        $meeting->topic = 'Some meeting';
        $meeting->start_time = '2020-04-01T15:00:00Z';
        $meeting->end_time = '2020-04-01T17:00:00Z';
        $meeting->uuid = 'someuuid123';
        $meeting->duration = 120 * 60; // In seconds.
        $meeting->participants = 4;

        // Create a new zoom instance.
        $params = [
            'course' => $course->id,
            'meeting_id' => $meeting->id,
            'grade' => 60,
            'name' => 'Zoom',
            'exists_on_zoom' => ZOOM_MEETING_EXISTS,
            'start_time' => strtotime('2020-04-01T15:00:00Z'),
            'duration' => 120 * 60, // In seconds.
        ];

        $generator = $this->getDataGenerator()->get_plugin_generator('mod_zoom');
        $instance = $generator->create_instance($params);
        $id = $instance->id;
        // Normalize the meeting.
        $meeting = $this->meetingtask->normalize_meeting($meeting);
        $meeting->zoomid = $id;

        $detailsid = $DB->insert_record('zoom_meeting_details', $meeting);

        $zoomrecord = $DB->get_record('zoom', ['id' => $id]);
        // Create users and corresponding meeting participants.
        $rawparticipants = [];
        $participants = [];
        // Enroll a bunch of users. Note: names were generated by
        // https://www.behindthename.com/random/ and any similarity to anyone
        // real or fictional is coincidence and not intentional.
        $users[0] = $this->getDataGenerator()->create_user([
            'lastname' => 'Arytis',
            'firstname' => 'Oitaa',
        ]);

        $users[1] = $this->getDataGenerator()->create_user([
            'lastname' => 'Chouxuong',
            'firstname' => 'Khah',
        ]);
        $users[2] = $this->getDataGenerator()->create_user([
            'lastname' => 'Spialdiouniem',
            'firstname' => 'Basem',
        ]);
        $users[3] = $this->getDataGenerator()->create_user([
            'lastname' => 'Padhzinnuj',
            'firstname' => 'Nibba',
        ]);
        $users[4] = $this->getDataGenerator()->create_user([
            'lastname' => 'Apea',
            'firstname' => 'Ziqit',
        ]);

        foreach ($users as $user) {
            $this->getDataGenerator()->enrol_user($user->id, $course->id);
        }
        [$names, $emails] = $this->meetingtask->get_enrollments($course->id);

        // Create a participant with 5 min overlap.
        // Total time 35 min, total grade 17.5 .
        $rawparticipants[1] = (object) [
            'id' => 32132165,
            'user_id' => 4456,
            'name' => 'Oitaa Arytis',
            'user_email' => '',
            'join_time' => '2023-05-01T15:05:00Z',
            'leave_time' => '2023-05-01T15:35:00Z',
            'duration' => 30 * 60,
        ];
        $participants[1] = (object) $this->meetingtask->format_participant($rawparticipants[1], $detailsid, $names, $emails);
        $rawparticipants[2] = (object) [
            'id' => 32132165,
            'user_id' => 4456,
            'name' => 'Oitaa Arytis',
            'user_email' => '',
            'join_time' => '2023-05-01T15:30:00Z',
            'leave_time' => '2023-05-01T15:40:00Z',
            'duration' => 10 * 60,
        ];
        $participants[2] = (object) $this->meetingtask->format_participant($rawparticipants[2], $detailsid, $names, $emails);
        $overlap = $this->meetingtask->get_participant_overlap_time($participants[1], $participants[2]);
        $this->assertEquals(5 * 60, $overlap);
        // Also check for the same result if the data inverted.
        $overlap = $this->meetingtask->get_participant_overlap_time($participants[2], $participants[1]);
        $this->assertEquals(5 * 60, $overlap);

        // Create a participant with 30 min overlap.
        // Total duration 60 min. expect a mark of 30 .
        $rawparticipants[3] = (object) [
            'id' => '',
            'user_id' => 1234,
            'name' => 'Chouxuong Khah',
            'user_email' => '',
            'join_time' => '2023-05-01T15:00:00Z',
            'leave_time' => '2023-05-01T16:00:00Z',
            'duration' => 60 * 60,
        ];
        $participants[3] = (object) $this->meetingtask->format_participant($rawparticipants[3], $detailsid, $names, $emails);
        $rawparticipants[4] = (object) [
            'id' => '',
            'user_id' => 1234,
            'name' => 'Chouxuong Khah',
            'user_email' => '',
            'join_time' => '2023-05-01T15:30:00Z',
            'leave_time' => '2023-05-01T16:00:00Z',
            'duration' => 30 * 60,
        ];
        $participants[4] = (object) $this->meetingtask->format_participant($rawparticipants[4], $detailsid, $names, $emails);
        $overlap = $this->meetingtask->get_participant_overlap_time($participants[3], $participants[4]);
        $this->assertEquals(30 * 60, $overlap);
        // Also check for the same result if the data inverted.
        $overlap = $this->meetingtask->get_participant_overlap_time($participants[4], $participants[3]);
        $this->assertEquals(30 * 60, $overlap);

        // Another user with no overlaping.
        // Total duration 60 min. Expect mark 30 .
        $rawparticipants[5] = (object) [
            'id' => '',
            'user_id' => 564312,
            'name' => 'Spialdiouniem Basem',
            'user_email' => '',
            'join_time' => '2023-05-01T15:10:00Z',
            'leave_time' => '2023-05-01T16:00:00Z',
            'duration' => 50 * 60,
        ];
        $participants[5] = (object) $this->meetingtask->format_participant($rawparticipants[5], $detailsid, $names, $emails);
        $rawparticipants[6] = (object) [
            'id' => '',
            'user_id' => 564312,
            'name' => 'Spialdiouniem Basem',
            'user_email' => '',
            'join_time' => '2023-05-01T16:30:00Z',
            'leave_time' => '2023-05-01T16:40:00Z',
            'duration' => 10 * 60,
        ];
        $participants[6] = (object) $this->meetingtask->format_participant($rawparticipants[6], $detailsid, $names, $emails);

        $overlap = $this->meetingtask->get_participant_overlap_time($participants[5], $participants[6]);
        $this->assertEquals(0, $overlap);
        // Also check for the same result if the data inverted.
        $overlap = $this->meetingtask->get_participant_overlap_time($participants[6], $participants[5]);
        $this->assertEquals(0, $overlap);

        // Adding another participant.
        // Total duration 90 min, expect mark 45 .
        $rawparticipants[7] = (object) [
            'id' => '',
            'user_id' => 789453,
            'name' => 'Padhzinnuj Nibba',
            'user_email' => '',
            'join_time' => '2023-05-01T15:30:00Z',
            'leave_time' => '2023-05-01T17:00:00Z',
            'duration' => 90 * 60,
        ];

        // Adding a participant at which matching names will fail.
        // His duration is 110 min, this grant him a grade of 55.
        $rawparticipants[8] = (object) [
            'id' => '',
            'user_id' => 168452,
            'name' => 'Farouk',
            'user_email' => '',
            'join_time' => '2023-05-01T15:10:00Z',
            'leave_time' => '2023-05-01T17:00:00Z',
            'duration' => 110 * 60,
        ];
        $this->mockparticipantsdata['someuuid123'] = $rawparticipants;
        // First mock the webservice object, so we can inject the return values
        // for get_meeting_participants.
        $mockwwebservice = $this->createMock('\mod_zoom\webservice');
        $this->meetingtask->service = $mockwwebservice;
        // Make get_meeting_participants() return our results array.
        $mockwwebservice->method('get_meeting_participants')
            ->will($this->returnCallback([$this, 'mock_get_meeting_participants']));

        $this->assertEquals(
            $this->mockparticipantsdata['someuuid123'],
            $mockwwebservice->get_meeting_participants('someuuid123', false)
        );

        // Now let's test the grades.
        $DB->set_field('zoom', 'grading_method', 'period', ['id' => $zoomrecord->id]);

        // Prepare messages.
        $this->preventResetByRollback(); // Messaging does not like transactions...
        $sink = $this->redirectMessages();
        // Process meeting reports should call the function grading_participant_upon_duration
        // and insert grades.
        $this->assertTrue($this->meetingtask->process_meeting_reports($meeting));
        $this->assertEquals(1, $DB->count_records('zoom_meeting_details'));
        $this->assertEquals(8, $DB->count_records('zoom_meeting_participants'));

        $usersids = [];
        foreach ($users as $user) {
            $usersids[] = $user->id;
        }
        // Get the gradelist for all users created.
        $gradelist = grade_get_grades($course->id, 'mod', 'zoom', $zoomrecord->id, $usersids);

        $gradelistitems = $gradelist->items;
        $grades = $gradelistitems[0]->grades;
        // Check grades of first user.
        $grade = $grades[$users[0]->id]->grade;
        $this->assertEquals(17.5, $grade);
        // Check grades of second user.
        $grade = $grades[$users[1]->id]->grade;
        $this->assertEquals(30, $grade);
        // Check grades of third user.
        $grade = $grades[$users[2]->id]->grade;
        $this->assertEquals(30, $grade);
        // Check grades for fourth user.
        $grade = $grades[$users[3]->id]->grade;
        $this->assertEquals(45, $grade);
        // This user didn't enter the meeting.
        $grade = $grades[$users[4]->id]->grade;
        $this->assertEquals(null, $grade);
        // Let's check the teacher notification if it is ok?
        $messages = $sink->get_messages();
        // Only one teacher, means only one message.
        $this->assertEquals(1, count($messages));
        // Verify that it has been sent to the teacher.
        $this->assertEquals($teacher->id, $messages[0]->useridto);
        // Check the content of the message.
        // Grading item url.
        $gurl = new moodle_url(
            '/grade/report/singleview/index.php',
            [
                'id' => $course->id,
                'item' => 'grade',
                'itemid' => $gradelistitems[0]->id,
            ]
        );
        $gradeurl = html_writer::link($gurl, get_string('gradinglink', 'mod_zoom'));

        // Zoom instance url.
        $zurl = new moodle_url('/mod/zoom/view.php', ['id' => $id]);
        $zoomurl = html_writer::link($zurl, $zoomrecord->name);
        // The user need grading.
        $needgradestr = get_string('grading_needgrade', 'mod_zoom');
        $needgrade[] = '(Name: Farouk, grade: 55)';
        $needgrade = $needgradestr . implode('<br>', $needgrade) . "\n";

        $a = (object) [
            'name' => $zoomrecord->name,
            'graded' => 4,
            'alreadygraded' => 0,
            'needgrade' => $needgrade,
            'number' => 1,
            'gradeurl' => $gradeurl,
            'zoomurl' => $zoomurl,
            'notfound' => '',
            'notenrolled' => '',
        ];
        $messagecontent = get_string('gradingmessagebody', 'mod_zoom', $a);
        $this->assertStringContainsString($messagecontent, $messages[0]->fullmessage);

        // Redo the process again to be sure that no grades have been changed.
        $this->assertTrue($this->meetingtask->process_meeting_reports($meeting));
        $this->assertEquals(1, $DB->count_records('zoom_meeting_details'));
        $this->assertEquals(8, $DB->count_records('zoom_meeting_participants'));
        $gradelist = grade_get_grades($course->id, 'mod', 'zoom', $zoomrecord->id, $usersids);
        $gradelistitems = $gradelist->items;
        $grades = $gradelistitems[0]->grades;
        // Check grade for first user.
        $grade = $grades[$users[0]->id]->grade;
        $this->assertEquals(17.5, $grade);
        // Check grade for second user.
        $grade = $grades[$users[1]->id]->grade;
        $this->assertEquals(30, $grade);
        // Check grade for third user.
        $grade = $grades[$users[2]->id]->grade;
        $this->assertEquals(30, $grade);
        // Check grade for fourth user.
        $grade = $grades[$users[3]->id]->grade;
        $this->assertEquals(45, $grade);
        // This user didn't enter the meeting.
        $grade = $grades[$users[4]->id]->grade;
        $this->assertEquals(null, $grade);

        // Let's check if the teacher notification is ok.
        $messages = $sink->get_messages();
        // No new messages as there has not been an update for participants.
        $this->assertEquals(1, count($messages));
    }
}

====================

file: mod_zoom_grade_test.php
path: tests/mod_zoom_grade_test.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Unit tests for supporting advanced password requirements in Zoom.
 *
 * @package    mod_zoom
 * @copyright  2020 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

use advanced_testcase;

/**
 * PHPunit testcase class.
 */
final class mod_zoom_grade_test extends advanced_testcase {
    /**
     * @var \stdClass Course record.
     */
    private $course;

    /**
     * @var \stdClass User record for teacher.
     */
    private $teacher;

    /**
     * @var \stdClass User record for student.
     */
    private $student;

    /**
     * @var \mod_zoom_generator Plugin generator for tests.
     */
    private $generator;

    /**
     * Setup to ensure that fixtures are loaded.
     */
    public static function setUpBeforeClass(): void {
        global $CFG;
        require_once($CFG->dirroot . '/mod/zoom/lib.php');
        require_once($CFG->dirroot . '/mod/zoom/locallib.php');
        parent::setUpBeforeClass();
    }

    /**
     * Setup before every test.
     */
    public function setUp(): void {
        parent::setUp();
        $this->resetAfterTest();
        $this->setAdminUser();

        $this->course = $this->getDataGenerator()->create_course();
        $this->teacher = $this->getDataGenerator()->create_and_enrol($this->course, 'teacher');
        $this->student = $this->getDataGenerator()->create_and_enrol($this->course, 'student');
        $this->generator = $this->getDataGenerator()->get_plugin_generator('mod_zoom');
    }

    /**
     * Tests that Zoom grades can be added and updated in the gradebook.
     * @covers ::zoom_grade_item_update
     */
    public function test_grade_added(): void {
        $params['course'] = $this->course->id;
        $params['grade'] = 100;

        $instance = $this->generator->create_instance($params);
        $gradebook = grade_get_grades($this->course->id, 'mod', 'zoom', $instance->id);

        // Gradebook should be empty.
        $this->assertEquals(0, count($gradebook->items[0]->grades));

        // Insert grade for student.
        $studentgrade = ['userid' => $this->student->id, 'rawgrade' => 50];
        zoom_grade_item_update($instance, $studentgrade);

        // Gradebook should contain a grade for student.
        $gradebook = grade_get_grades($this->course->id, 'mod', 'zoom', $instance->id, $this->student->id);
        $this->assertEquals(1, count($gradebook->items[0]->grades));
        $this->assertEquals(50, $gradebook->items[0]->grades[$this->student->id]->grade);

        // Update grade for student.
        $studentgrade = ['userid' => $this->student->id, 'rawgrade' => 75];
        zoom_grade_item_update($instance, $studentgrade);
        $gradebook = grade_get_grades($this->course->id, 'mod', 'zoom', $instance->id, $this->student->id);

        // Verify grade has been updated.
        $this->assertEquals(1, count($gradebook->items[0]->grades));
        $this->assertEquals(75, $gradebook->items[0]->grades[$this->student->id]->grade);
    }

    /**
     * Tests that the Zoom grade type cannot be changed to NONE if grades are already inputted.
     * @covers ::zoom_grade_item_update
     */
    public function test_grade_type_not_none(): void {
        $params['course'] = $this->course->id;
        $params['grade'] = 100;

        $instance = $this->generator->create_instance($params);
        $gradebook = grade_get_grades($this->course->id, 'mod', 'zoom', $instance->id);

        // Gradebook should be empty.
        $this->assertEquals(0, count($gradebook->items[0]->grades));

        // Insert grade for student.
        $studentgrade = ['userid' => $this->student->id, 'rawgrade' => 100];
        zoom_grade_item_update($instance, $studentgrade);

        // Gradebook should contain a grade for student.
        $gradebook = grade_get_grades($this->course->id, 'mod', 'zoom', $instance->id, $this->student->id);
        $this->assertEquals(1, count($gradebook->items[0]->grades));

        // Try to change grade type to NONE.
        $instance->grade = 0;
        zoom_grade_item_update($instance);
        $gradebook = grade_get_grades($this->course->id, 'mod', 'zoom', $instance->id);

        // Verify grade type is not changed.
        $this->assertEquals(100, $gradebook->items[0]->grademax);
    }

    /**
     * Tests that the Zoom grades can be deleted.
     * @covers ::zoom_grade_item_delete
     */
    public function test_grade_delete(): void {
        $params['course'] = $this->course->id;
        $params['grade'] = 100;

        $instance = $this->generator->create_instance($params);
        $gradebook = grade_get_grades($this->course->id, 'mod', 'zoom', $instance->id);

        // Gradebook should be empty.
        $this->assertEquals(0, count($gradebook->items[0]->grades));

        // Insert grade for student.
        $studentgrade = ['userid' => $this->student->id, 'rawgrade' => 100];
        zoom_grade_item_update($instance, $studentgrade);

        // Gradebook should contain a grade for student.
        $gradebook = grade_get_grades($this->course->id, 'mod', 'zoom', $instance->id, $this->student->id);
        $this->assertEquals(1, count($gradebook->items[0]->grades));

        // Delete the grade items.
        zoom_grade_item_delete($instance);
        $gradebook = grade_get_grades($this->course->id, 'mod', 'zoom', $instance->id);

        // Verify gradebook is empty.
        $this->assertEmpty($gradebook->items);
    }
}

====================

file: mod_zoom_provider_test.php
path: tests/privacy/mod_zoom_provider_test.php
codice:
<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

namespace mod_zoom\privacy;

use context_module;
use core_privacy\local\metadata\collection;
use core_privacy\local\request\approved_contextlist;
use core_privacy\local\request\approved_userlist;
use core_privacy\local\request\deletion_criteria;
use core_privacy\local\request\userlist;
use core_privacy\local\request\writer;
use core_privacy\tests\provider_testcase;
use mod_zoom\privacy\provider;

/**
 * Privacy provider tests class.
 *
 * @package    mod_zoom
 * @copyright  2022 Catalyst IT Australia Pty Ltd
 * @author     2022 Ghaly Marc-Alexandre <marc-alexandreghaly@catalyst-ca.net>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 * @coversDefaultClass \mod_zoom\privacy\provider
 */
final class mod_zoom_provider_test extends provider_testcase {
    /** @var object The zoom instance object. */
    protected $zoominstance;

    /** @var object The course object. */
    protected $course;

    /** @var object The student object. */
    protected $student;

    /** @var object The second student object. */
    protected $student2;

    /** @var object The course module object.*/
    protected $cm;

    /**
     * {@inheritdoc}
     */
    protected function setUp(): void {
        parent::setUp();
        $this->resetAfterTest();
        $this->setAdminUser();

        global $DB;
        $generator = $this->getDataGenerator();
        $course = $generator->create_course();
        $params = [
            'course' => $course->id,
            'name' => 'First Zoom Activity',
            'showpreview' => 0,
        ];

        $plugingenerator = $generator->get_plugin_generator('mod_zoom');
        // The zoom activity.
        $zoom = $plugingenerator->create_instance($params);
        // Create a student enrolled in zoom activity.
        $student = $generator->create_user();
        $student2 = $generator->create_user();
        $studentrole = $DB->get_record('role', ['shortname' => 'student']);
        $generator->enrol_user($student->id, $course->id, $studentrole->id);
        $generator->enrol_user($student2->id, $course->id, $studentrole->id);
        // Fill all related data tables.
        $meeting = (object) [
            'id' => 12345,
            'meeting_id' => 12345,
            'topic' => 'Some meeting',
            'start_time' => 1646769060,
            'end_time' => 1646715600,
            'uuid' => 'someuuid',
            'duration' => 60,
            'participants' => 3,
            'zoomid' => $zoom->id,
        ];

        $zmid = $DB->insert_record('zoom_meeting_details', $meeting, true);
        $participant = (object) [
            'zoomuserid' => 9999,
            'userid' => $student->id,
            'join_time' => 1646769061,
            'leave_time' => 1646769062,
            'duration' => 60,
            'name' => 'Michell',
            'detailsid' => $zmid,
        ];
        $participant2 = (object) [
            'zoomuserid' => 9999,
            'userid' => $student2->id,
            'join_time' => 1646769061,
            'leave_time' => 1646769062,
            'duration' => 60,
            'name' => 'John',
            'detailsid' => $zmid,
        ];
        $zmparticipantsid = $DB->insert_record('zoom_meeting_participants', $participant, true);
        $zmparticipantsid2 = $DB->insert_record('zoom_meeting_participants', $participant2, true);
        $meetingrecording = (object) [
            'zoomid' => $zoom->id,
            'meetinguuid' => 'meetinguuid',
            'zoomrecordingid' => 'zoomrecordingid',
            'name' => 'a zoom recording name',
            'externalurl' => 'www.dummyurl.com',
            'recordingtype' => 'recordingtype',
            'recordingstart' => 1646769061,
            'showrecording' => 1,
        ];
        $meetingrecordingid = $DB->insert_record('zoom_meeting_recordings', $meetingrecording, true);
        $meetingrecordingsview = (object) [
            'recordingsid' => $meetingrecordingid,
            'userid' => $student->id,
            'viewed' => 1,
        ];
        $meetingrecordingsview2 = (object) [
            'recordingsid' => $meetingrecordingid,
            'userid' => $student2->id,
            'viewed' => 1,
        ];
        $DB->insert_record('zoom_meeting_recordings_view', $meetingrecordingsview, true);
        $DB->insert_record('zoom_meeting_recordings_view', $meetingrecordingsview2, true);

        $cm = get_coursemodule_from_instance('zoom', $zoom->id);

        $this->zoominstance = $zoom;
        $this->course = $course;
        $this->student = $student;
        $this->student2 = $student2;
        $this->cm = $cm;
    }

    /**
     * Test for provider::get_metadata().
     * @covers ::get_metadata
     */
    public function test_get_metadata(): void {
        $collection = new collection('mod_zoom');
        $newcollection = provider::get_metadata($collection);
        $itemcollection = $newcollection->get_collection();

        $this->assertCount(4, $itemcollection);
        $table = reset($itemcollection);
        $table2 = $itemcollection[1];
        $table3 = $itemcollection[2];
        $table4 = $itemcollection[3];
        $this->assertEquals('zoom_meeting_participants', $table->get_name());
        $this->assertEquals('zoom_meeting_details', $table2->get_name());
        $this->assertEquals('zoom_meeting_recordings_view', $table3->get_name());
        $this->assertEquals('zoom_breakout_participants', $table4->get_name());

        $privacyfields1 = $table->get_privacy_fields();
        $this->assertArrayHasKey('name', $privacyfields1);
        $this->assertArrayHasKey('user_email', $privacyfields1);
        $this->assertArrayHasKey('join_time', $privacyfields1);
        $this->assertArrayHasKey('leave_time', $privacyfields1);
        $this->assertArrayHasKey('duration', $privacyfields1);

        $this->assertEquals('privacy:metadata:zoom_meeting_participants', $table->get_summary());

        $privacyfields2 = $table2->get_privacy_fields();
        $this->assertArrayHasKey('topic', $privacyfields2);

        $this->assertEquals('privacy:metadata:zoom_meeting_details', $table2->get_summary());

        $privacyfields3 = $table3->get_privacy_fields();
        $this->assertArrayHasKey('userid', $privacyfields3);

        $this->assertEquals('privacy:metadata:zoom_meeting_view', $table3->get_summary());

        $privacyfields4 = $table4->get_privacy_fields();
        $this->assertArrayHasKey('userid', $privacyfields4);

        $this->assertEquals('privacy:metadata:zoom_breakout_participants', $table4->get_summary());
    }

    /**
     * Test for provider::get_contexts_for_userid().
     * @covers ::get_contexts_for_userid
     */
    public function test_get_contexts_for_userid(): void {
        $contextlist = provider::get_contexts_for_userid($this->student->id);
        $this->assertCount(1, $contextlist);
        $contextforuser = $contextlist->current();
        $cmcontext = context_module::instance($this->cm->id);
        $this->assertEquals($cmcontext->id, $contextforuser->id);

        $contextlist2 = provider::get_contexts_for_userid($this->student2->id);
        $this->assertCount(1, $contextlist2);
        $contextforuser2 = $contextlist2->current();
        $cmcontext2 = context_module::instance($this->cm->id);
        $this->assertEquals($cmcontext2->id, $contextforuser2->id);
    }

    /**
     * Test for provider::get_users_in_context().
     * @covers ::get_users_in_context
     */
    public function test_get_users_in_context(): void {
        $cmcontext = context_module::instance($this->cm->id);

        $userlist = new userlist($cmcontext, 'mod_zoom');
        provider::get_users_in_context($userlist);

        $this->assertEquals([$this->student->id, $this->student2->id], $userlist->get_userids());
    }

    /**
     * Test for provider::export_user_data().
     * @covers ::export_user_data
     */
    public function test_export_user_data(): void {
        $cmcontext = context_module::instance($this->cm->id);

        // Export all of the data for the context.
        $this->export_context_data_for_user($this->student->id, $cmcontext, 'mod_zoom');
        $writer = writer::with_context($cmcontext);
        $this->assertTrue($writer->has_any_data());
    }

    /**
     * Test for provider::delete_data_for_all_users_in_context().
     * @covers ::delete_data_for_all_users_in_context
     */
    public function test_delete_data_for_all_users_in_context(): void {
        global $DB;

        $zoommeetingcount = $DB->count_records('zoom_meeting_details');
        $this->assertEquals(1, $zoommeetingcount);

        $zmparticipants = $DB->count_records('zoom_meeting_participants');
        $this->assertEquals(2, $zmparticipants);

        $zmrecordingcount = $DB->count_records('zoom_meeting_recordings');
        $this->assertEquals(1, $zmrecordingcount);

        $zmrecordingviewcount = $DB->count_records('zoom_meeting_recordings_view');
        $this->assertEquals(2, $zmrecordingviewcount);

        // Delete data based on context.
        $cmcontext = context_module::instance($this->cm->id);
        provider::delete_data_for_all_users_in_context($cmcontext);

        $newzoommeetingcount = $DB->count_records('zoom_meeting_details');
        $this->assertEquals(0, $newzoommeetingcount);

        $newzmparticipants = $DB->count_records('zoom_meeting_participants');
        $this->assertEquals(0, $newzmparticipants);

        $newzmrecordingcount = $DB->count_records('zoom_meeting_recordings');
        $this->assertEquals(0, $newzmrecordingcount);

        $newzmrecordingviewcount = $DB->count_records('zoom_meeting_recordings_view');
        $this->assertEquals(0, $newzmrecordingviewcount);
    }

    /**
     * Test for provider::delete_data_for_user().
     * @covers ::delete_data_for_user
     */
    public function test_delete_data_for_user(): void {
        global $DB;

        $zmparticipants = $DB->count_records('zoom_meeting_participants');
        $this->assertEquals(2, $zmparticipants);

        $zmrecordingviewcount = $DB->count_records('zoom_meeting_recordings_view');
        $this->assertEquals(2, $zmrecordingviewcount);
        // Delete data based on specific context.
        $context = context_module::instance($this->cm->id);
        $contextlist = new approved_contextlist($this->student, 'mod_zoom', [$context->id]);

        provider::delete_data_for_user($contextlist);

        $newzmparticipants = $DB->count_records('zoom_meeting_participants');
        $this->assertEquals(1, $newzmparticipants);

        $newzmrecordingviewcount = $DB->count_records('zoom_meeting_recordings_view');
        $this->assertEquals(1, $newzmrecordingviewcount);
    }

    /**
     * Test for provider::delete_data_for_users().
     * @covers ::delete_data_for_users
     */
    public function test_delete_data_for_users(): void {
        global $DB;

        $zmparticipants = $DB->count_records('zoom_meeting_participants');
        $this->assertEquals(2, $zmparticipants);

        $zmrecordingviewcount = $DB->count_records('zoom_meeting_recordings_view');
        $this->assertEquals(2, $zmrecordingviewcount);
        // Delete data based on specific context.
        $context = context_module::instance($this->cm->id);
        $approveduserlist = new approved_userlist(
            $context,
            'zoom',
            [$this->student->id, $this->student2->id]
        );
        provider::delete_data_for_users($approveduserlist);

        $newzmparticipants = $DB->count_records('zoom_meeting_participants');
        $this->assertEquals(0, $newzmparticipants);

        $newzmrecordingviewcount = $DB->count_records('zoom_meeting_recordings_view');
        $this->assertEquals(0, $newzmrecordingviewcount);
    }
}

====================

file: lib.php
path: tests/generator/lib.php
codice:
<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Zoom module test data generator class
 *
 * @package mod_zoom
 * @copyright 2020 UC Regents
 * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class mod_zoom_generator extends testing_module_generator {
    /**
     * Creates new Zoom module instance.
     * @param array|stdClass $record
     * @param array|null $options
     * @return stdClass Zoom instance
     */
    public function create_instance($record = null, ?array $options = null) {
        global $CFG;
        require_once($CFG->dirroot . '/mod/zoom/locallib.php');

        set_config('clientid', 'test', 'zoom');
        set_config('clientsecret', 'test', 'zoom');
        set_config('accountid', 'test', 'zoom');

        // Mock Zoom data for testing.
        $defaultzoomsettings = [
            'grade' => 0,
            'name' => 'Test Zoom Meeting',
            'meeting_id' => 1,
            'host_id' => 'test',
            'meetingcode' => '',
            'webinar' => 0,
            'option_host_video' => 0,
            'option_audio' => 0,
            'recurring' => 0,
            'option_participants_video' => 0,
            'option_jbh' => 0,
            'option_waiting_room' => 0,
            'option_mute_upon_entry' => 0,
            'start_time' => mktime(0, 0, 0, 2, 22, 2021),
            'duration' => 60,
            'exists_on_zoom' => ZOOM_MEETING_EXPIRED,
        ];

        $record = (object) (array) $record;
        foreach ($defaultzoomsettings as $name => $value) {
            if (!isset($record->{$name})) {
                $record->{$name} = $value;
            }
        }

        return parent::create_instance($record, $options);
    }
}

====================

file: mod_zoom_webservice_test.php
path: tests/mod_zoom_webservice_test.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Unit tests for get_meeting_reports task class.
 *
 * @package    mod_zoom
 * @copyright  2019 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

use advanced_testcase;

/**
 * PHPunit testcase class.
 * @covers \mod_zoom\webservice
 */
final class mod_zoom_webservice_test extends advanced_testcase {
    /**
     * @var object Anonymous class to mock \curl.
     */
    private $notfoundmockcurl;

    /**
     * Setup to ensure that fixtures are loaded.
     */
    public static function setUpBeforeClass(): void {
        global $CFG;
        require_once($CFG->dirroot . '/mod/zoom/locallib.php');
        parent::setUpBeforeClass();
    }

    /**
     * Get mock webservice object.
     *
     * @param array $mockmethods Array of method => return value methods.
     */
    public function get_mock_webservice($mockmethods) {
        $mockmethods += [
            'get_access_token' => 'token123',
        ];

        $mockbuilder = $this->getMockBuilder(webservice::class);

        if (method_exists($mockbuilder, 'onlyMethods')) {
            $mockbuilder->onlyMethods(array_keys($mockmethods));
        } else {
            $mockbuilder->setMethods(array_keys($mockmethods));
        }

        $mockservice = $mockbuilder->getMock();

        foreach ($mockmethods as $method => $willreturn) {
            $mockservice->expects($this->any())
                ->method($method)
                ->willReturn($willreturn);
        }

        return $mockservice;
    }

    /**
     * Setup before every test.
     */
    public function setUp(): void {
        parent::setUp();
        $this->resetAfterTest();
        // Set fake values so we can test methods in class.
        set_config('clientid', 'test', 'zoom');
        set_config('clientsecret', 'test', 'zoom');
        set_config('accountid', 'test', 'zoom');

        $this->notfoundmockcurl = new class {
            // phpcs:disable moodle.NamingConventions.ValidFunctionName.LowercaseMethod
            /**
             * Stub for curl setHeader().
             * @param string $unusedparam
             * @return void
             */
            public function setHeader($unusedparam) {
                // phpcs:enable
                return;
            }
            /**
             * Stub for curl get_errno().
             * @return boolean
             */
            public function get_errno() {
                return false;
            }
            /**
             * Returns 404 error code.
             * @return array
             */
            public function get_info() {
                return ['http_code' => 404];
            }
        };
    }

    /**
     * Tests that uuid are encoded properly for use in web service calls.
     */
    public function test_encode_uuid(): void {
        $service = zoom_webservice();

        // If uuid includes / or // it needs to be double encoded.
        $uuid = $service->encode_uuid('/u2F0gUNSqqC7DT+08xKrw==');
        $this->assertEquals('%252Fu2F0gUNSqqC7DT%252B08xKrw%253D%253D', $uuid);

        $uuid = $service->encode_uuid('Ahqu+zVcQpO//RcAUUWkNA==');
        $this->assertEquals('Ahqu%252BzVcQpO%252F%252FRcAUUWkNA%253D%253D', $uuid);

        // If not, then it can be used as is.
        $uuid = $service->encode_uuid('M8TigfzxRTKJmhXnV7bNjw==');
        $this->assertEquals('M8TigfzxRTKJmhXnV7bNjw==', $uuid);
    }

    /**
     * Tests whether the meeting not found errors are properly parsed.
     */
    public function test_meeting_not_found_exception(): void {
        $methods = [
            'make_curl_call' => '{"code":3001,"message":"runion introuvable"}',
            'get_curl_object' => $this->notfoundmockcurl,
        ];
        $mockservice = $this->get_mock_webservice($methods);

        $foundexception = false;
        try {
            $response = $mockservice->get_meeting_webinar_info('-1', false);
        } catch (webservice_exception $error) {
            $this->assertEquals(3001, $error->zoomerrorcode);
            $this->assertTrue(zoom_is_meeting_gone_error($error));
            $foundexception = true;
        }

        $this->assertTrue($foundexception);
    }

    /**
     * Tests whether user not found errors are properly parsed.
     */
    public function test_user_not_found_exception(): void {
        $methods = [
            'make_curl_call' => '{"code":1001,"message":"nexiste pas ou nappartient pas  ce compte"}',
            'get_curl_object' => $this->notfoundmockcurl,
        ];
        $mockservice = $this->get_mock_webservice($methods);

        $foundexception = false;
        try {
            $founduser = $mockservice->get_user('-1');
        } catch (webservice_exception $error) {
            $this->assertEquals(1001, $error->zoomerrorcode);
            $this->assertTrue(zoom_is_meeting_gone_error($error));
            $this->assertTrue(zoom_is_user_not_found_error($error));
            $foundexception = true;
        }

        $this->assertTrue($foundexception || !$founduser);
    }

    /**
     * Tests whether invalid user errors are parsed properly
     */
    public function test_invalid_user_exception(): void {
        $invalidmockcurl = new class {
            // phpcs:disable moodle.NamingConventions.ValidFunctionName.LowercaseMethod
            /**
             * Stub for curl setHeader().
             * @param string $unusedparam
             * @return void
             */
            public function setHeader($unusedparam) {
                // phpcs:enable
                return;
            }
            /**
             * Stub for curl get_errno().
             * @return boolean
             */
            public function get_errno() {
                return false;
            }
            /**
             * Returns 400 error code.
             * @return array
             */
            public function get_info() {
                return ['http_code' => 400];
            }
        };

        $methods = [
            'make_curl_call' => '{"code":1120,"message":"utilisateur invalide"}',
            'get_curl_object' => $invalidmockcurl,
        ];
        $mockservice = $this->get_mock_webservice($methods);

        $foundexception = false;
        try {
            $founduser = $mockservice->get_user('-1');
        } catch (webservice_exception $error) {
            $this->assertEquals(1120, $error->zoomerrorcode);
            $this->assertTrue(zoom_is_meeting_gone_error($error));
            $this->assertTrue(zoom_is_user_not_found_error($error));
            $foundexception = true;
        }

        $this->assertTrue($foundexception || !$founduser);
    }

    /**
     * Tests whether the retry on a 429 works properly when the Retry-After header
     * is in the curl response to specify the time that the retry should be sent.
     */
    public function test_retry_with_header(): void {
        $retrywithheadermockcurl = new class {
            /**
             * @var int Number of calls.
             */
            public $numgetinfocalls = 0;
            // phpcs:disable moodle.NamingConventions.ValidFunctionName.LowercaseMethod
            /**
             * Stub for curl setHeader().
             * @param string $unusedparam
             * @return void
             */
            public function setHeader($unusedparam) {
                // phpcs:enable
                return;
            }
            /**
             * Stub for curl get_errno().
             * @return boolean
             */
            public function get_errno() {
                return false;
            }
            /**
             * Returns 429 for first 3 calls, then 200.
             * @return array
             */
            public function get_info() {
                $this->numgetinfocalls++;
                if ($this->numgetinfocalls <= 3) {
                    return ['http_code' => 429];
                }

                return ['http_code' => 200];
            }
            // phpcs:disable moodle.NamingConventions.ValidFunctionName.LowercaseMethod
            /**
             * Returns retry to be 1 second later.
             * @return array
             */
            public function getResponse() {
                // phpcs:enable
                // Set retry time to be 1 second. Format is 2020-05-31T00:00:00Z.
                $retrytime = time() + 1;
                return [
                    'X-RateLimit-Type' => 'Daily',
                    'X-RateLimit-Remaining' => 100,
                    'Retry-After' => gmdate('Y-m-d\TH:i:s\Z', $retrytime),
                ];
            }
        };

        // Class retrywithheadermockcurl will give 429 retry error 3 times
        // before giving a 200.
        $methods = [
            'make_curl_call' => '{"response":"success", "message": "", "code": 200}',
            'get_curl_object' => $retrywithheadermockcurl,
        ];
        $mockservice = $this->get_mock_webservice($methods);

        $result = $mockservice->get_user("1");
        // Expect 3 debugging calls for each retry attempt.
        $this->assertDebuggingCalledCount($expectedcount = 3);
        // Expect 3 calls to get_info() for the retries and 1 for success.
        $this->assertEquals($retrywithheadermockcurl->numgetinfocalls, 4);
        $this->assertEquals($result->response, 'success');
    }

    /**
     * Tests whether the retry on a 429 response works when the Retry-After
     * header is not sent in the curl response.
     */
    public function test_retry_without_header(): void {
        $retrynoheadermockcurl = new class {
            /**
             * @var int Number of calls.
             */
            public $numgetinfocalls = 0;
            // phpcs:disable moodle.NamingConventions.ValidFunctionName.LowercaseMethod
            /**
             * Stub for curl setHeader().
             * @param string $unusedparam
             * @return void
             */
            public function setHeader($unusedparam) {
                // phpcs:enable
                return;
            }
            /**
             * Stub for curl get_errno().
             * @return boolean
             */
            public function get_errno() {
                return false;
            }
            /**
             * Returns 429 for first 3 calls, then 200.
             * @return array
             */
            public function get_info() {
                $this->numgetinfocalls++;
                if ($this->numgetinfocalls <= 3) {
                    return ['http_code' => 429];
                }

                return ['http_code' => 200];
            }
            // phpcs:disable moodle.NamingConventions.ValidFunctionName.LowercaseMethod
            /**
             * Returns empty response.
             * @return array
             */
            public function getResponse() {
                // phpcs:enable
                return [];
            }
        };

        $methods = [
            'make_curl_call' => '{"response":"success"}',
            'get_curl_object' => $retrynoheadermockcurl,
        ];
        $mockservice = $this->get_mock_webservice($methods);

        $result = $mockservice->get_user("1");
        $this->assertDebuggingCalledCount($expectedcount = 3);
        $this->assertEquals($retrynoheadermockcurl->numgetinfocalls, 4);
        $this->assertEquals($result->response, 'success');
    }

    /**
     * Tests that we throw error if we tried more than max retries.
     */
    public function test_retry_exception(): void {
        $retryfailuremockcurl = new class {
            /**
             * @var ?string URL path.
             */
            public $urlpath = null;
            // phpcs:disable moodle.NamingConventions.ValidFunctionName.LowercaseMethod
            /**
             * Stub for curl setHeader().
             * @param string $unusedparam
             * @return void
             */
            public function setHeader($unusedparam) {
                // phpcs:enable
                return;
            }
            /**
             * Stub for curl get_errno().
             * @return boolean
             */
            public function get_errno() {
                return false;
            }
            /**
             * Returns 429.
             * @return array
             */
            public function get_info() {
                return ['http_code' => 429];
            }
            /**
             * Returns error code and message.
             * @param string $url
             * @param array $data
             * @return string
             */
            public function get($url, $data) {
                if ($this->urlpath === null) {
                    $this->urlpath = $url;
                } else if ($this->urlpath !== $url) {
                    // We should be getting the same path every time.
                    return '{"code":-1, "message":"incorrect url"}';
                }
                return '{"code":-1, "message":"too many retries"}';
            }
            // phpcs:disable moodle.NamingConventions.ValidFunctionName.LowercaseMethod
            /**
             * Returns retry to be 1 second later.
             * @return array
             */
            public function getResponse() {
                // phpcs:enable
                // Set retry time after 1 second. Format is 2020-05-31T00:00:00Z.
                $retrytime = time() + 1;
                return [
                    'X-RateLimit-Type' => 'Daily',
                    'X-RateLimit-Remaining' => 100,
                    'Retry-After' => gmdate('Y-m-d\TH:i:s\Z', $retrytime),
                ];
            }
        };

        $methods = [
            'get_curl_object' => $retryfailuremockcurl,
        ];
        $mockservice = $this->get_mock_webservice($methods);

        $foundexception = false;
        try {
            $result = $mockservice->get_user("1");
        } catch (retry_failed_exception $error) {
            $foundexception = true;
            $this->assertEquals($error->response, 'too many retries');
        }

        $this->assertTrue($foundexception);
        // Check that we retried MAX_RETRIES times.
        $this->assertDebuggingCalledCount(webservice::MAX_RETRIES);
    }

    /**
     * Tests that we are waiting 1 minute for QPS rate limit types.
     */
    public function test_retryqps_exception(): void {
        $retryqpsmockcurl = new class {
            /**
             * @var ?string URL path.
             */
            public $urlpath = null;
            // phpcs:disable moodle.NamingConventions.ValidFunctionName.LowercaseMethod
            /**
             * Stub for curl setHeader().
             * @param string $unusedparam
             * @return void
             */
            public function setHeader($unusedparam) {
                // phpcs:enable
                return;
            }
            /**
             * Stub for curl get_errno().
             * @return boolean
             */
            public function get_errno() {
                return false;
            }
            /**
             * Returns 429.
             * @return array
             */
            public function get_info() {
                return ['http_code' => 429];
            }
            /**
             * Returns error code and message.
             * @param string $url
             * @param array $data
             * @return string
             */
            public function get($url, $data) {
                if ($this->urlpath === null) {
                    $this->urlpath = $url;
                } else if ($this->urlpath !== $url) {
                    // We should be getting the same path every time.
                    return '{"code":-1, "message":"incorrect url"}';
                }

                return '{"code":-1, "message":"too many retries"}';
            }
            // phpcs:disable moodle.NamingConventions.ValidFunctionName.LowercaseMethod
            /**
             * Returns retry to be 1 second later.
             * @return array
             */
            public function getResponse() {
                // phpcs:enable
                // Signify that we reached max per second/minute rate limit.
                return ['X-RateLimit-Type' => 'QPS'];
            }
        };

        $methods = [
            'get_curl_object' => $retryqpsmockcurl,
        ];
        $mockservice = $this->get_mock_webservice($methods);

        $foundexception = false;
        try {
            $result = $mockservice->get_meetings('2020-01-01', '2020-01-02');
        } catch (webservice_exception $error) {
            $foundexception = true;
            $this->assertEquals($error->response, 'too many retries');
        }

        $this->assertTrue($foundexception);

        // Check that we waited 1 minute.
        $debugging = $this->getDebuggingMessages();

        $debuggingmsg = array_pop($debugging);
        $this->assertEquals('Received 429 response, sleeping 60 seconds ' .
                'until next retry. Current retry: 5', $debuggingmsg->message);

        // Check that we retried MAX_RETRIES times.
        $this->assertDebuggingCalledCount(webservice::MAX_RETRIES);
    }
}

====================

file: mod_zoom_invitation_test.php
path: tests/mod_zoom_invitation_test.php
codice:
<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Tests for the invitation class.
 *
 * @package    mod_zoom
 * @author     Andrew Madden <andrewmadden@catalyst-au.net>
 * @copyright  2021 Catalyst IT
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

use advanced_testcase;
use context_system;
use context_course;
use moodle_url;

/**
 * PHPunit testcase class for invitations.
 * @covers \mod_zoom\invitation
 */
final class mod_zoom_invitation_test extends advanced_testcase {
    /**
     * Setup to ensure that fixtures are loaded.
     */
    public static function setUpBeforeClass(): void {
        global $CFG;
        require_once($CFG->libdir . '/accesslib.php');
        parent::setUpBeforeClass();
    }

    /**
     * Run before every test.
     */
    protected function setUp(): void {
        parent::setUp();
        set_config('invitationregexenabled', 1, 'zoom');
    }

    /**
     * Test zoom invitation display message for user with all capabilities.
     */
    public function test_display_message_when_user_has_all_capabilities(): void {
        $this->resetAfterTest();
        $this->setAdminUser();
        $course = $this->getDataGenerator()->create_course();
        $zoom = $this->getDataGenerator()->create_module('zoom', ['course' => $course]);
        $message = (new invitation(
            $this->get_mock_invitation_message_scheduledmeeting()
        ))->get_display_string($zoom->cmid);
        $expectedmessage = "Organization is inviting you to a scheduled Zoom meeting.\r\n"
            . "\r\n"
            . "Topic: Zoom Meeting\r\n"
            . "Time: Mar 15, 2021 06:08 AM London\r\n"
            . "\r\n"
            . "Join Zoom Meeting\r\n"
            . "https://us02web.zoom.us/j/12341234123?pwd=THBLWExVS0QyYnV1Z1nZTDJGYVI2QT09\r\n"
            . "\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123123\r\n"
            . "\r\n"
            . "One tap mobile\r\n"
            . "+61323452345,,12341234123#,,,,*123456# Australia\r\n"
            . "+61312341234,,12341234123#,,,,*123456# Australia\r\n"
            . "\r\n"
            . "Dial by your location\r\n"
            . "        +61 3 5678 5678 Australia\r\n"
            . "        +61 3 4567 4567 Australia\r\n"
            . "        +61 3 3456 3456 Australia\r\n"
            . "        +61 3 2345 2345 Australia\r\n"
            . "        +61 3 1234 1234 Australia\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123456\r\n"
            . "Find your local number: https://us02web.zoom.us/u/abcde12345\r\n"
            . "\r\n"
            . "Join by SIP\r\n"
            . "1231231231234@zoomabc.com\r\n"
            . "\r\n"
            . "Join by H.323\r\n"
            . "162.255.37.11 (US West)\r\n"
            . "162.255.36.11 (US East)\r\n"
            . "115.114.131.7 (India Mumbai)\r\n"
            . "115.114.115.7 (India Hyderabad)\r\n"
            . "213.19.144.110 (Amsterdam Netherlands)\r\n"
            . "213.244.140.110 (Germany)\r\n"
            . "103.122.166.55 (Australia Sydney)\r\n"
            . "103.122.167.55 (Australia Melbourne)\r\n"
            . "149.137.40.110 (Singapore)\r\n"
            . "64.211.144.160 (Brazil)\r\n"
            . "69.174.57.160 (Canada Toronto)\r\n"
            . "65.39.152.160 (Canada Vancouver)\r\n"
            . "207.226.132.110 (Japan Tokyo)\r\n"
            . "149.137.24.110 (Japan Osaka)\r\n"
            . "Meeting ID: 966 7989 3993\r\n"
            . "Passcode: 44730043";
        $this->assertEquals($expectedmessage, $message);
    }

    /**
     * Test zoom invitation display message for user with only the mod/zoom:viewjoinurl capability.
     */
    public function test_display_message_when_user_has_viewjoinurl_capability(): void {
        $this->resetAfterTest();
        $this->setAdminUser();
        $user = $this->getDataGenerator()->create_user();
        $course = $this->getDataGenerator()->create_course();
        $role = $this->getDataGenerator()->create_role();
        $zoom = $this->getDataGenerator()->create_module('zoom', ['course' => $course]);
        assign_capability('mod/zoom:viewjoinurl', CAP_ALLOW, $role, context_system::instance()->id);
        role_assign($role, $user->id, context_course::instance($course->id));
        $message = (new invitation(
            $this->get_mock_invitation_message_scheduledmeeting()
        ))->get_display_string($zoom->cmid, $user->id);
        $expectedmessage = "Organization is inviting you to a scheduled Zoom meeting.\r\n"
            . "\r\n"
            . "Topic: Zoom Meeting\r\n"
            . "Time: Mar 15, 2021 06:08 AM London\r\n"
            . "\r\n"
            . "Join Zoom Meeting\r\n"
            . "https://us02web.zoom.us/j/12341234123?pwd=THBLWExVS0QyYnV1Z1nZTDJGYVI2QT09\r\n"
            . "\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123123";
        $this->assertEquals($expectedmessage, $message);
    }

    /**
     * Test zoom invitation display message for user with only the mod/zoom:viewdialin capability.
     */
    public function test_display_message_when_user_has_viewdialin_capability(): void {
        $this->resetAfterTest();
        $this->setAdminUser();
        $user = $this->getDataGenerator()->create_user();
        $course = $this->getDataGenerator()->create_course();
        $role = $this->getDataGenerator()->create_role();
        $zoom = $this->getDataGenerator()->create_module('zoom', ['course' => $course]);
        assign_capability('mod/zoom:viewdialin', CAP_ALLOW, $role, context_system::instance());
        role_assign($role, $user->id, context_course::instance($course->id));
        $message = (new invitation(
            $this->get_mock_invitation_message_scheduledmeeting()
        ))->get_display_string($zoom->cmid, $user->id);
        $expectedmessage = "Organization is inviting you to a scheduled Zoom meeting.\r\n"
            . "\r\n"
            . "Topic: Zoom Meeting\r\n"
            . "Time: Mar 15, 2021 06:08 AM London\r\n"
            . "\r\n"
            . "One tap mobile\r\n"
            . "+61323452345,,12341234123#,,,,*123456# Australia\r\n"
            . "+61312341234,,12341234123#,,,,*123456# Australia\r\n"
            . "\r\n"
            . "Dial by your location\r\n"
            . "        +61 3 5678 5678 Australia\r\n"
            . "        +61 3 4567 4567 Australia\r\n"
            . "        +61 3 3456 3456 Australia\r\n"
            . "        +61 3 2345 2345 Australia\r\n"
            . "        +61 3 1234 1234 Australia\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123456\r\n"
            . "Find your local number: https://us02web.zoom.us/u/abcde12345\r\n"
            . "\r\n"
            . "Join by SIP\r\n"
            . "1231231231234@zoomabc.com\r\n"
            . "\r\n"
            . "Join by H.323\r\n"
            . "162.255.37.11 (US West)\r\n"
            . "162.255.36.11 (US East)\r\n"
            . "115.114.131.7 (India Mumbai)\r\n"
            . "115.114.115.7 (India Hyderabad)\r\n"
            . "213.19.144.110 (Amsterdam Netherlands)\r\n"
            . "213.244.140.110 (Germany)\r\n"
            . "103.122.166.55 (Australia Sydney)\r\n"
            . "103.122.167.55 (Australia Melbourne)\r\n"
            . "149.137.40.110 (Singapore)\r\n"
            . "64.211.144.160 (Brazil)\r\n"
            . "69.174.57.160 (Canada Toronto)\r\n"
            . "65.39.152.160 (Canada Vancouver)\r\n"
            . "207.226.132.110 (Japan Tokyo)\r\n"
            . "149.137.24.110 (Japan Osaka)\r\n"
            . "Meeting ID: 966 7989 3993\r\n"
            . "Passcode: 44730043";
        $this->assertEquals($expectedmessage, $message);
    }

    /**
     * Test zoom invitation display message for user has no capabilities.
     */
    public function test_display_message_when_user_has_no_capabilities(): void {
        $this->resetAfterTest();
        $this->setAdminUser();
        $user = $this->getDataGenerator()->create_user();
        $course = $this->getDataGenerator()->create_course();
        $role = $this->getDataGenerator()->create_role();
        $zoom = $this->getDataGenerator()->create_module('zoom', ['course' => $course]);
        role_assign($role, $user->id, context_course::instance($course->id));
        $message = (new invitation(
            $this->get_mock_invitation_message_scheduledmeeting()
        ))->get_display_string($zoom->cmid, $user->id);
        $expectedmessage = "Organization is inviting you to a scheduled Zoom meeting.\r\n"
            . "\r\n"
            . "Topic: Zoom Meeting\r\n"
            . "Time: Mar 15, 2021 06:08 AM London";
        $this->assertEquals($expectedmessage, $message);
    }

    /**
     * Test message if regex pattern is intentionally set to empty for an element.
     */
    public function test_display_message_when_a_regex_pattern_is_empty(): void {
        global $PAGE;
        $this->resetAfterTest();
        $this->setAdminUser();
        set_config('invitation_joinurl', '', 'zoom');
        $user = $this->getDataGenerator()->create_user();
        $course = $this->getDataGenerator()->create_course();
        $role = $this->getDataGenerator()->create_role();
        $zoom = $this->getDataGenerator()->create_module('zoom', ['course' => $course]);
        role_assign($role, $user->id, context_course::instance($course->id));
        // Set mock zoom activity URL for page as exception messages expect it.
        $PAGE->set_url(new moodle_url('/mod/zoom/view.php?id=123'));
        $message = (new invitation(
            $this->get_mock_invitation_message_scheduledmeeting()
        ))->get_display_string($zoom->cmid, $user->id);
        $this->assertDebuggingNotCalled();
    }

    /**
     * Test debug message if regex pattern is not valid for an element.
     */
    public function test_display_message_when_a_regex_pattern_is_invalid(): void {
        global $PAGE;
        $this->resetAfterTest();
        $this->setAdminUser();
        set_config('invitation_joinurl', '~', 'zoom');
        $user = $this->getDataGenerator()->create_user();
        $course = $this->getDataGenerator()->create_course();
        $role = $this->getDataGenerator()->create_role();
        $zoom = $this->getDataGenerator()->create_module('zoom', ['course' => $course]);
        role_assign($role, $user->id, context_course::instance($course->id));
        // Set mock zoom activity URL for page as exception messages expect it.
        $PAGE->set_url(new moodle_url('/mod/zoom/view.php?id=123'));
        $message = (new invitation(
            $this->get_mock_invitation_message_scheduledmeeting()
        ))->get_display_string($zoom->cmid, $user->id);
        $this->assertDebuggingCalled('Error in regex for zoom invitation element: "joinurl" with pattern: "~".');
    }

    /**
     * Test debug message if no match is found using regex pattern for an element.
     */
    public function test_display_message_when_a_regex_pattern_is_finds_no_match(): void {
        $this->resetAfterTest();
        $this->setAdminUser();
        set_config('invitation_joinurl', '/nomatch/mi', 'zoom');
        $user = $this->getDataGenerator()->create_user();
        $course = $this->getDataGenerator()->create_course();
        $role = $this->getDataGenerator()->create_role();
        $zoom = $this->getDataGenerator()->create_module('zoom', ['course' => $course]);
        role_assign($role, $user->id, context_course::instance($course->id));
        $message = (new invitation(
            $this->get_mock_invitation_message_scheduledmeeting()
        ))->get_display_string($zoom->cmid, $user->id);
        $this->assertDebuggingCalled('No match found in zoom invitation for element: "joinurl" with pattern: "/nomatch/mi".');
    }

    /**
     * Test removing the invite sentence from the zoom meeting message.
     */
    public function test_display_message_has_invite_removed_if_setting_enabled(): void {
        $this->resetAfterTest();
        $this->setAdminUser();
        set_config('invitationremoveinvite', '1', 'zoom');
        $course = $this->getDataGenerator()->create_course();
        $zoom = $this->getDataGenerator()->create_module('zoom', ['course' => $course]);
        $message = (new invitation(
            $this->get_mock_invitation_message_scheduledmeeting()
        ))->get_display_string($zoom->cmid);
        $expectedmessage = "Topic: Zoom Meeting\r\n"
            . "Time: Mar 15, 2021 06:08 AM London\r\n"
            . "\r\n"
            . "Join Zoom Meeting\r\n"
            . "https://us02web.zoom.us/j/12341234123?pwd=THBLWExVS0QyYnV1Z1nZTDJGYVI2QT09\r\n"
            . "\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123123\r\n"
            . "\r\n"
            . "One tap mobile\r\n"
            . "+61323452345,,12341234123#,,,,*123456# Australia\r\n"
            . "+61312341234,,12341234123#,,,,*123456# Australia\r\n"
            . "\r\n"
            . "Dial by your location\r\n"
            . "        +61 3 5678 5678 Australia\r\n"
            . "        +61 3 4567 4567 Australia\r\n"
            . "        +61 3 3456 3456 Australia\r\n"
            . "        +61 3 2345 2345 Australia\r\n"
            . "        +61 3 1234 1234 Australia\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123456\r\n"
            . "Find your local number: https://us02web.zoom.us/u/abcde12345\r\n"
            . "\r\n"
            . "Join by SIP\r\n"
            . "1231231231234@zoomabc.com\r\n"
            . "\r\n"
            . "Join by H.323\r\n"
            . "162.255.37.11 (US West)\r\n"
            . "162.255.36.11 (US East)\r\n"
            . "115.114.131.7 (India Mumbai)\r\n"
            . "115.114.115.7 (India Hyderabad)\r\n"
            . "213.19.144.110 (Amsterdam Netherlands)\r\n"
            . "213.244.140.110 (Germany)\r\n"
            . "103.122.166.55 (Australia Sydney)\r\n"
            . "103.122.167.55 (Australia Melbourne)\r\n"
            . "149.137.40.110 (Singapore)\r\n"
            . "64.211.144.160 (Brazil)\r\n"
            . "69.174.57.160 (Canada Toronto)\r\n"
            . "65.39.152.160 (Canada Vancouver)\r\n"
            . "207.226.132.110 (Japan Tokyo)\r\n"
            . "149.137.24.110 (Japan Osaka)\r\n"
            . "Meeting ID: 966 7989 3993\r\n"
            . "Passcode: 44730043";
        $this->assertEquals($expectedmessage, $message);
    }

    /**
     * Test not removing the invite sentence from the zoom meeting message.
     */
    public function test_display_message_does_not_have_invite_removed_if_setting_disabled(): void {
        $this->resetAfterTest();
        $this->setAdminUser();
        set_config('invitationremoveinvite', '0', 'zoom');
        $course = $this->getDataGenerator()->create_course();
        $zoom = $this->getDataGenerator()->create_module('zoom', ['course' => $course]);
        $message = (new invitation(
            $this->get_mock_invitation_message_scheduledmeeting()
        ))->get_display_string($zoom->cmid);
        $expectedmessage = "Organization is inviting you to a scheduled Zoom meeting.\r\n"
            . "\r\n"
            . "Topic: Zoom Meeting\r\n"
            . "Time: Mar 15, 2021 06:08 AM London\r\n"
            . "\r\n"
            . "Join Zoom Meeting\r\n"
            . "https://us02web.zoom.us/j/12341234123?pwd=THBLWExVS0QyYnV1Z1nZTDJGYVI2QT09\r\n"
            . "\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123123\r\n"
            . "\r\n"
            . "One tap mobile\r\n"
            . "+61323452345,,12341234123#,,,,*123456# Australia\r\n"
            . "+61312341234,,12341234123#,,,,*123456# Australia\r\n"
            . "\r\n"
            . "Dial by your location\r\n"
            . "        +61 3 5678 5678 Australia\r\n"
            . "        +61 3 4567 4567 Australia\r\n"
            . "        +61 3 3456 3456 Australia\r\n"
            . "        +61 3 2345 2345 Australia\r\n"
            . "        +61 3 1234 1234 Australia\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123456\r\n"
            . "Find your local number: https://us02web.zoom.us/u/abcde12345\r\n"
            . "\r\n"
            . "Join by SIP\r\n"
            . "1231231231234@zoomabc.com\r\n"
            . "\r\n"
            . "Join by H.323\r\n"
            . "162.255.37.11 (US West)\r\n"
            . "162.255.36.11 (US East)\r\n"
            . "115.114.131.7 (India Mumbai)\r\n"
            . "115.114.115.7 (India Hyderabad)\r\n"
            . "213.19.144.110 (Amsterdam Netherlands)\r\n"
            . "213.244.140.110 (Germany)\r\n"
            . "103.122.166.55 (Australia Sydney)\r\n"
            . "103.122.167.55 (Australia Melbourne)\r\n"
            . "149.137.40.110 (Singapore)\r\n"
            . "64.211.144.160 (Brazil)\r\n"
            . "69.174.57.160 (Canada Toronto)\r\n"
            . "65.39.152.160 (Canada Vancouver)\r\n"
            . "207.226.132.110 (Japan Tokyo)\r\n"
            . "149.137.24.110 (Japan Osaka)\r\n"
            . "Meeting ID: 966 7989 3993\r\n"
            . "Passcode: 44730043";
        $this->assertEquals($expectedmessage, $message);
    }

    /**
     * Test removing the iCal link from the zoom meeting message.
     */
    public function test_display_message_has_icallink_removed_if_setting_enabled(): void {
        $this->resetAfterTest();
        $this->setAdminUser();
        set_config('invitationremoveicallink', '1', 'zoom');
        $course = $this->getDataGenerator()->create_course();
        $zoom = $this->getDataGenerator()->create_module('zoom', ['course' => $course]);

        // Test a scheduled meeting.
        $message = (new invitation(
            $this->get_mock_invitation_message_scheduledmeeting()
        ))->get_display_string($zoom->cmid);
        $expectedmessage = "Organization is inviting you to a scheduled Zoom meeting.\r\n"
            . "\r\n"
            . "Topic: Zoom Meeting\r\n"
            . "Time: Mar 15, 2021 06:08 AM London\r\n"
            . "\r\n"
            . "Join Zoom Meeting\r\n"
            . "https://us02web.zoom.us/j/12341234123?pwd=THBLWExVS0QyYnV1Z1nZTDJGYVI2QT09\r\n"
            . "\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123123\r\n"
            . "\r\n"
            . "One tap mobile\r\n"
            . "+61323452345,,12341234123#,,,,*123456# Australia\r\n"
            . "+61312341234,,12341234123#,,,,*123456# Australia\r\n"
            . "\r\n"
            . "Dial by your location\r\n"
            . "        +61 3 5678 5678 Australia\r\n"
            . "        +61 3 4567 4567 Australia\r\n"
            . "        +61 3 3456 3456 Australia\r\n"
            . "        +61 3 2345 2345 Australia\r\n"
            . "        +61 3 1234 1234 Australia\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123456\r\n"
            . "Find your local number: https://us02web.zoom.us/u/abcde12345\r\n"
            . "\r\n"
            . "Join by SIP\r\n"
            . "1231231231234@zoomabc.com\r\n"
            . "\r\n"
            . "Join by H.323\r\n"
            . "162.255.37.11 (US West)\r\n"
            . "162.255.36.11 (US East)\r\n"
            . "115.114.131.7 (India Mumbai)\r\n"
            . "115.114.115.7 (India Hyderabad)\r\n"
            . "213.19.144.110 (Amsterdam Netherlands)\r\n"
            . "213.244.140.110 (Germany)\r\n"
            . "103.122.166.55 (Australia Sydney)\r\n"
            . "103.122.167.55 (Australia Melbourne)\r\n"
            . "149.137.40.110 (Singapore)\r\n"
            . "64.211.144.160 (Brazil)\r\n"
            . "69.174.57.160 (Canada Toronto)\r\n"
            . "65.39.152.160 (Canada Vancouver)\r\n"
            . "207.226.132.110 (Japan Tokyo)\r\n"
            . "149.137.24.110 (Japan Osaka)\r\n"
            . "Meeting ID: 966 7989 3993\r\n"
            . "Passcode: 44730043";
        $this->assertEquals($expectedmessage, $message);

        // Test a recurring meeting with no fixed time.
        $message = (new invitation(
            $this->get_mock_invitation_message_recurringnofixed()
        ))->get_display_string($zoom->cmid);
        $expectedmessage = "Organization is inviting you to a scheduled Zoom meeting.\r\n"
            . "\r\n"
            . "Topic: Zoom Meeting\r\n"
            . "Time: This is a recurring meeting Meet anytime\r\n"
            . "\r\n"
            . "Join Zoom Meeting\r\n"
            . "https://us02web.zoom.us/j/12341234123?pwd=THBLWExVS0QyYnV1Z1nZTDJGYVI2QT09\r\n"
            . "\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123123\r\n"
            . "\r\n"
            . "One tap mobile\r\n"
            . "+61323452345,,12341234123#,,,,*123456# Australia\r\n"
            . "+61312341234,,12341234123#,,,,*123456# Australia\r\n"
            . "\r\n"
            . "Dial by your location\r\n"
            . "        +61 3 5678 5678 Australia\r\n"
            . "        +61 3 4567 4567 Australia\r\n"
            . "        +61 3 3456 3456 Australia\r\n"
            . "        +61 3 2345 2345 Australia\r\n"
            . "        +61 3 1234 1234 Australia\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123456\r\n"
            . "Find your local number: https://us02web.zoom.us/u/abcde12345\r\n"
            . "\r\n"
            . "Join by SIP\r\n"
            . "1231231231234@zoomabc.com\r\n"
            . "\r\n"
            . "Join by H.323\r\n"
            . "162.255.37.11 (US West)\r\n"
            . "162.255.36.11 (US East)\r\n"
            . "115.114.131.7 (India Mumbai)\r\n"
            . "115.114.115.7 (India Hyderabad)\r\n"
            . "213.19.144.110 (Amsterdam Netherlands)\r\n"
            . "213.244.140.110 (Germany)\r\n"
            . "103.122.166.55 (Australia Sydney)\r\n"
            . "103.122.167.55 (Australia Melbourne)\r\n"
            . "149.137.40.110 (Singapore)\r\n"
            . "64.211.144.160 (Brazil)\r\n"
            . "69.174.57.160 (Canada Toronto)\r\n"
            . "65.39.152.160 (Canada Vancouver)\r\n"
            . "207.226.132.110 (Japan Tokyo)\r\n"
            . "149.137.24.110 (Japan Osaka)\r\n"
            . "Meeting ID: 966 7989 3993\r\n"
            . "Passcode: 44730043";
        $this->assertEquals($expectedmessage, $message);

        // Test a recurring meeting with fixed time.
        $message = (new invitation($this->get_mock_invitation_message_recurringfixed()))->get_display_string($zoom->cmid);
        $expectedmessage = "Organization is inviting you to a scheduled Zoom meeting.\r\n"
            . "\r\n"
            . "Topic: Zoom Meeting\r\n"
            . "Time: Mar 15, 2021 06:08 AM London\r\n"
            . "        Every day, until Mar 17, 2021, 3 occurrence(s)\r\n"
            . "        Mar 15, 2021 06:08 AM\r\n"
            . "        Mar 16, 2021 06:08 AM\r\n"
            . "        Mar 17, 2021 06:08 AM\r\n"
            . "\r\n"
            . "Join Zoom Meeting\r\n"
            . "https://us02web.zoom.us/j/12341234123?pwd=THBLWExVS0QyYnV1Z1nZTDJGYVI2QT09\r\n"
            . "\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123123\r\n"
            . "\r\n"
            . "One tap mobile\r\n"
            . "+61323452345,,12341234123#,,,,*123456# Australia\r\n"
            . "+61312341234,,12341234123#,,,,*123456# Australia\r\n"
            . "\r\n"
            . "Dial by your location\r\n"
            . "        +61 3 5678 5678 Australia\r\n"
            . "        +61 3 4567 4567 Australia\r\n"
            . "        +61 3 3456 3456 Australia\r\n"
            . "        +61 3 2345 2345 Australia\r\n"
            . "        +61 3 1234 1234 Australia\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123456\r\n"
            . "Find your local number: https://us02web.zoom.us/u/abcde12345\r\n"
            . "\r\n"
            . "Join by SIP\r\n"
            . "1231231231234@zoomabc.com\r\n"
            . "\r\n"
            . "Join by H.323\r\n"
            . "162.255.37.11 (US West)\r\n"
            . "162.255.36.11 (US East)\r\n"
            . "115.114.131.7 (India Mumbai)\r\n"
            . "115.114.115.7 (India Hyderabad)\r\n"
            . "213.19.144.110 (Amsterdam Netherlands)\r\n"
            . "213.244.140.110 (Germany)\r\n"
            . "103.122.166.55 (Australia Sydney)\r\n"
            . "103.122.167.55 (Australia Melbourne)\r\n"
            . "149.137.40.110 (Singapore)\r\n"
            . "64.211.144.160 (Brazil)\r\n"
            . "69.174.57.160 (Canada Toronto)\r\n"
            . "65.39.152.160 (Canada Vancouver)\r\n"
            . "207.226.132.110 (Japan Tokyo)\r\n"
            . "149.137.24.110 (Japan Osaka)\r\n"
            . "Meeting ID: 966 7989 3993\r\n"
            . "Passcode: 44730043";
        $this->assertEquals($expectedmessage, $message);

        // We expect that the debugging was called two times:
        // - one time for the scheduled meeting
        // - one time for the recurring meeting with no fixed time.
        $debugmessage = 'No match found in zoom invitation for element: "icallink"'
            . ' with pattern: "/^.+download and import the following iCalendar.+$\n.+$/mi".';
        $this->assertDebuggingCalledCount(2, [$debugmessage, $debugmessage]);
    }

    /**
     * Test not removing the iCal link from the zoom meeting message.
     */
    public function test_display_message_does_not_have_icallink_removed_if_setting_disabled(): void {
        $this->resetAfterTest();
        $this->setAdminUser();
        set_config('invitationremoveicallink', '0', 'zoom');
        $course = $this->getDataGenerator()->create_course();
        $zoom = $this->getDataGenerator()->create_module('zoom', ['course' => $course]);

        // Test a scheduled meeting.
        $message = (new invitation(
            $this->get_mock_invitation_message_scheduledmeeting()
        ))->get_display_string($zoom->cmid);
        $expectedmessage = "Organization is inviting you to a scheduled Zoom meeting.\r\n"
            . "\r\n"
            . "Topic: Zoom Meeting\r\n"
            . "Time: Mar 15, 2021 06:08 AM London\r\n"
            . "\r\n"
            . "Join Zoom Meeting\r\n"
            . "https://us02web.zoom.us/j/12341234123?pwd=THBLWExVS0QyYnV1Z1nZTDJGYVI2QT09\r\n"
            . "\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123123\r\n"
            . "\r\n"
            . "One tap mobile\r\n"
            . "+61323452345,,12341234123#,,,,*123456# Australia\r\n"
            . "+61312341234,,12341234123#,,,,*123456# Australia\r\n"
            . "\r\n"
            . "Dial by your location\r\n"
            . "        +61 3 5678 5678 Australia\r\n"
            . "        +61 3 4567 4567 Australia\r\n"
            . "        +61 3 3456 3456 Australia\r\n"
            . "        +61 3 2345 2345 Australia\r\n"
            . "        +61 3 1234 1234 Australia\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123456\r\n"
            . "Find your local number: https://us02web.zoom.us/u/abcde12345\r\n"
            . "\r\n"
            . "Join by SIP\r\n"
            . "1231231231234@zoomabc.com\r\n"
            . "\r\n"
            . "Join by H.323\r\n"
            . "162.255.37.11 (US West)\r\n"
            . "162.255.36.11 (US East)\r\n"
            . "115.114.131.7 (India Mumbai)\r\n"
            . "115.114.115.7 (India Hyderabad)\r\n"
            . "213.19.144.110 (Amsterdam Netherlands)\r\n"
            . "213.244.140.110 (Germany)\r\n"
            . "103.122.166.55 (Australia Sydney)\r\n"
            . "103.122.167.55 (Australia Melbourne)\r\n"
            . "149.137.40.110 (Singapore)\r\n"
            . "64.211.144.160 (Brazil)\r\n"
            . "69.174.57.160 (Canada Toronto)\r\n"
            . "65.39.152.160 (Canada Vancouver)\r\n"
            . "207.226.132.110 (Japan Tokyo)\r\n"
            . "149.137.24.110 (Japan Osaka)\r\n"
            . "Meeting ID: 966 7989 3993\r\n"
            . "Passcode: 44730043";
        $this->assertEquals($expectedmessage, $message);

        // Test a recurring meeting with no fixed time.
        $message = (new invitation(
            $this->get_mock_invitation_message_recurringnofixed()
        ))->get_display_string($zoom->cmid);
        $expectedmessage = "Organization is inviting you to a scheduled Zoom meeting.\r\n"
            . "\r\n"
            . "Topic: Zoom Meeting\r\n"
            . "Time: This is a recurring meeting Meet anytime\r\n"
            . "\r\n"
            . "Join Zoom Meeting\r\n"
            . "https://us02web.zoom.us/j/12341234123?pwd=THBLWExVS0QyYnV1Z1nZTDJGYVI2QT09\r\n"
            . "\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123123\r\n"
            . "\r\n"
            . "One tap mobile\r\n"
            . "+61323452345,,12341234123#,,,,*123456# Australia\r\n"
            . "+61312341234,,12341234123#,,,,*123456# Australia\r\n"
            . "\r\n"
            . "Dial by your location\r\n"
            . "        +61 3 5678 5678 Australia\r\n"
            . "        +61 3 4567 4567 Australia\r\n"
            . "        +61 3 3456 3456 Australia\r\n"
            . "        +61 3 2345 2345 Australia\r\n"
            . "        +61 3 1234 1234 Australia\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123456\r\n"
            . "Find your local number: https://us02web.zoom.us/u/abcde12345\r\n"
            . "\r\n"
            . "Join by SIP\r\n"
            . "1231231231234@zoomabc.com\r\n"
            . "\r\n"
            . "Join by H.323\r\n"
            . "162.255.37.11 (US West)\r\n"
            . "162.255.36.11 (US East)\r\n"
            . "115.114.131.7 (India Mumbai)\r\n"
            . "115.114.115.7 (India Hyderabad)\r\n"
            . "213.19.144.110 (Amsterdam Netherlands)\r\n"
            . "213.244.140.110 (Germany)\r\n"
            . "103.122.166.55 (Australia Sydney)\r\n"
            . "103.122.167.55 (Australia Melbourne)\r\n"
            . "149.137.40.110 (Singapore)\r\n"
            . "64.211.144.160 (Brazil)\r\n"
            . "69.174.57.160 (Canada Toronto)\r\n"
            . "65.39.152.160 (Canada Vancouver)\r\n"
            . "207.226.132.110 (Japan Tokyo)\r\n"
            . "149.137.24.110 (Japan Osaka)\r\n"
            . "Meeting ID: 966 7989 3993\r\n"
            . "Passcode: 44730043";
        $this->assertEquals($expectedmessage, $message);

        // Test a recurring meeting with fixed time.
        $message = (new invitation($this->get_mock_invitation_message_recurringfixed()))->get_display_string($zoom->cmid);
        $expectedmessage = "Organization is inviting you to a scheduled Zoom meeting.\r\n"
            . "\r\n"
            . "Topic: Zoom Meeting\r\n"
            . "Time: Mar 15, 2021 06:08 AM London\r\n"
            . "        Every day, until Mar 17, 2021, 3 occurrence(s)\r\n"
            . "        Mar 15, 2021 06:08 AM\r\n"
            . "        Mar 16, 2021 06:08 AM\r\n"
            . "        Mar 17, 2021 06:08 AM\r\n"
            . "Please download and import the following iCalendar (.ics) files to your calendar system.\r\n"
            . "Zoom Meeting: https://us02web.zoom.us/meeting/u7Utd-GqqTkiEtEkvHci3z_X0W3TMjX_Avua/ics?icsToken="
            . "88tyKu-prjsiGNOXuBGCR_McAoigWerwtnpHj7d4lwnNACkAeDzOZtURBp91KOfx\r\n"
            . "\r\n"
            . "Join Zoom Meeting\r\n"
            . "https://us02web.zoom.us/j/12341234123?pwd=THBLWExVS0QyYnV1Z1nZTDJGYVI2QT09\r\n"
            . "\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123123\r\n"
            . "\r\n"
            . "One tap mobile\r\n"
            . "+61323452345,,12341234123#,,,,*123456# Australia\r\n"
            . "+61312341234,,12341234123#,,,,*123456# Australia\r\n"
            . "\r\n"
            . "Dial by your location\r\n"
            . "        +61 3 5678 5678 Australia\r\n"
            . "        +61 3 4567 4567 Australia\r\n"
            . "        +61 3 3456 3456 Australia\r\n"
            . "        +61 3 2345 2345 Australia\r\n"
            . "        +61 3 1234 1234 Australia\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123456\r\n"
            . "Find your local number: https://us02web.zoom.us/u/abcde12345\r\n"
            . "\r\n"
            . "Join by SIP\r\n"
            . "1231231231234@zoomabc.com\r\n"
            . "\r\n"
            . "Join by H.323\r\n"
            . "162.255.37.11 (US West)\r\n"
            . "162.255.36.11 (US East)\r\n"
            . "115.114.131.7 (India Mumbai)\r\n"
            . "115.114.115.7 (India Hyderabad)\r\n"
            . "213.19.144.110 (Amsterdam Netherlands)\r\n"
            . "213.244.140.110 (Germany)\r\n"
            . "103.122.166.55 (Australia Sydney)\r\n"
            . "103.122.167.55 (Australia Melbourne)\r\n"
            . "149.137.40.110 (Singapore)\r\n"
            . "64.211.144.160 (Brazil)\r\n"
            . "69.174.57.160 (Canada Toronto)\r\n"
            . "65.39.152.160 (Canada Vancouver)\r\n"
            . "207.226.132.110 (Japan Tokyo)\r\n"
            . "149.137.24.110 (Japan Osaka)\r\n"
            . "Meeting ID: 966 7989 3993\r\n"
            . "Passcode: 44730043";
        $this->assertEquals($expectedmessage, $message);
    }

    /**
     * Test get_display_string returns null without throwing an error if the invitation string provided is null.
     */
    public function test_display_message_when_instantiated_with_null_zoom_meeting_invitation(): void {
        $this->resetAfterTest();
        $this->setAdminUser();
        $course = $this->getDataGenerator()->create_course();
        $zoom = $this->getDataGenerator()->create_module('zoom', ['course' => $course]);
        $message = (new invitation(null))->get_display_string($zoom->cmid);
        $this->assertNull($message);
    }

    /**
     * Test display message is returned in full regardless of capabilities if regex patterns are disabled.
     */
    public function test_display_message_when_user_has_no_capabilities_with_regex_disabled(): void {
        set_config('invitationregexenabled', 0, 'zoom');
        $this->resetAfterTest();
        $this->setAdminUser();
        $user = $this->getDataGenerator()->create_user();
        $course = $this->getDataGenerator()->create_course();
        $role = $this->getDataGenerator()->create_role();
        $zoom = $this->getDataGenerator()->create_module('zoom', ['course' => $course]);
        role_assign($role, $user->id, context_course::instance($course->id));
        $message = (new invitation(
            $this->get_mock_invitation_message_scheduledmeeting()
        ))->get_display_string($zoom->cmid, $user->id);
        $expectedmessage = $this->get_mock_invitation_message_scheduledmeeting();
        $this->assertEquals($expectedmessage, $message);
    }

    /**
     * Get a mock zoom invitation email message for a scheduled meeting.
     *
     * @return string
     */
    private function get_mock_invitation_message_scheduledmeeting(): string {
        return "Organization is inviting you to a scheduled Zoom meeting.\r\n"
            . "\r\n"
            . "Topic: Zoom Meeting\r\n"
            . "Time: Mar 15, 2021 06:08 AM London\r\n"
            . "\r\n"
            . "Join Zoom Meeting\r\n"
            . "https://us02web.zoom.us/j/12341234123?pwd=THBLWExVS0QyYnV1Z1nZTDJGYVI2QT09\r\n"
            . "\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123123\r\n"
            . "One tap mobile\r\n"
            . "+61323452345,,12341234123#,,,,*123456# Australia\r\n"
            . "+61312341234,,12341234123#,,,,*123456# Australia\r\n"
            . "\r\n"
            . "Dial by your location\r\n"
            . "        +61 3 5678 5678 Australia\r\n"
            . "        +61 3 4567 4567 Australia\r\n"
            . "        +61 3 3456 3456 Australia\r\n"
            . "        +61 3 2345 2345 Australia\r\n"
            . "        +61 3 1234 1234 Australia\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123456\r\n"
            . "Find your local number: https://us02web.zoom.us/u/abcde12345\r\n"
            . "\r\n"
            . "Join by SIP\r\n"
            . "1231231231234@zoomabc.com\r\n"
            . "\r\n"
            . "Join by H.323\r\n"
            . "162.255.37.11 (US West)\r\n"
            . "162.255.36.11 (US East)\r\n"
            . "115.114.131.7 (India Mumbai)\r\n"
            . "115.114.115.7 (India Hyderabad)\r\n"
            . "213.19.144.110 (Amsterdam Netherlands)\r\n"
            . "213.244.140.110 (Germany)\r\n"
            . "103.122.166.55 (Australia Sydney)\r\n"
            . "103.122.167.55 (Australia Melbourne)\r\n"
            . "149.137.40.110 (Singapore)\r\n"
            . "64.211.144.160 (Brazil)\r\n"
            . "69.174.57.160 (Canada Toronto)\r\n"
            . "65.39.152.160 (Canada Vancouver)\r\n"
            . "207.226.132.110 (Japan Tokyo)\r\n"
            . "149.137.24.110 (Japan Osaka)\r\n"
            . "Meeting ID: 966 7989 3993\r\n"
            . "Passcode: 44730043\r";
    }

    /**
     * Get a mock zoom invitation email message for a recurring meeting with no fixed time.
     *
     * @return string
     */
    private function get_mock_invitation_message_recurringnofixed(): string {
        return "Organization is inviting you to a scheduled Zoom meeting.\r\n"
            . "\r\n"
            . "Topic: Zoom Meeting\r\n"
            . "Time: This is a recurring meeting Meet anytime\r\n"
            . "\r\n"
            . "Join Zoom Meeting\r\n"
            . "https://us02web.zoom.us/j/12341234123?pwd=THBLWExVS0QyYnV1Z1nZTDJGYVI2QT09\r\n"
            . "\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123123\r\n"
            . "One tap mobile\r\n"
            . "+61323452345,,12341234123#,,,,*123456# Australia\r\n"
            . "+61312341234,,12341234123#,,,,*123456# Australia\r\n"
            . "\r\n"
            . "Dial by your location\r\n"
            . "        +61 3 5678 5678 Australia\r\n"
            . "        +61 3 4567 4567 Australia\r\n"
            . "        +61 3 3456 3456 Australia\r\n"
            . "        +61 3 2345 2345 Australia\r\n"
            . "        +61 3 1234 1234 Australia\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123456\r\n"
            . "Find your local number: https://us02web.zoom.us/u/abcde12345\r\n"
            . "\r\n"
            . "Join by SIP\r\n"
            . "1231231231234@zoomabc.com\r\n"
            . "\r\n"
            . "Join by H.323\r\n"
            . "162.255.37.11 (US West)\r\n"
            . "162.255.36.11 (US East)\r\n"
            . "115.114.131.7 (India Mumbai)\r\n"
            . "115.114.115.7 (India Hyderabad)\r\n"
            . "213.19.144.110 (Amsterdam Netherlands)\r\n"
            . "213.244.140.110 (Germany)\r\n"
            . "103.122.166.55 (Australia Sydney)\r\n"
            . "103.122.167.55 (Australia Melbourne)\r\n"
            . "149.137.40.110 (Singapore)\r\n"
            . "64.211.144.160 (Brazil)\r\n"
            . "69.174.57.160 (Canada Toronto)\r\n"
            . "65.39.152.160 (Canada Vancouver)\r\n"
            . "207.226.132.110 (Japan Tokyo)\r\n"
            . "149.137.24.110 (Japan Osaka)\r\n"
            . "Meeting ID: 966 7989 3993\r\n"
            . "Passcode: 44730043\r";
    }

    /**
     * Get a mock zoom invitation email message for a recurring meeting with fixed time.
     *
     * @return string
     */
    private function get_mock_invitation_message_recurringfixed(): string {
        return "Organization is inviting you to a scheduled Zoom meeting.\r\n"
            . "\r\n"
            . "Topic: Zoom Meeting\r\n"
            . "Time: Mar 15, 2021 06:08 AM London\r\n"
            . "        Every day, until Mar 17, 2021, 3 occurrence(s)\r\n"
            . "        Mar 15, 2021 06:08 AM\r\n"
            . "        Mar 16, 2021 06:08 AM\r\n"
            . "        Mar 17, 2021 06:08 AM\r\n"
            . "Please download and import the following iCalendar (.ics) files to your calendar system.\r\n"
            . "Zoom Meeting: https://us02web.zoom.us/meeting/u7Utd-GqqTkiEtEkvHci3z_X0W3TMjX_Avua/ics?icsToken="
            . "88tyKu-prjsiGNOXuBGCR_McAoigWerwtnpHj7d4lwnNACkAeDzOZtURBp91KOfx\r\n"
            . "\r\n"
            . "Join Zoom Meeting\r\n"
            . "https://us02web.zoom.us/j/12341234123?pwd=THBLWExVS0QyYnV1Z1nZTDJGYVI2QT09\r\n"
            . "\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123123\r\n"
            . "One tap mobile\r\n"
            . "+61323452345,,12341234123#,,,,*123456# Australia\r\n"
            . "+61312341234,,12341234123#,,,,*123456# Australia\r\n"
            . "\r\n"
            . "Dial by your location\r\n"
            . "        +61 3 5678 5678 Australia\r\n"
            . "        +61 3 4567 4567 Australia\r\n"
            . "        +61 3 3456 3456 Australia\r\n"
            . "        +61 3 2345 2345 Australia\r\n"
            . "        +61 3 1234 1234 Australia\r\n"
            . "Meeting ID: 123 1234 1234\r\n"
            . "Passcode: 123456\r\n"
            . "Find your local number: https://us02web.zoom.us/u/abcde12345\r\n"
            . "\r\n"
            . "Join by SIP\r\n"
            . "1231231231234@zoomabc.com\r\n"
            . "\r\n"
            . "Join by H.323\r\n"
            . "162.255.37.11 (US West)\r\n"
            . "162.255.36.11 (US East)\r\n"
            . "115.114.131.7 (India Mumbai)\r\n"
            . "115.114.115.7 (India Hyderabad)\r\n"
            . "213.19.144.110 (Amsterdam Netherlands)\r\n"
            . "213.244.140.110 (Germany)\r\n"
            . "103.122.166.55 (Australia Sydney)\r\n"
            . "103.122.167.55 (Australia Melbourne)\r\n"
            . "149.137.40.110 (Singapore)\r\n"
            . "64.211.144.160 (Brazil)\r\n"
            . "69.174.57.160 (Canada Toronto)\r\n"
            . "65.39.152.160 (Canada Vancouver)\r\n"
            . "207.226.132.110 (Japan Tokyo)\r\n"
            . "149.137.24.110 (Japan Osaka)\r\n"
            . "Meeting ID: 966 7989 3993\r\n"
            . "Passcode: 44730043\r";
    }
}

====================

file: advanced_passcode_test.php
path: tests/advanced_passcode_test.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Unit tests for supporting advanced password requirements in Zoom.
 *
 * @package    mod_zoom
 * @copyright  2020 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

use basic_testcase;

/**
 * PHPunit testcase class.
 */
final class advanced_passcode_test extends basic_testcase {
    /**
     * Fake data from get_user_security_settings().
     * @var object
     */
    private $zoomdata;

    /**
     * Check regular expressions. Compatibility support for PHPUnit.
     *
     * @param string $pattern Regular expression.
     * @param string $string String.
     * @param string $message Message.
     */
    public static function assert_regexp($pattern, $string, $message = ''): void {
        if (method_exists('basic_testcase', 'assertMatchesRegularExpression')) {
            parent::assertMatchesRegularExpression($pattern, $string, $message);
        } else {
            parent::assertRegExp($pattern, $string, $message);
        }
    }

    /**
     * Setup to ensure that fixtures are loaded.
     */
    public static function setUpBeforeClass(): void {
        global $CFG;
        require_once($CFG->dirroot . '/mod/zoom/locallib.php');
        parent::setUpBeforeClass();
    }

    /**
     * Tests that a default password of 6 numbers is created when settings are null.
     * @covers ::zoom_create_default_passcode
     */
    public function test_settings_default(): void {
        $this->zoomdata = (object) webservice::DEFAULT_MEETING_PASSWORD_REQUIREMENT;

        $passcode = zoom_create_default_passcode($this->zoomdata);
        $this->assertEquals(strlen($passcode), 6);
        $this->assertTrue(ctype_digit($passcode));
    }

    /**
     * Tests that a password has the given minimum length.
     * @covers ::zoom_create_default_passcode
     */
    public function test_settings_length(): void {
        $data = [
            'length' => 8,
            'have_letter' => false,
            'have_upper_and_lower_characters' => false,
            'have_special_character' => false,
        ];
        $this->zoomdata = (object) $data;

        $passcode = zoom_create_default_passcode($this->zoomdata);
        $this->assertEquals(strlen($passcode), 8);
        $this->assertTrue(ctype_digit($passcode));
    }

    /**
     * Tests that a password is all numbers when the setting is specified.
     * @covers ::zoom_create_default_passcode
     */
    public function test_settings_only_numeric(): void {
        $data = [
            'length' => 10,
            'have_letter' => false,
            'have_upper_and_lower_characters' => false,
            'have_special_character' => false,
            'only_allow_numeric' => true,
        ];
        $this->zoomdata = (object) $data;

        $passcode = zoom_create_default_passcode($this->zoomdata);
        $this->assertEquals(strlen($passcode), 10);
        $this->assertTrue(ctype_digit($passcode));
    }

    /**
     * Tests that a password has a letter when the setting is specified.
     * @covers ::zoom_create_default_passcode
     */
    public function test_settings_letter(): void {
        $data = [
            'length' => null,
            'have_letter' => true,
            'have_upper_and_lower_characters' => false,
            'have_special_character' => null,
        ];
        $this->zoomdata = (object) $data;

        $passcode = zoom_create_default_passcode($this->zoomdata);
        $this->assertEquals(strlen($passcode), 6);
        $this->assert_regexp('/\d/', $passcode);
        $this->assert_regexp('/[a-zA-Z]/', $passcode);
    }

    /**
     * Tests that a password has uppercase and lowercase letters when the setting is specified.
     * @covers ::zoom_create_default_passcode
     */
    public function test_settings_upper_and_lower_letters(): void {
        $data = [
            'length' => null,
            'have_letter' => true,
            'have_upper_and_lower_characters' => true,
            'have_special_character' => null,
        ];
        $this->zoomdata = (object) $data;

        $passcode = zoom_create_default_passcode($this->zoomdata);
        $this->assertEquals(strlen($passcode), 6);
        $this->assert_regexp('/\d/', $passcode);
        $this->assert_regexp('/[A-Z]/', $passcode);
        $this->assert_regexp('/[a-z]/', $passcode);
    }

    /**
     * Tests that a password has a special character when the setting is specified.
     * @covers ::zoom_create_default_passcode
     */
    public function test_settings_special_character(): void {
        $data = [
            'length' => null,
            'have_letter' => null,
            'have_upper_and_lower_characters' => null,
            'have_special_character' => true,
        ];
        $this->zoomdata = (object) $data;

        $passcode = zoom_create_default_passcode($this->zoomdata);
        $this->assertEquals(strlen($passcode), 6);
        $this->assert_regexp('/\d/', $passcode);
        $this->assert_regexp('/[^a-zA-Z\d]/', $passcode);
    }

    /**
     * Tests that a password has correct length, a letter, and a special character when setting is specified.
     * @covers ::zoom_create_default_passcode
     */
    public function test_settings_all(): void {
        $data = [
            'length' => 7,
            'have_letter' => true,
            'have_upper_and_lower_characters' => true,
            'have_special_character' => true,
        ];
        $this->zoomdata = (object) $data;

        $passcode = zoom_create_default_passcode($this->zoomdata);
        $this->assertEquals(strlen($passcode), 7);
        $this->assert_regexp('/\d/', $passcode);
        $this->assert_regexp('/[a-zA-Z]/', $passcode);
        $this->assert_regexp('/[^a-zA-Z\d]/', $passcode);
    }

    /**
     * Tests that the password description is correct when all settings are present.
     * @covers ::zoom_create_passcode_description
     */
    public function test_pasword_description_all(): void {
        $data = [
            'length' => 9,
            'have_letter' => true,
            'have_number' => true,
            'have_upper_and_lower_characters' => true,
            'have_special_character' => true,
            'consecutive_characters_length' => 4,
            'only_allow_numeric' => false,
        ];
        $this->zoomdata = (object) $data;

        $description = zoom_create_passcode_description($this->zoomdata);
        $expected = 'Passcode must include both lower and uppercase characters. Passcode must contain at least 1 number. ' .
         'Passcode must have at least 1 special character (@-_*). Minimum of 9 character(s). Maximum of 3 consecutive ' .
         'characters (abcd, 1111, 1234, etc.). Maximum of 10 characters.';
        $this->assertEquals($description, $expected);
    }

    /**
     * Tests that the password description is correct when the only numeric option is present.
     * @covers ::zoom_create_passcode_description
     */
    public function test_pasword_description_only_numeric(): void {
        $data = [
            'length' => 8,
            'have_letter' => false,
            'have_number' => true,
            'have_upper_and_lower_characters' => false,
            'have_special_character' => false,
            'consecutive_characters_length' => 0,
            'only_allow_numeric' => true,
        ];
        $this->zoomdata = (object) $data;

        $description = zoom_create_passcode_description($this->zoomdata);
        $expected = 'Passcode may only contain numbers and no other characters. Minimum of 8 character(s). ' .
            'Maximum of 10 characters.';
        $this->assertEquals($description, $expected);
    }

    /**
     * Tests that the password description is correct when the default settings are present.
     * @covers ::zoom_create_passcode_description
     */
    public function test_pasword_description_default(): void {
        $this->zoomdata = (object) webservice::DEFAULT_MEETING_PASSWORD_REQUIREMENT;

        $description = zoom_create_passcode_description($this->zoomdata);
        $expected = 'Passcode may only contain the following characters: [a-z A-Z 0-9 @ - _ *]. Maximum of 10 characters.';
        $this->assertEquals($description, $expected);
    }
}

====================

file: error_handling_test.php
path: tests/error_handling_test.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Unit tests for error handling for zoom exceptions.
 *
 * @package    mod_zoom
 * @copyright  2019 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

use basic_testcase;

/**
 * PHPunit testcase class.
 */
final class error_handling_test extends basic_testcase {
    /**
     * Exception for when the meeting isn't found on Zoom.
     * @var not_found_exception
     */
    private $meetingnotfoundexception;

    /**
     * Exception for when the user isn't found on Zoom.
     * @var not_found_exception
     */
    private $usernotfoundexception;

    /**
     * Exception for when the user is found in the system but they haven't
     * accepted their invite, so they don't have permissions to do what was
     * requested.
     * @var not_found_exception
     */
    private $invaliduserexception;

    /**
     * Exception for when the meeting isn't found on Zoom.
     * @var not_found_exception
     */
    private $othererrorcodeexception;

    /**
     * Setup to ensure that fixtures are loaded.
     */
    public static function setUpBeforeClass(): void {
        global $CFG;
        require_once($CFG->dirroot . '/mod/zoom/locallib.php');
        parent::setUpBeforeClass();
    }

    /**
     * Setup before every test.
     */
    public function setUp(): void {
        parent::setUp();
        $this->meetingnotfoundexception = new not_found_exception('meeting not found', 3001);
        $this->usernotfoundexception = new not_found_exception('user not found', 1001);
        $this->invaliduserexception = new not_found_exception('invalid user found', 1120);
        $this->othererrorcodeexception = new not_found_exception('other exception', -1);
    }

    /**
     * Tests that uuid are encoded properly for use in web service calls.
     * @covers ::zoom_is_meeting_gone_error
     * @covers ::zoom_is_user_not_found_error
     */
    public function test_correct_error_recognition(): void {
        // Check meeting not found behavior.
        $this->assertTrue(zoom_is_meeting_gone_error($this->meetingnotfoundexception));
        $this->assertTrue(zoom_is_meeting_gone_error($this->usernotfoundexception));
        $this->assertTrue(zoom_is_meeting_gone_error($this->invaliduserexception));
        $this->assertFalse(zoom_is_meeting_gone_error($this->othererrorcodeexception));

        // Check user not found behavior.
        $this->assertTrue(zoom_is_user_not_found_error($this->usernotfoundexception));
        $this->assertTrue(zoom_is_user_not_found_error($this->invaliduserexception));
        $this->assertFalse(zoom_is_user_not_found_error($this->meetingnotfoundexception));
        $this->assertFalse(zoom_is_user_not_found_error($this->othererrorcodeexception));
    }
}

====================

file: view.php
path: view.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Prints a particular instance of zoom
 *
 * You can have a rather longer description of the file as well,
 * if you like, and it can span multiple lines.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

require(__DIR__ . '/../../config.php');
require_once(__DIR__ . '/lib.php');
require_once(__DIR__ . '/locallib.php');
require_once($CFG->libdir . '/moodlelib.php');

require_login();
// Additional access checks in zoom_get_instance_setup().
[$course, $cm, $zoom] = zoom_get_instance_setup();

$config = get_config('zoom');

$context = context_module::instance($cm->id);
$iszoommanager = has_capability('mod/zoom:addinstance', $context);

$event = \mod_zoom\event\course_module_viewed::create([
    'objectid' => $PAGE->cm->instance,
    'context' => $PAGE->context,
]);
$event->add_record_snapshot('course', $PAGE->course);
$event->add_record_snapshot($PAGE->cm->modname, $zoom);
$event->trigger();

// Print the page header.

$PAGE->set_url('/mod/zoom/view.php', ['id' => $cm->id]);
$PAGE->set_title(format_string($zoom->name));
$PAGE->set_heading(format_string($course->fullname));
$PAGE->requires->js_call_amd("mod_zoom/toggle_text", 'init');

// Get Zoom user ID of current Moodle user.
$zoomuserid = zoom_get_user_id(false);

// Check if this user is the (real) host.
$userisrealhost = ($zoomuserid === $zoom->host_id);

// Get the alternative hosts of the meeting.
$alternativehosts = zoom_get_alternative_host_array_from_string($zoom->alternative_hosts);

// Check if this user is the host or an alternative host.
// Lowercase email addresses so that we can do case-insensitive comparisons.
$userapiidentifier = zoom_get_api_identifier($USER);
if (filter_var($userapiidentifier, FILTER_VALIDATE_EMAIL) !== false) {
    $userapiidentifier = strtolower($userapiidentifier);
}
$userishost = ($userisrealhost || in_array($userapiidentifier, $alternativehosts, true));

// Get host user from Zoom.
$showrecreate = false;
if ($zoom->exists_on_zoom == ZOOM_MEETING_EXPIRED) {
    $showrecreate = true;
} else {
    try {
        zoom_webservice()->get_meeting_webinar_info($zoom->meeting_id, $zoom->webinar);
    } catch (\mod_zoom\webservice_exception $error) {
        $showrecreate = zoom_is_meeting_gone_error($error);

        if ($showrecreate) {
            // Mark meeting as expired.
            $updatedata = new stdClass();
            $updatedata->id = $zoom->id;
            $updatedata->exists_on_zoom = ZOOM_MEETING_EXPIRED;
            $DB->update_record('zoom', $updatedata);

            $zoom->exists_on_zoom = ZOOM_MEETING_EXPIRED;
        }
    } catch (moodle_exception $error) {
        // Ignore other exceptions.
        debugging($error->getMessage());
    }
}

$isrecurringnotime = ($zoom->recurring && $zoom->recurrence_type == ZOOM_RECURRINGTYPE_NOTIME);

$stryes = get_string('yes');
$strno = get_string('no');
$strstart = get_string('start_meeting', 'mod_zoom');
$strjoin = get_string('join_meeting', 'mod_zoom');
$strregister = get_string('register', 'mod_zoom');
$strtime = get_string('meeting_time', 'mod_zoom');
$strduration = get_string('duration', 'mod_zoom');
$strpassprotect = get_string('passwordprotected', 'mod_zoom');
$strpassword = get_string('password', 'mod_zoom');
$strjoinlink = get_string('joinlink', 'mod_zoom');
$strencryption = get_string('option_encryption_type', 'mod_zoom');
$strencryptionenhanced = get_string('option_encryption_type_enhancedencryption', 'mod_zoom');
$strencryptionendtoend = get_string('option_encryption_type_endtoendencryption', 'mod_zoom');
$strjoinbeforehost = get_string('joinbeforehost', 'mod_zoom');
$strstartvideohost = get_string('starthostjoins', 'mod_zoom');
$strstartvideopart = get_string('startpartjoins', 'mod_zoom');
$straudioopt = get_string('option_audio', 'mod_zoom');
$strstatus = get_string('status', 'mod_zoom');
$strall = get_string('allmeetings', 'mod_zoom');
$strwwaitingroom = get_string('waitingroom', 'mod_zoom');
$strmuteuponentry = get_string('option_mute_upon_entry', 'mod_zoom');
$strauthenticatedusers = get_string('option_authenticated_users', 'mod_zoom');
$strhost = get_string('host', 'mod_zoom');
$strmeetinginvite = get_string('meeting_invite', 'mod_zoom');
$strmeetinginviteshow = get_string('meeting_invite_show', 'mod_zoom');

// Output starts here.
echo $OUTPUT->header();

if ($CFG->branch < '400') {
    echo $OUTPUT->heading(format_string($zoom->name), 2);
}

// Show notification if the meeting does not exist on Zoom.
if ($showrecreate) {
    // Only show recreate/delete links in the message for users that can edit.
    if ($iszoommanager) {
        $message = get_string('zoomerr_meetingnotfound', 'mod_zoom', zoom_meetingnotfound_param($cm->id));
        $style = \core\output\notification::NOTIFY_ERROR;
    } else {
        $message = get_string('zoomerr_meetingnotfound_info', 'mod_zoom');
        $style = \core\output\notification::NOTIFY_WARNING;
    }

    echo $OUTPUT->notification($message, $style);
}

// Show intro.
if ($zoom->intro && $CFG->branch < '400') {
    echo $OUTPUT->box(format_module_intro('zoom', $zoom, $cm->id), 'generalbox mod_introbox', 'intro');
}

// Supplementary feature: Meeting capacity warning.
// Only show if the admin did not disable this feature completely.
if (!$showrecreate && $config->showcapacitywarning == true) {
    // Only show if the user viewing this is the host.
    if ($userishost) {
        // Get meeting capacity.
        $meetingcapacity = zoom_get_meeting_capacity($zoom->host_id, $zoom->webinar);

        // Get number of course participants who are eligible to join the meeting.
        $eligiblemeetingparticipants = zoom_get_eligible_meeting_participants($context);

        // If the number of eligible course participants exceeds the meeting capacity, output a warning.
        if ($eligiblemeetingparticipants > $meetingcapacity) {
            // Compose warning string.
            $participantspageurl = new moodle_url('/user/index.php', ['id' => $course->id]);
            $meetingcapacityplaceholders = [
                'meetingcapacity' => $meetingcapacity,
                'eligiblemeetingparticipants' => $eligiblemeetingparticipants,
                'zoomprofileurl' => $config->zoomurl . '/profile',
                'courseparticipantsurl' => $participantspageurl->out(),
                'hostname' => zoom_get_user_display_name($zoom->host_id),
            ];
            $meetingcapacitywarning = get_string('meetingcapacitywarningheading', 'mod_zoom');
            $meetingcapacitywarning .= html_writer::empty_tag('br');
            if ($userisrealhost == true) {
                $meetingcapacitywarning .= get_string(
                    'meetingcapacitywarningbodyrealhost',
                    'mod_zoom',
                    $meetingcapacityplaceholders
                );
            } else {
                $meetingcapacitywarning .= get_string(
                    'meetingcapacitywarningbodyalthost',
                    'mod_zoom',
                    $meetingcapacityplaceholders
                );
            }

            $meetingcapacitywarning .= html_writer::empty_tag('br');
            if ($userisrealhost == true) {
                $meetingcapacitywarning .= get_string('meetingcapacitywarningcontactrealhost', 'mod_zoom');
            } else {
                $meetingcapacitywarning .= get_string('meetingcapacitywarningcontactalthost', 'mod_zoom');
            }

            // Ideally, this would use $OUTPUT->notification(), but this renderer adds a close icon to the notification which
            // does not make sense here. So we build the notification manually.
            echo html_writer::tag('div', $meetingcapacitywarning, ['class' => 'alert alert-warning']);
        }
    }
}

// Get meeting state from Zoom.
[$inprogress, $available, $finished] = zoom_get_state($zoom);

// Show join meeting button or unavailability note.
if (!$showrecreate) {
    // If registration is required, check the registration.
    if (!$userishost && $zoom->registration != ZOOM_REGISTRATION_OFF) {
        $userisregistered = zoom_is_user_registered_for_meeting($USER->email, $zoom->meeting_id, $zoom->webinar);

        // Unregistered users are allowed to register.
        if (!$userisregistered) {
            $available = true;
        }
    }

    if ($available) {
        // Show join meeting button.
        if ($userishost) {
            $buttonhtml = html_writer::tag('button', $strstart, ['type' => 'submit', 'class' => 'btn btn-success']);
        } else {
            $btntext = $strjoin;
            // If user is not already registered, use register text.
            if ($zoom->registration != ZOOM_REGISTRATION_OFF && !$userisregistered) {
                $btntext = $strregister;
            }

            $buttonhtml = html_writer::tag('button', $btntext, ['type' => 'submit', 'class' => 'btn btn-primary']);
        }

        $aurl = new moodle_url('/mod/zoom/loadmeeting.php', ['id' => $cm->id]);
        $buttonhtml .= html_writer::input_hidden_params($aurl);
        $link = html_writer::tag('form', $buttonhtml, ['action' => $aurl->out_omit_querystring(), 'target' => '_blank']);
    } else {
        // Get unavailability note.
        $unavailabilitynote = zoom_get_unavailability_note($zoom, $finished);

        // Show unavailability note.
        // Ideally, this would use $OUTPUT->notification(), but this renderer adds a close icon to the notification which does not
        // make sense here. So we build the notification manually.
        $link = html_writer::tag('div', $unavailabilitynote, ['class' => 'alert alert-primary']);
    }

    echo $OUTPUT->box_start('generalbox text-center');
    echo $link;
    echo $OUTPUT->box_end();
}

if ($zoom->show_schedule) {
    echo $OUTPUT->box_start('', 'zoom_section-schedule');
    // Output "Schedule" heading.
    echo $OUTPUT->heading(get_string('schedule', 'mod_zoom'), 3);

    // Start "Schedule" table.
    $table = new html_table();
    $table->attributes['class'] = 'generaltable mod_view';
    $table->align = ['center', 'left'];
    $table->size = ['35%', '65%'];
    $numcolumns = 2;

    // Show start/end date or recurring meeting information.
    $rowmeetingtime = new html_table_row();
    $rowmeetingtime->id = 'zoom_schedule-meetingtime';
    $meetingtimeheader = new html_table_cell();
    $meetingtimeheader->header = true;
    $meetingtimetext = new html_table_cell();

    if ($isrecurringnotime) {
        $meetingtimeheader->text = get_string('recurringmeeting', 'mod_zoom');
        $meetingtimetext->text = get_string('recurringmeetingexplanation', 'mod_zoom');
    } else if ($zoom->recurring && $zoom->recurrence_type != ZOOM_RECURRINGTYPE_NOTIME) {
        $meetingrecurringheader = new html_table_cell();
        $meetingrecurringheader->header = true;
        $meetingrecurringheader->text = get_string('recurringmeeting', 'mod_zoom');
        $meetingrecurringtext = new html_table_cell();
        $meetingrecurringtext->text = get_string('recurringmeetingthisis', 'mod_zoom');
        $rowmeetingrecurring = new html_table_row();
        $rowmeetingrecurring->id = 'zoom_schedule-meetingrecurring';
        $rowmeetingrecurring->cells = [$meetingrecurringheader, $meetingrecurringtext];
        $table->data[] = $rowmeetingrecurring;
        $nextoccurrence = zoom_get_next_occurrence($zoom);
        $meetingtimeheader->text = get_string('nextoccurrence', 'mod_zoom');
        if ($nextoccurrence > 0) {
            $meetingtimetext->text = userdate($nextoccurrence);
        } else {
            $meetingtimetext->text = get_string('nooccurrenceleft', 'mod_zoom');
        }
    } else {
        $meetingtimeheader->text = $strtime;
        $meetingtimetext->text = userdate($zoom->start_time);
    }

    $rowmeetingtime->cells = [$meetingtimeheader, $meetingtimetext];
    $table->data[] = $rowmeetingtime;

    // Show meeting duration.
    if (!$isrecurringnotime) {
        $rowduration = new html_table_row();
        $rowduration->id = 'zoom_schedule-duration';
        $durationheader = new html_table_cell($strduration);
        $durationheader->header = true;
        $rowduration->cells = [$durationheader, format_time($zoom->duration)];
        $table->data[] = $rowduration;
    }

    // Show recordings section if option enabled to view recordings.
    if (!empty($config->viewrecordings)) {
        $recordinghtml = null;
        $recordingaddurl = new moodle_url('/mod/zoom/recordings.php', ['id' => $cm->id]);
        $recordingaddbutton = html_writer::div(get_string('recordingview', 'mod_zoom'), 'btn btn-primary');
        $recordingaddbuttonhtml = html_writer::link($recordingaddurl, $recordingaddbutton, ['target' => '_blank']);
        $recordingaddhtml = html_writer::div($recordingaddbuttonhtml);
        $recordinghtml .= $recordingaddhtml;

        $rowrecordings = new html_table_row();
        $rowrecordings->id = 'zoom_schedule-recordings';
        $recordingheader = new html_table_cell(get_string('recordings', 'mod_zoom'));
        $recordingheader->header = true;
        $rowrecordings->cells = [$recordingheader, $recordinghtml];
        $table->data[] = $rowrecordings;
    }

    // Display add-to-calendar button if meeting was found and isn't recurring and if the admin did not disable the feature.
    if ($config->showdownloadical != ZOOM_DOWNLOADICAL_DISABLE && !$showrecreate && !$isrecurringnotime) {
        $icallink = new moodle_url('/mod/zoom/exportical.php', ['id' => $cm->id]);
        $calendaricon = $OUTPUT->pix_icon('i/calendar', get_string('calendariconalt', 'mod_zoom'));
        $calendarbutton = html_writer::div($calendaricon . ' ' . get_string('downloadical', 'mod_zoom'), 'btn btn-primary');
        $buttonhtml = html_writer::link((string) $icallink, $calendarbutton, ['target' => '_blank']);
        $rowaddtocalendar = new html_table_row();
        $rowaddtocalendar->id = 'zoom_schedule-addtocalendar';
        $addtocalendarheader = new html_table_cell(get_string('addtocalendar', 'mod_zoom'));
        $addtocalendarheader->header = true;
        $rowaddtocalendar->cells = [$addtocalendarheader, $buttonhtml];
        $table->data[] = $rowaddtocalendar;
    }

    // Show meeting status.
    if ($zoom->exists_on_zoom == ZOOM_MEETING_EXPIRED) {
        $status = get_string('meeting_nonexistent_on_zoom', 'mod_zoom');
    } else if (!$isrecurringnotime) {
        if ($finished) {
            $status = get_string('meeting_finished', 'mod_zoom');
        } else if ($inprogress) {
            $status = get_string('meeting_started', 'mod_zoom');
        } else {
            $status = get_string('meeting_not_started', 'mod_zoom');
        }
        $rowstatus = new html_table_row();
        $rowstatus->id = 'zoom_schedule-status';
        $statusheader = new html_table_cell($strstatus);
        $statusheader->header = true;
        $rowstatus->cells = [$statusheader, $status];
        $table->data[] = $rowstatus;
    }

    // Show host.
    $hostdisplayname = zoom_get_user_display_name($zoom->host_id);
    if (isset($hostdisplayname)) {
        $rowhost = new html_table_row();
        $rowhost->id = 'zoom_schedule-host';
        $hostheader = new html_table_cell($strhost);
        $hostheader->header = true;
        $rowhost->cells = [$hostheader, $hostdisplayname];
        $table->data[] = $rowhost;
    }

    // Display alternate hosts if they exist and if the admin did not disable the feature.
    if ($iszoommanager) {
        if ($config->showalternativehosts != ZOOM_ALTERNATIVEHOSTS_DISABLE && !empty($zoom->alternative_hosts)) {
            // If the admin did show the alternative hosts user picker, we try to show the real names of the users here.
            $rowshowalternativehosts = new html_table_row();
            $rowshowalternativehosts->id = 'zoom_schedule-showalternativehosts';
            $alternativehostsheader = new html_table_cell(get_string('alternative_hosts', 'mod_zoom'));
            $alternativehostsheader->header = true;

            if ($config->showalternativehosts == ZOOM_ALTERNATIVEHOSTS_PICKER) {
                // Unfortunately, the host is not only able to add alternative hosts in Moodle with the user picker.
                // He is also able to add any alternative host with an email address in Zoom directly.
                // Thus, we get a) the array of existing Moodle user objects and b) the array of non-Moodle user mail addresses
                // based on the given set of alternative host email addresses.
                $alternativehostusers = zoom_get_users_from_alternativehosts($alternativehosts);
                $alternativehostnonusers = zoom_get_nonusers_from_alternativehosts($alternativehosts);

                // Create a comma-separated string of the existing Moodle users' fullnames.
                $alternativehostusersstring = implode(', ', array_map('fullname', $alternativehostusers));

                // Create a comma-separated string of the non-Moodle users' mail addresses.
                foreach ($alternativehostnonusers as &$ah) {
                    $ah .= ' (' . get_string('externaluser', 'mod_zoom') . ')';
                }

                $alternativehostnonusersstring = implode(', ', $alternativehostnonusers);

                // Concatenate both strings.
                // If we have existing Moodle users and non-Moodle users.
                if ($alternativehostusersstring != '' && $alternativehostnonusersstring != '') {
                    $alternativehoststring = $alternativehostusersstring . ', ' . $alternativehostnonusersstring;

                    // If we just have existing Moodle users.
                } else if ($alternativehostusersstring != '') {
                    $alternativehoststring = $alternativehostusersstring;

                    // It seems as if we just have non-Moodle users.
                } else {
                    $alternativehoststring = $alternativehostnonusersstring;
                }

                // Output the concatenated string of alternative hosts.
                $rowshowalternativehosts->cells = [$alternativehostsheader, $alternativehoststring];

                // Otherwise we stick with the plain list of email addresses as we got it from Zoom directly.
            } else {
                $rowshowalternativehosts->cells = [$alternativehostsheader, $zoom->alternative_hosts];
            }

            $table->data[] = $rowshowalternativehosts;
        }
    }

    // Show sessions link to users with edit capability.
    if ($iszoommanager) {
        $sessionsurl = new moodle_url('/mod/zoom/report.php', ['id' => $cm->id]);
        $sessionslink = html_writer::link($sessionsurl, get_string('sessionsreport', 'mod_zoom'));
        $rowsessions = new html_table_row();
        $rowsessions->id = 'zoom_schedule-sessions';
        $sessionsheader = new html_table_cell(get_string('sessions', 'mod_zoom'));
        $sessionsheader->header = true;
        $rowsessions->cells = [$sessionsheader, $sessionslink];
        $table->data[] = $rowsessions;
    }

    // Output table.
    echo html_writer::table($table);
    echo $OUTPUT->box_end();
}

if ($zoom->show_security) {
    echo $OUTPUT->box_start('', 'zoom_section-security');
    // Output "Security" heading.
    echo $OUTPUT->heading(get_string('security', 'mod_zoom'), 3);

    // Start "Security" table.
    $table = new html_table();
    $table->attributes['class'] = 'generaltable mod_view';
    $table->align = ['center', 'left'];
    $table->size = ['35%', '65%'];
    $numcolumns = 2;

    // Get passcode information.
    $haspassword = (isset($zoom->password) && $zoom->password !== '');
    $strhaspass = ($haspassword) ? $stryes : $strno;
    $canviewjoinurl = ($userishost || has_capability('mod/zoom:viewjoinurl', $context));

    // Show passcode status.
    $rowhaspass = new html_table_row();
    $rowhaspass->id = 'zoom_security-haspass';
    $haspassheader = new html_table_cell($strpassprotect);
    $haspassheader->header = true;
    $rowhaspass->cells = [$haspassheader, $strhaspass];
    $table->data[] = $rowhaspass;

    // Show passcode.
    if ($haspassword && ($canviewjoinurl || get_config('zoom', 'displaypassword'))) {
        $rowpassword = new html_table_row();
        $rowpassword->id = 'zoom_security-password';
        $passwordheader = new html_table_cell($strpassword);
        $passwordheader->header = true;
        $rowpassword->cells = [$passwordheader, $zoom->password];
        $table->data[] = $rowpassword;
    }

    // Show join link.
    if ($canviewjoinurl) {
        $rowjoinurl = new html_table_row();
        $rowjoinurl->id = 'zoom_security-joinurl';
        $joinurlheader = new html_table_cell($strjoinlink);
        $joinurlheader->header = true;
        $rowjoinurl->cells = [$joinurlheader, html_writer::link($zoom->join_url, $zoom->join_url, ['target' => '_blank'])];
        $table->data[] = $rowjoinurl;
    }

    // Show encryption type.
    if (!$zoom->webinar) {
        if ($config->showencryptiontype != ZOOM_ENCRYPTION_DISABLE) {
            $strenc = ($zoom->option_encryption_type === ZOOM_ENCRYPTION_TYPE_E2EE)
                ? $strencryptionendtoend
                : $strencryptionenhanced;
            $rowencryption = new html_table_row();
            $rowencryption->id = 'zoom_security-encryption';
            $encryptionheader = new html_table_cell($strencryption);
            $encryptionheader->header = true;
            $rowencryption->cells = [$encryptionheader, $strenc];
            $table->data[] = $rowencryption;
        }
    }

    // Show waiting room.
    if (!$zoom->webinar) {
        $strwr = ($zoom->option_waiting_room) ? $stryes : $strno;
        $rowwaitingroom = new html_table_row();
        $rowwaitingroom->id = 'zoom_security-waitingroom';
        $waitingroomheader = new html_table_cell($strwwaitingroom);
        $waitingroomheader->header = true;
        $rowwaitingroom->cells = [$waitingroomheader, $strwr];
        $table->data[] = $rowwaitingroom;
    }

    // Show join before host.
    if (!$zoom->webinar) {
        $strjbh = ($zoom->option_jbh) ? $stryes : $strno;
        $rowjoinbeforehost = new html_table_row();
        $rowjoinbeforehost->id = 'zoom_security-joinbeforehost';
        $joinbeforehostheader = new html_table_cell($strjoinbeforehost);
        $joinbeforehostheader->header = true;
        $rowjoinbeforehost->cells = [$joinbeforehostheader, $strjbh];
        $table->data[] = $rowjoinbeforehost;
    }

    // Show authentication.
    $rowauthenticatedusers = new html_table_row();
    $rowauthenticatedusers->id = 'zoom_security-authenticatedusers';
    $authenticatedusersheader = new html_table_cell($strauthenticatedusers);
    $authenticatedusersheader->header = true;
    $rowauthenticatedusers->cells = [$authenticatedusersheader, $zoom->option_authenticated_users ? $stryes : $strno];
    $table->data[] = $rowauthenticatedusers;

    // Output table.
    echo html_writer::table($table);
    echo $OUTPUT->box_end();
}

if ($zoom->show_media) {
    echo $OUTPUT->box_start('', 'zoom_section-media');
    // Output "Media" heading.
    echo $OUTPUT->heading(get_string('media', 'mod_zoom'), 3);

    // Start "Media" table.
    $table = new html_table();
    $table->attributes['class'] = 'generaltable mod_view';
    $table->align = ['center', 'left'];
    $table->size = ['35%', '65%'];
    $numcolumns = 2;

    // Show host video.
    if (!$zoom->webinar) {
        $strvideohost = ($zoom->option_host_video) ? $stryes : $strno;
        $rowshowhostvideo = new html_table_row();
        $rowshowhostvideo->id = 'zoom_media-showhostvideo';
        $showhostvideoheader = new html_table_cell($strstartvideohost);
        $showhostvideoheader->header = true;
        $rowshowhostvideo->cells = [$showhostvideoheader, $strvideohost];
        $table->data[] = $rowshowhostvideo;
    }

    // Show participants video.
    if (!$zoom->webinar) {
        $strparticipantsvideo = ($zoom->option_participants_video) ? $stryes : $strno;
        $rowstartvideopart = new html_table_row();
        $rowstartvideopart->id = 'zoom_media-startvideopart';
        $startvideopartheader = new html_table_cell($strstartvideopart);
        $startvideopartheader->header = true;
        $rowstartvideopart->cells = [$startvideopartheader, $strparticipantsvideo];
        $table->data[] = $rowstartvideopart;
    }

    // Show audio options.
    $rowaudioopt = new html_table_row();
    $rowaudioopt->id = 'zoom_media-audioopt';
    $audiooptheader = new html_table_cell($straudioopt);
    $audiooptheader->header = true;
    $rowaudioopt->cells = [$audiooptheader, get_string('audio_' . $zoom->option_audio, 'mod_zoom')];
    $table->data[] = $rowaudioopt;

    // Show audio default configuration.
    $rowmuteuponentry = new html_table_row();
    $rowmuteuponentry->id = 'zoom_media-muteuponentry';
    $muteuponentryheader = new html_table_cell($strmuteuponentry);
    $muteuponentryheader->header = true;
    $rowmuteuponentry->cells = [$muteuponentryheader, ($zoom->option_mute_upon_entry) ? $stryes : $strno];
    $table->data[] = $rowmuteuponentry;

    // Show dial-in information.
    if (
        !$showrecreate
        && ($zoom->option_audio === ZOOM_AUDIO_BOTH || $zoom->option_audio === ZOOM_AUDIO_TELEPHONY)
        && ($userishost || has_capability('mod/zoom:viewdialin', $context))
    ) {
        // Get meeting invitation from Zoom.
        $meetinginvite = zoom_webservice()->get_meeting_invitation($zoom)->get_display_string($cm->id);
        // Show meeting invitation if there is any.
        if (!empty($meetinginvite)) {
            $meetinginvitetext = str_replace("\r\n", '<br/>', $meetinginvite);
            $showbutton = html_writer::tag(
                'button',
                $strmeetinginviteshow,
                ['id' => 'show-more-button', 'class' => 'btn btn-link pt-0 pl-0']
            );
            $meetinginvitebody = html_writer::div(
                $meetinginvitetext,
                '',
                ['id' => 'show-more-body', 'style' => 'display: none;']
            );
            $rowmeetinginvite = new html_table_row();
            $rowmeetinginvite->id = 'zoom_media-meetinginvite';
            $meetinginviteheader = new html_table_cell($strmeetinginvite);
            $meetinginviteheader->header = true;
            $rowmeetinginvite->cells = [$meetinginviteheader, html_writer::div($showbutton . $meetinginvitebody, '')];
            $table->data[] = $rowmeetinginvite;
        }
    }

    // Output table.
    echo html_writer::table($table);
    echo $OUTPUT->box_end();
}

// Supplementary feature: All meetings link.
// Only show if the admin did not disable this feature completely.
if ($config->showallmeetings != ZOOM_ALLMEETINGS_DISABLE) {
    $urlall = new moodle_url('/mod/zoom/index.php', ['id' => $course->id]);
    $linkall = html_writer::link($urlall, $strall);
    echo $OUTPUT->box_start('generalbox mt-4 pt-4 border-top text-center');
    echo $linkall;
    echo $OUTPUT->box_end();
}

// Finish the page.
echo $OUTPUT->footer();

====================

file: locallib.php
path: locallib.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Internal library of functions for module zoom
 *
 * All the zoom specific functions, needed to implement the module
 * logic, should go here. Never include this file from your lib.php!
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die();

global $CFG;
require_once($CFG->dirroot . '/mod/zoom/lib.php');
require_once($CFG->dirroot . '/mod/zoom/classes/webservice_exception.php');
require_once($CFG->dirroot . '/mod/zoom/classes/api_limit_exception.php');
require_once($CFG->dirroot . '/mod/zoom/classes/bad_request_exception.php');
require_once($CFG->dirroot . '/mod/zoom/classes/not_found_exception.php');
require_once($CFG->dirroot . '/mod/zoom/classes/retry_failed_exception.php');
require_once($CFG->dirroot . '/mod/zoom/classes/webservice.php');

// Constants.
// Audio options.
define('ZOOM_AUDIO_TELEPHONY', 'telephony');
define('ZOOM_AUDIO_VOIP', 'voip');
define('ZOOM_AUDIO_BOTH', 'both');
// Meeting types.
define('ZOOM_INSTANT_MEETING', 1);
define('ZOOM_SCHEDULED_MEETING', 2);
define('ZOOM_RECURRING_MEETING', 3);
define('ZOOM_SCHEDULED_WEBINAR', 5);
define('ZOOM_RECURRING_WEBINAR', 6);
define('ZOOM_RECURRING_FIXED_MEETING', 8);
define('ZOOM_RECURRING_FIXED_WEBINAR', 9);
// Meeting status.
define('ZOOM_MEETING_EXPIRED', 0);
define('ZOOM_MEETING_EXISTS', 1);

// Number of meetings per page from zoom's get user report.
define('ZOOM_DEFAULT_RECORDS_PER_CALL', 30);
define('ZOOM_MAX_RECORDS_PER_CALL', 300);
// User types. Numerical values from Zoom API.
define('ZOOM_USER_TYPE_BASIC', 1);
define('ZOOM_USER_TYPE_PRO', 2);
define('ZOOM_USER_TYPE_CORP', 3);
define('ZOOM_MEETING_NOT_FOUND_ERROR_CODE', 3001);
define('ZOOM_USER_NOT_FOUND_ERROR_CODE', 1001);
define('ZOOM_INVALID_USER_ERROR_CODE', 1120);
// Webinar options.
define('ZOOM_WEBINAR_DISABLE', 0);
define('ZOOM_WEBINAR_SHOWONLYIFLICENSE', 1);
define('ZOOM_WEBINAR_ALWAYSSHOW', 2);
// Encryption type options.
define('ZOOM_ENCRYPTION_DISABLE', 0);
define('ZOOM_ENCRYPTION_SHOWONLYIFPOSSIBLE', 1);
define('ZOOM_ENCRYPTION_ALWAYSSHOW', 2);
// Encryption types. String values for Zoom API.
define('ZOOM_ENCRYPTION_TYPE_ENHANCED', 'enhanced_encryption');
define('ZOOM_ENCRYPTION_TYPE_E2EE', 'e2ee');
// Alternative hosts options.
define('ZOOM_ALTERNATIVEHOSTS_DISABLE', 0);
define('ZOOM_ALTERNATIVEHOSTS_INPUTFIELD', 1);
define('ZOOM_ALTERNATIVEHOSTS_PICKER', 2);
// Scheduling privilege options.
define('ZOOM_SCHEDULINGPRIVILEGE_DISABLE', 0);
define('ZOOM_SCHEDULINGPRIVILEGE_ENABLE', 1);
// All meetings options.
define('ZOOM_ALLMEETINGS_DISABLE', 0);
define('ZOOM_ALLMEETINGS_ENABLE', 1);
// Download iCal options.
define('ZOOM_DOWNLOADICAL_DISABLE', 0);
define('ZOOM_DOWNLOADICAL_ENABLE', 1);
// Capacity warning options.
define('ZOOM_CAPACITYWARNING_DISABLE', 0);
define('ZOOM_CAPACITYWARNING_ENABLE', 1);
// Recurrence type options.
define('ZOOM_RECURRINGTYPE_NOTIME', 0);
define('ZOOM_RECURRINGTYPE_DAILY', 1);
define('ZOOM_RECURRINGTYPE_WEEKLY', 2);
define('ZOOM_RECURRINGTYPE_MONTHLY', 3);
// Recurring monthly repeat options.
define('ZOOM_MONTHLY_REPEAT_OPTION_DAY', 1);
define('ZOOM_MONTHLY_REPEAT_OPTION_WEEK', 2);
// Recurring end date options.
define('ZOOM_END_DATE_OPTION_BY', 1);
define('ZOOM_END_DATE_OPTION_AFTER', 2);
// API endpoint options.
define('ZOOM_API_ENDPOINT_EU', 'eu');
define('ZOOM_API_ENDPOINT_GLOBAL', 'global');
define('ZOOM_API_URL_EU', 'https://eu01api-www4local.zoom.us/v2/');
define('ZOOM_API_URL_GLOBAL', 'https://api.zoom.us/v2/');
// Auto-recording options.
define('ZOOM_AUTORECORDING_NONE', 'none');
define('ZOOM_AUTORECORDING_USERDEFAULT', 'userdefault');
define('ZOOM_AUTORECORDING_LOCAL', 'local');
define('ZOOM_AUTORECORDING_CLOUD', 'cloud');
// Registration options.
define('ZOOM_REGISTRATION_AUTOMATIC', 0);
define('ZOOM_REGISTRATION_MANUAL', 1);
define('ZOOM_REGISTRATION_OFF', 2);

/**
 * Terminate the current script with a fatal error.
 *
 * Adapted from core_renderer's fatal_error() method. Needed because throwing errors with HTML links in them will convert links
 * to text using htmlentities. See MDL-66161 - Reflected XSS possible from some fatal error messages.
 *
 * So need custom error handler for fatal Zoom errors that have links to help people.
 *
 * @param string $errorcode The name of the string from error.php to print
 * @param string $module name of module
 * @param string $continuelink The url where the user will be prompted to continue.
 *                             If no url is provided the user will be directed to
 *                             the site index page.
 * @param mixed $a Extra words and phrases that might be required in the error string
 */
function zoom_fatal_error($errorcode, $module = '', $continuelink = '', $a = null) {
    global $CFG, $COURSE, $OUTPUT, $PAGE;

    $output = '';
    $obbuffer = '';

    // Assumes that function is run before output is generated.
    if ($OUTPUT->has_started()) {
        // If not then have to default to standard error.
        throw new moodle_exception($errorcode, $module, $continuelink, $a);
    }

    $PAGE->set_heading($COURSE->fullname);
    $output .= $OUTPUT->header();

    // Output message without messing with HTML content of error.
    $message = '<p class="errormessage">' . get_string($errorcode, $module, $a) . '</p>';

    $output .= $OUTPUT->box($message, 'errorbox alert alert-danger', null, ['data-rel' => 'fatalerror']);

    if ($CFG->debugdeveloper) {
        if (!empty($debuginfo)) {
            $debuginfo = s($debuginfo); // Removes all nasty JS.
            $debuginfo = str_replace("\n", '<br />', $debuginfo); // Keep newlines.
            $output .= $OUTPUT->notification('<strong>Debug info:</strong> ' . $debuginfo, 'notifytiny');
        }

        if (!empty($backtrace)) {
            $output .= $OUTPUT->notification('<strong>Stack trace:</strong> ' . format_backtrace($backtrace), 'notifytiny');
        }

        if ($obbuffer !== '') {
            $output .= $OUTPUT->notification('<strong>Output buffer:</strong> ' . s($obbuffer), 'notifytiny');
        }
    }

    if (!empty($continuelink)) {
        $output .= $OUTPUT->continue_button($continuelink);
    }

    $output .= $OUTPUT->footer();

    // Padding to encourage IE to display our error page, rather than its own.
    $output .= str_repeat(' ', 512);

    echo $output;

    exit(1); // General error code.
}

/**
 * Get course/cm/zoom objects from url parameters, and check for login/permissions.
 *
 * @return array Array of ($course, $cm, $zoom)
 */
function zoom_get_instance_setup() {
    global $DB;

    $id = optional_param('id', 0, PARAM_INT); // Course_module ID.
    $n = optional_param('n', 0, PARAM_INT);  // Zoom instance ID.

    if ($id) {
        $cm = get_coursemodule_from_id('zoom', $id, 0, false, MUST_EXIST);
        $course = $DB->get_record('course', ['id' => $cm->course], '*', MUST_EXIST);
        $zoom = $DB->get_record('zoom', ['id' => $cm->instance], '*', MUST_EXIST);
    } else if ($n) {
        $zoom = $DB->get_record('zoom', ['id' => $n], '*', MUST_EXIST);
        $course = $DB->get_record('course', ['id' => $zoom->course], '*', MUST_EXIST);
        $cm = get_coursemodule_from_instance('zoom', $zoom->id, $course->id, false, MUST_EXIST);
    } else {
        throw new moodle_exception('zoomerr_id_missing', 'mod_zoom');
    }

    require_login($course, true, $cm);

    $context = context_module::instance($cm->id);
    require_capability('mod/zoom:view', $context);

    return [$course, $cm, $zoom];
}

/**
 * Retrieves information for a meeting.
 *
 * @param int $zoomid
 * @return array information about the meeting
 */
function zoom_get_sessions_for_display($zoomid) {
    global $DB, $CFG;

    require_once($CFG->libdir . '/moodlelib.php');

    $sessions = [];
    $format = get_string('strftimedatetimeshort', 'langconfig');

    // Sort sessions in start_time ascending order.
    $instances = $DB->get_records('zoom_meeting_details', ['zoomid' => $zoomid], 'start_time');

    foreach ($instances as $instance) {
        // The meeting uuid, not the participant's uuid.
        $uuid = $instance->uuid;
        $participantlist = zoom_get_participants_report($instance->id);
        $sessions[$uuid]['participants'] = $participantlist;

        $uniquevalues = [];
        $uniqueparticipantcount = 0;
        foreach ($participantlist as $participant) {
            $unique = true;
            if ($participant->uuid != null) {
                if (array_key_exists($participant->uuid, $uniquevalues)) {
                    $unique = false;
                } else {
                    $uniquevalues[$participant->uuid] = true;
                }
            }

            if ($participant->userid != null) {
                if (!$unique || !array_key_exists($participant->userid, $uniquevalues)) {
                    $uniquevalues[$participant->userid] = true;
                } else {
                    $unique = false;
                }
            }

            if ($participant->user_email != null) {
                if (!$unique || !array_key_exists($participant->user_email, $uniquevalues)) {
                    $uniquevalues[$participant->user_email] = true;
                } else {
                    $unique = false;
                }
            }

            $uniqueparticipantcount += $unique ? 1 : 0;
        }

        $sessions[$uuid]['count'] = $uniqueparticipantcount;
        $sessions[$uuid]['topic'] = $instance->topic;
        $sessions[$uuid]['duration'] = $instance->duration;
        $sessions[$uuid]['starttime'] = userdate($instance->start_time, $format);
        $sessions[$uuid]['endtime'] = userdate($instance->start_time + $instance->duration * 60, $format);
    }

    return $sessions;
}

/**
 * Get the next occurrence of a meeting.
 *
 * @param stdClass $zoom
 * @return int The timestamp of the next occurrence of a recurring meeting or
 *             0 if this is a recurring meeting without fixed time or
 *             the timestamp of the meeting start date if this isn't a recurring meeting.
 */
function zoom_get_next_occurrence($zoom) {
    global $DB;

    // Prepare an ad-hoc request cache as this function could be called multiple times throughout a request
    // and we want to avoid to make duplicate DB calls.
    $cacheoptions = [
        'simplekeys' => true,
        'simpledata' => true,
    ];
    $cache = cache::make_from_params(cache_store::MODE_REQUEST, 'zoom', 'nextoccurrence', [], $cacheoptions);

    // If the next occurrence wasn't already cached, fill the cache.
    $cachednextoccurrence = $cache->get($zoom->id);
    if ($cachednextoccurrence === false) {
        // If this isn't a recurring meeting.
        if (!$zoom->recurring) {
            // Use the meeting start time.
            $cachednextoccurrence = $zoom->start_time;

            // Or if this is a recurring meeting without fixed time.
        } else if ($zoom->recurrence_type == ZOOM_RECURRINGTYPE_NOTIME) {
            // Use 0 as there isn't anything better to return.
            $cachednextoccurrence = 0;

            // Otherwise we have a recurring meeting with a recurrence schedule.
        } else {
            // Get the calendar event of the next occurrence.
            $selectclause = "modulename = :modulename AND instance = :instance AND (timestart + timeduration) >= :now";
            $selectparams = ['modulename' => 'zoom', 'instance' => $zoom->id, 'now' => time()];
            $nextoccurrence = $DB->get_records_select('event', $selectclause, $selectparams, 'timestart ASC', 'timestart', 0, 1);

            // If we haven't got a single event.
            if (empty($nextoccurrence)) {
                // Use 0 as there isn't anything better to return.
                $cachednextoccurrence = 0;
            } else {
                // Use the timestamp of the event.
                $nextoccurenceobject = reset($nextoccurrence);
                $cachednextoccurrence = $nextoccurenceobject->timestart;
            }
        }

        // Store the next occurrence into the cache.
        $cache->set($zoom->id, $cachednextoccurrence);
    }

    // Return the next occurrence.
    return $cachednextoccurrence;
}

/**
 * Determine if a zoom meeting is in progress, is available, and/or is finished.
 *
 * @param stdClass $zoom
 * @return array Array of booleans: [in progress, available, finished].
 */
function zoom_get_state($zoom) {
    // Get plugin config.
    $config = get_config('zoom');

    // Get the current time as calculation basis.
    $now = time();

    // If this is a recurring meeting with a recurrence schedule.
    if ($zoom->recurring && $zoom->recurrence_type != ZOOM_RECURRINGTYPE_NOTIME) {
        // Get the next occurrence start time.
        $starttime = zoom_get_next_occurrence($zoom);
    } else {
        // Get the meeting start time.
        $starttime = $zoom->start_time;
    }

    // Calculate the time when the recurring meeting becomes available next,
    // based on the next occurrence start time and the general meeting lead time.
    $firstavailable = $starttime - ($config->firstabletojoin * 60);

    // Calculate the time when the meeting ends to be available,
    // based on the next occurrence start time and the meeting duration.
    $lastavailable = $starttime + $zoom->duration;

    // Determine if the meeting is in progress.
    $inprogress = ($firstavailable <= $now && $now <= $lastavailable);

    // Determine if its a recurring meeting with no fixed time.
    $isrecurringnotime = $zoom->recurring && $zoom->recurrence_type == ZOOM_RECURRINGTYPE_NOTIME;

    // Determine if the meeting is available,
    // based on the fact if it is recurring or in progress.
    $available = $isrecurringnotime || $inprogress;

    // Determine if the meeting is finished,
    // based on the fact if it is recurring or the meeting end time is still in the future.
    $finished = !$isrecurringnotime && $now > $lastavailable;

    // Return the requested information.
    return [$inprogress, $available, $finished];
}

/**
 * Get the Zoom id of the currently logged-in user.
 *
 * @param bool $required If true, will error if the user doesn't have a Zoom account.
 * @return string
 */
function zoom_get_user_id($required = true) {
    global $USER;

    $cache = cache::make('mod_zoom', 'zoomid');
    if (!($zoomuserid = $cache->get($USER->id))) {
        $zoomuserid = false;
        try {
            $zoomuser = zoom_get_user(zoom_get_api_identifier($USER));
            if ($zoomuser !== false && isset($zoomuser->id) && ($zoomuser->id !== false)) {
                $zoomuserid = $zoomuser->id;
                $cache->set($USER->id, $zoomuserid);
            }
            // If user does not have a Zoom account, throw an error.
            if ($required && $zoomuser === false) {
                throw new moodle_exception('zoomerr_usernotfound', 'mod_zoom', '', get_config('zoom', 'zoomurl'));
            }
        } catch (moodle_exception $error) {
            if ($required) {
                throw $error;
            }
        }
    }

    return $zoomuserid;
}

/**
 * Get the Zoom meeting security settings, including meeting password requirements of the user's master account.
 *
 * @param string|int $identifier The user's email or the user's ID per Zoom API.
 * @return stdClass
 */
function zoom_get_meeting_security_settings($identifier) {
    $cache = cache::make('mod_zoom', 'zoommeetingsecurity');
    $zoommeetingsecurity = $cache->get($identifier);
    if (empty($zoommeetingsecurity)) {
        $zoommeetingsecurity = zoom_webservice()->get_account_meeting_security_settings($identifier);
        $cache->set($identifier, $zoommeetingsecurity);
    }

    return $zoommeetingsecurity;
}

/**
 * Check if the error indicates that a meeting is gone.
 *
 * @param moodle_exception $error
 * @return bool
 */
function zoom_is_meeting_gone_error($error) {
    // If the meeting's owner/user cannot be found, we consider the meeting to be gone.
    return ($error->zoomerrorcode === ZOOM_MEETING_NOT_FOUND_ERROR_CODE) || zoom_is_user_not_found_error($error);
}

/**
 * Check if the error indicates that a user is not found or does not belong to the current account.
 *
 * @param moodle_exception $error
 * @return bool
 */
function zoom_is_user_not_found_error($error) {
    return ($error->zoomerrorcode === ZOOM_USER_NOT_FOUND_ERROR_CODE) || ($error->zoomerrorcode === ZOOM_INVALID_USER_ERROR_CODE);
}

/**
 * Return the string parameter for zoomerr_meetingnotfound.
 *
 * @param string $cmid
 * @return stdClass
 */
function zoom_meetingnotfound_param($cmid) {
    // Provide links to recreate and delete.
    $recreate = new moodle_url('/mod/zoom/recreate.php', ['id' => $cmid, 'sesskey' => sesskey()]);
    $delete = new moodle_url('/course/mod.php', ['delete' => $cmid, 'sesskey' => sesskey()]);

    // Convert links to strings and pass as error parameter.
    $param = new stdClass();
    $param->recreate = $recreate->out();
    $param->delete = $delete->out();

    return $param;
}

/**
 * Get the data of each user for the participants report.
 * @param string $detailsid The meeting ID that you want to get the participants report for.
 * @return array The user data as an array of records (array of arrays).
 */
function zoom_get_participants_report($detailsid) {
    global $DB;
    $sql = 'SELECT zmp.id,
                   zmp.name,
                   zmp.userid,
                   zmp.user_email,
                   zmp.join_time,
                   zmp.leave_time,
                   zmp.duration,
                   zmp.uuid
              FROM {zoom_meeting_participants} zmp
             WHERE zmp.detailsid = :detailsid
    ';
    $params = [
        'detailsid' => $detailsid,
    ];
    $participants = $DB->get_records_sql($sql, $params);
    return $participants;
}

/**
 * Creates a default passcode from the user's Zoom meeting security settings.
 *
 * @param stdClass $meetingpasswordrequirement
 * @return string passcode
 */
function zoom_create_default_passcode($meetingpasswordrequirement) {
    $length = max($meetingpasswordrequirement->length, 6);
    $random = rand(0, pow(10, $length) - 1);
    $passcode = str_pad(strval($random), $length, '0', STR_PAD_LEFT);

    // Get a random set of indexes to replace with non-numberic values.
    $indexes = range(0, $length - 1);
    shuffle($indexes);

    if ($meetingpasswordrequirement->have_letter || $meetingpasswordrequirement->have_upper_and_lower_characters) {
        // Random letter from A-Z.
        $passcode[$indexes[0]] = chr(rand(65, 90));
        // Random letter from a-z.
        $passcode[$indexes[1]] = chr(rand(97, 122));
    }

    if ($meetingpasswordrequirement->have_special_character) {
        $specialchar = '@_*-';
        $passcode[$indexes[2]] = substr(str_shuffle($specialchar), 0, 1);
    }

    return $passcode;
}

/**
 * Creates a description string from the user's Zoom meeting security settings.
 *
 * @param stdClass $meetingpasswordrequirement
 * @return string description of password requirements
 */
function zoom_create_passcode_description($meetingpasswordrequirement) {
    $description = '';
    if ($meetingpasswordrequirement->only_allow_numeric) {
        $description .= get_string('password_only_numeric', 'mod_zoom') . ' ';
    } else {
        if ($meetingpasswordrequirement->have_letter && !$meetingpasswordrequirement->have_upper_and_lower_characters) {
            $description .= get_string('password_letter', 'mod_zoom') . ' ';
        } else if ($meetingpasswordrequirement->have_upper_and_lower_characters) {
            $description .= get_string('password_lower_upper', 'mod_zoom') . ' ';
        }

        if ($meetingpasswordrequirement->have_number) {
            $description .= get_string('password_number', 'mod_zoom') . ' ';
        }

        if ($meetingpasswordrequirement->have_special_character) {
            $description .= get_string('password_special', 'mod_zoom') . ' ';
        } else {
            $description .= get_string('password_allowed_char', 'mod_zoom') . ' ';
        }
    }

    if ($meetingpasswordrequirement->length) {
        $description .= get_string('password_length', 'mod_zoom', $meetingpasswordrequirement->length) . ' ';
    }

    if ($meetingpasswordrequirement->consecutive_characters_length > 0) {
        $description .= get_string(
            'password_consecutive',
            'mod_zoom',
            $meetingpasswordrequirement->consecutive_characters_length - 1
        ) . ' ';
    }

    $description .= get_string('password_max_length', 'mod_zoom');
    return $description;
}

/**
 * Creates an array of users who can be selected as alternative host in a given context.
 *
 * @param context $context The context to be used.
 *
 * @return array Array of users (mail => fullname).
 */
function zoom_get_selectable_alternative_hosts_list(context $context) {
    // Get selectable alternative host users based on the capability.
    $users = get_enrolled_users($context, 'mod/zoom:eligiblealternativehost', 0, 'u.*', 'lastname');

    // Create array of users.
    $selectablealternativehosts = [];

    // Iterate over selectable alternative host users.
    foreach ($users as $u) {
        // Note: Basically, if this is the user's own data row, the data row should be skipped.
        // But this would then not cover the case when a user is scheduling the meeting _for_ another user
        // and wants to be an alternative host himself.
        // As this would have to be handled at runtime in the browser, we just offer all users with the
        // capability as selectable and leave this aspect as possible improvement for the future.
        // At least, Zoom does not care if the user who is the host adds himself as alternative host as well.

        // Verify that the user really has a Zoom account.
        // Furthermore, verify that the user's status is active. Adding a pending or inactive user as alternative host will result
        // in a Zoom API error otherwise.
        $zoomuser = zoom_get_user($u->email);
        if ($zoomuser !== false && $zoomuser->status === 'active') {
            // Add user to array of users.
            $selectablealternativehosts[strtolower($u->email)] = fullname($u);
        }
    }

    return $selectablealternativehosts;
}

/**
 * Creates a string of roles who can be selected as alternative host in a given context.
 *
 * @param context $context The context to be used.
 *
 * @return string The string of roles.
 */
function zoom_get_selectable_alternative_hosts_rolestring(context $context) {
    // Get selectable alternative host users based on the capability.
    $roles = get_role_names_with_caps_in_context($context, ['mod/zoom:eligiblealternativehost']);

    // Compose string.
    $rolestring = implode(', ', $roles);

    return $rolestring;
}

/**
 * Get existing Moodle users from a given set of alternative hosts.
 *
 * @param array $alternativehosts The array of alternative hosts email addresses.
 *
 * @return array The array of existing Moodle user objects.
 */
function zoom_get_users_from_alternativehosts(array $alternativehosts) {
    global $DB;

    // Get the existing Moodle user objects from the DB.
    [$insql, $inparams] = $DB->get_in_or_equal($alternativehosts);
    $sql = 'SELECT *
            FROM {user}
            WHERE email ' . $insql . '
            ORDER BY lastname ASC';
    $alternativehostusers = $DB->get_records_sql($sql, $inparams);

    return $alternativehostusers;
}

/**
 * Get non-Moodle users from a given set of alternative hosts.
 *
 * @param array $alternativehosts The array of alternative hosts email addresses.
 *
 * @return array The array of non-Moodle user mail addresses.
 */
function zoom_get_nonusers_from_alternativehosts(array $alternativehosts) {
    global $DB;

    // Get the non-Moodle user mail addresses by checking which one does not exist in the DB.
    $alternativehostnonusers = [];
    [$insql, $inparams] = $DB->get_in_or_equal($alternativehosts);
    $sql = 'SELECT email
            FROM {user}
            WHERE email ' . $insql . '
            ORDER BY email ASC';
    $alternativehostusersmails = $DB->get_records_sql($sql, $inparams);
    foreach ($alternativehosts as $ah) {
        if (!array_key_exists($ah, $alternativehostusersmails)) {
            $alternativehostnonusers[] = $ah;
        }
    }

    return $alternativehostnonusers;
}

/**
 * Get the unavailability note based on the Zoom plugin configuration.
 *
 * @param object $zoom The Zoom meeting object.
 * @param bool|null $finished The function needs to know if the meeting is already finished.
 *                       You can provide this information, if already available, to the function.
 *                       Otherwise it will determine it with a small overhead.
 *
 * @return string The unavailability note.
 */
function zoom_get_unavailability_note($zoom, $finished = null) {
    // Get config.
    $config = get_config('zoom');

    // Get the plain unavailable string.
    $strunavailable = get_string('unavailable', 'mod_zoom');

    // If this is a recurring meeting without fixed time, just use the plain unavailable string.
    if ($zoom->recurring && $zoom->recurrence_type == ZOOM_RECURRINGTYPE_NOTIME) {
        $unavailabilitynote = $strunavailable;

        // Otherwise we add some more information to the unavailable string.
    } else {
        // If we don't have the finished information yet, get it with a small overhead.
        if ($finished === null) {
            [$inprogress, $available, $finished] = zoom_get_state($zoom);
        }

        // If this meeting is still pending.
        if ($finished !== true) {
            // If the admin wants to show the leadtime.
            if (!empty($config->displayleadtime) && $config->firstabletojoin > 0) {
                $unavailabilitynote = $strunavailable . '<br />' .
                        get_string('unavailablefirstjoin', 'mod_zoom', ['mins' => ($config->firstabletojoin)]);

                // Otherwise.
            } else {
                $unavailabilitynote = $strunavailable . '<br />' . get_string('unavailablenotstartedyet', 'mod_zoom');
            }

            // Otherwise, the meeting has finished.
        } else {
            $unavailabilitynote = $strunavailable . '<br />' . get_string('unavailablefinished', 'mod_zoom');
        }
    }

    return $unavailabilitynote;
}

/**
 * Gets the meeting capacity of a given Zoom user.
 * Please note: This function does not check if the Zoom user really exists, this has to be checked before calling this function.
 *
 * @param string $zoomhostid The Zoom ID of the host.
 * @param bool $iswebinar The meeting is a webinar.
 *
 * @return int|bool The meeting capacity of the Zoom user or false if the user does not have any meeting capacity at all.
 */
function zoom_get_meeting_capacity(string $zoomhostid, bool $iswebinar = false) {
    // Get the 'feature' section of the user's Zoom settings.
    $userfeatures = zoom_get_user_settings($zoomhostid)->feature;

    $meetingcapacity = false;

    // If this is a webinar.
    if ($iswebinar === true) {
        // Get the appropriate capacity value.
        if (!empty($userfeatures->webinar_capacity)) {
            $meetingcapacity = $userfeatures->webinar_capacity;
        } else if (!empty($userfeatures->zoom_events_capacity)) {
            $meetingcapacity = $userfeatures->zoom_events_capacity;
        }
    } else {
        // If this is a meeting, get the 'meeting_capacity' value.
        if (!empty($userfeatures->meeting_capacity)) {
            $meetingcapacity = $userfeatures->meeting_capacity;

            // Check if the user has a 'large_meeting' license that has a higher capacity value.
            if (!empty($userfeatures->large_meeting_capacity) && $userfeatures->large_meeting_capacity > $meetingcapacity) {
                $meetingcapacity = $userfeatures->large_meeting_capacity;
            }
        }
    }

    return $meetingcapacity;
}

/**
 * Gets the number of eligible meeting participants in a given context.
 * Please note: This function only covers users who are enrolled into the given context.
 * It does _not_ include users who have the necessary capability on a higher context without being enrolled.
 *
 * @param context $context The context which we want to check.
 *
 * @return int The number of eligible meeting participants.
 */
function zoom_get_eligible_meeting_participants(context $context) {
    global $DB;

    // Compose SQL query.
    $sqlsnippets = get_enrolled_with_capabilities_join($context, '', 'mod/zoom:view', 0, true);
    $sql = 'SELECT count(DISTINCT u.id)
            FROM {user} u ' . $sqlsnippets->joins . ' WHERE ' . $sqlsnippets->wheres;

    // Run query and count records.
    $eligibleparticipantcount = $DB->count_records_sql($sql, $sqlsnippets->params);

    return $eligibleparticipantcount;
}

/**
 * Get array of alternative hosts from a string.
 *
 * @param string $alternativehoststring Comma (or semicolon) separated list of alternative hosts.
 * @return string[] $alternativehostarray Array of alternative hosts.
 */
function zoom_get_alternative_host_array_from_string($alternativehoststring) {
    if (empty($alternativehoststring)) {
        return [];
    }

    // The Zoom API has historically returned either semicolons or commas, so we need to support both.
    $alternativehoststring = str_replace(';', ',', $alternativehoststring);
    $alternativehostarray = array_filter(explode(',', $alternativehoststring));

    // Lowercase email addresses so that we can do case-insensitive comparisons.
    foreach ($alternativehostarray as $key => $value) {
        if (filter_var($value, FILTER_VALIDATE_EMAIL) !== false) {
            $alternativehostarray[$key] = strtolower($value);
        }
    }
    return $alternativehostarray;
}

/**
 * Get all custom user profile fields of type text
 *
 * @return array list of user profile fields
 */
function zoom_get_user_profile_fields() {
    global $DB;

    $userfields = [];
    $records = $DB->get_records('user_info_field', ['datatype' => 'text']);
    foreach ($records as $record) {
        $userfields[$record->shortname] = $record->name;
    }

    return $userfields;
}

/**
 * Get all valid options for API Identifier field
 *
 * @return array list of all valid options
 */
function zoom_get_api_identifier_fields() {
    $options = [
        'email' => get_string('email'),
        'username' => get_string('username'),
        'idnumber' => get_string('idnumber'),
    ];

    $userfields = zoom_get_user_profile_fields();
    if (!empty($userfields)) {
        $options += $userfields;
    }

    return $options;
}

/**
 * Get the zoom api identifier
 *
 * @param object $user The user object
 *
 * @return string the value of the identifier
 */
function zoom_get_api_identifier($user) {
    // Get the value from the config first.
    $field = get_config('zoom', 'apiidentifier');

    $identifier = '';
    if (isset($user->$field)) {
        // If one of the standard user fields.
        $identifier = $user->$field;
    } else if (isset($user->profile[$field])) {
        // If one of the custom user fields.
        $identifier = $user->profile[$field];
    }

    if (empty($identifier)) {
        // Fallback to email if the field is not set.
        $identifier = $user->email;
    }

    return $identifier;
}

/**
 * Creates an iCalendar_event for a Zoom meeting.
 *
 * @param stdClass $event The meeting object.
 * @param string $description The event description.
 *
 * @return iCalendar_event
 */
function zoom_helper_icalendar_event($event, $description) {
    global $CFG;

    // Match Moodle's uid format for iCal events.
    $hostaddress = str_replace('http://', '', $CFG->wwwroot);
    $hostaddress = str_replace('https://', '', $hostaddress);
    $uid = $event->id . '@' . $hostaddress;

    $icalevent = new iCalendar_event();
    $icalevent->add_property('uid', $uid); // A unique identifier.
    $icalevent->add_property('summary', $event->name); // Title.
    $icalevent->add_property('dtstamp', Bennu::timestamp_to_datetime()); // Time of creation.
    $icalevent->add_property('last-modified', Bennu::timestamp_to_datetime($event->timemodified));
    $icalevent->add_property('dtstart', Bennu::timestamp_to_datetime($event->timestart)); // Start time.
    $icalevent->add_property('dtend', Bennu::timestamp_to_datetime($event->timestart + $event->timeduration)); // End time.
    $icalevent->add_property('description', $description);
    return $icalevent;
}

/**
 * Get the configured Zoom API URL.
 *
 * @return string The API URL.
 */
function zoom_get_api_url() {
    // Get the API endpoint setting.
    $apiendpoint = get_config('zoom', 'apiendpoint');

    // Pick the corresponding API URL.
    switch ($apiendpoint) {
        case ZOOM_API_ENDPOINT_EU:
            $apiurl = ZOOM_API_URL_EU;
            break;

        case ZOOM_API_ENDPOINT_GLOBAL:
        default:
            $apiurl = ZOOM_API_URL_GLOBAL;
            break;
    }

    // Return API URL.
    return $apiurl;
}

/**
 * Loads the zoom meeting and passes back a meeting URL
 * after processing events, view completion, grades, and license updates.
 *
 * @param int $id course module id
 * @param object $context moodle context object
 * @param bool $usestarturl
 * @return array $returns contains url object 'nexturl' or string 'error'
 */
function zoom_load_meeting($id, $context, $usestarturl = true) {
    global $CFG, $DB, $USER;
    require_once($CFG->libdir . '/gradelib.php');

    $cm = get_coursemodule_from_id('zoom', $id, 0, false, MUST_EXIST);
    $course = get_course($cm->course);
    $zoom = $DB->get_record('zoom', ['id' => $cm->instance], '*', MUST_EXIST);

    require_login($course, true, $cm);

    require_capability('mod/zoom:view', $context);

    $returns = ['nexturl' => null, 'error' => null];

    [$inprogress, $available, $finished] = zoom_get_state($zoom);

    $userisregistered = false;
    $userisregistering = false;
    if ($zoom->registration != ZOOM_REGISTRATION_OFF) {
        // Check if user already registered.
        $registrantjoinurl = zoom_get_registrant_join_url($USER->email, $zoom->meeting_id, $zoom->webinar);
        $userisregistered = !empty($registrantjoinurl);

        // Allow unregistered users to register.
        if (!$userisregistered) {
            $userisregistering = true;
        }
    }

    // If the meeting is not yet available, deny access.
    if (!$available && !$userisregistering) {
        // Get unavailability note.
        $returns['error'] = zoom_get_unavailability_note($zoom, $finished);
        return $returns;
    }

    $userisrealhost = (zoom_get_user_id(false) === $zoom->host_id);
    $alternativehosts = zoom_get_alternative_host_array_from_string($zoom->alternative_hosts);
    // Lowercase email addresses so that we can do case-insensitive comparisons.
    $userapiidentifier = zoom_get_api_identifier($USER);
    if (filter_var($userapiidentifier, FILTER_VALIDATE_EMAIL) !== false) {
        $userapiidentifier = strtolower($userapiidentifier);
    }
    $userishost = ($userisrealhost || in_array($userapiidentifier, $alternativehosts, true));

    // Check if we should use the start meeting url.
    if ($userisrealhost && $usestarturl) {
        // Important: Only the real host can use this URL, because it joins the meeting as the host user.
        $starturl = zoom_get_start_url($zoom->meeting_id, $zoom->webinar, $zoom->join_url);
        $returns['nexturl'] = new moodle_url($starturl);
    } else {
        $url = $zoom->join_url;
        if ($userisregistered) {
            $url = $registrantjoinurl;
        }

        $unamesetting = get_config('zoom', 'unamedisplay');
        switch ($unamesetting) {
            case 'fullname':
            default:
                $unamedisplay = fullname($USER);
                break;

            case 'firstname':
                $unamedisplay = $USER->firstname;
                break;

            case 'idfullname':
                $unamedisplay = '(' . $USER->id . ') ' . fullname($USER);
                break;

            case 'id':
                $unamedisplay = '(' . $USER->id . ')';
                break;
        }

        // Try to send the user email (not guaranteed).
        $returns['nexturl'] = new moodle_url($url, ['uname' => $unamedisplay, 'uemail' => $USER->email]);
    }

    // If the user is pre-registering, skip grading/completion.
    if (!$available && $userisregistering) {
        return $returns;
    }

    // Record user's clicking join.
    \mod_zoom\event\join_meeting_button_clicked::create([
        'context' => $context,
        'objectid' => $zoom->id,
        'other' => [
            'cmid' => $id,
            'meetingid' => (int) $zoom->meeting_id,
            'userishost' => $userishost,
        ],
    ])->trigger();

    // Track completion viewed.
    $completion = new completion_info($course);
    $completion->set_module_viewed($cm);

    // Check the grading method settings.
    if (!empty($zoom->grading_method)) {
        $gradingmethod = $zoom->grading_method;
    } else if ($defaultgrading = get_config('gradingmethod', 'zoom')) {
        $gradingmethod = $defaultgrading;
    } else {
        $gradingmethod = 'entry';
    }

    if ($gradingmethod === 'entry') {
        // Check whether user has a grade. If not, then assign full credit to them.
        $gradelist = grade_get_grades($course->id, 'mod', 'zoom', $cm->instance, $USER->id);

        // Assign full credits for user who has no grade yet, if this meeting is gradable (i.e. the grade type is not "None").
        if (!empty($gradelist->items) && empty($gradelist->items[0]->grades[$USER->id]->grade)) {
            $grademax = $gradelist->items[0]->grademax;
            $grades = [
                'rawgrade' => $grademax,
                'userid' => $USER->id,
                'usermodified' => $USER->id,
                'dategraded' => '',
                'feedbackformat' => '',
                'feedback' => '',
            ];

            zoom_grade_item_update($zoom, $grades);
        }
    } // Otherwise, the get_meetings_report task calculates the grades according to duration.

    // Upgrade host upon joining meeting, if host is not Licensed.
    if ($userishost) {
        $config = get_config('zoom');
        if (!empty($config->recycleonjoin)) {
            zoom_webservice()->provide_license($zoom->host_id);
        }
    }

    return $returns;
}

/**
 * Fetches a fresh URL that can be used to start the Zoom meeting.
 *
 * @param string $meetingid Zoom meeting ID.
 * @param bool $iswebinar If the session is a webinar.
 * @param string $fallbackurl URL to use if the webservice call fails.
 * @return string Best available URL for starting the meeting.
 */
function zoom_get_start_url($meetingid, $iswebinar, $fallbackurl) {
    try {
        $response = zoom_webservice()->get_meeting_webinar_info($meetingid, $iswebinar);
        return $response->start_url ?? $response->join_url;
    } catch (moodle_exception $e) {
        // If an exception was thrown, gracefully use the fallback URL.
        return $fallbackurl;
    }
}

/**
 * Get the configured Zoom tracking fields.
 *
 * @return array tracking fields, keys as lower case
 */
function zoom_list_tracking_fields() {
    $trackingfields = [];

    // Get the tracking fields configured on the account.
    $response = zoom_webservice()->list_tracking_fields();
    if (isset($response->tracking_fields)) {
        foreach ($response->tracking_fields as $trackingfield) {
            $field = str_replace(' ', '_', strtolower($trackingfield->field));
            $trackingfields[$field] = (array) $trackingfield;
        }
    }

    return $trackingfields;
}

/**
 * Trim and lower case tracking fields.
 *
 * @return array tracking fields trimmed, keys as lower case
 */
function zoom_clean_tracking_fields() {
    $config = get_config('zoom');
    $defaulttrackingfields = explode(',', $config->defaulttrackingfields);
    $trackingfields = [];

    foreach ($defaulttrackingfields as $key => $defaulttrackingfield) {
        $trimmed = trim($defaulttrackingfield);
        if (!empty($trimmed)) {
            $key = str_replace(' ', '_', strtolower($trimmed));
            $trackingfields[$key] = $trimmed;
        }
    }

    return $trackingfields;
}

/**
 * Synchronize tracking field data for a meeting.
 *
 * @param int $zoomid Zoom meeting ID
 * @param array $trackingfields Tracking fields configured in Zoom.
 */
function zoom_sync_meeting_tracking_fields($zoomid, $trackingfields) {
    global $DB;

    $tfvalues = [];
    foreach ($trackingfields as $trackingfield) {
        $field = str_replace(' ', '_', strtolower($trackingfield->field));
        $tfvalues[$field] = $trackingfield->value;
    }

    $tfrows = $DB->get_records('zoom_meeting_tracking_fields', ['meeting_id' => $zoomid]);
    $tfobjects = [];
    foreach ($tfrows as $tfrow) {
        $tfobjects[$tfrow->tracking_field] = $tfrow;
    }

    $defaulttrackingfields = zoom_clean_tracking_fields();
    foreach ($defaulttrackingfields as $key => $defaulttrackingfield) {
        $value = $tfvalues[$key] ?? '';
        if (isset($tfobjects[$key])) {
            $tfobject = $tfobjects[$key];
            if ($value === '') {
                $DB->delete_records('zoom_meeting_tracking_fields', ['meeting_id' => $zoomid, 'tracking_field' => $key]);
            } else if ($tfobject->value !== $value) {
                $tfobject->value = $value;
                $DB->update_record('zoom_meeting_tracking_fields', $tfobject);
            }
        } else if ($value !== '') {
            $tfobject = new stdClass();
            $tfobject->meeting_id = $zoomid;
            $tfobject->tracking_field = $key;
            $tfobject->value = $value;
            $DB->insert_record('zoom_meeting_tracking_fields', $tfobject);
        }
    }
}

/**
 * Get all meeting records
 *
 * @return array All zoom meetings stored in the database.
 */
function zoom_get_all_meeting_records() {
    global $DB;

    $meetings = [];
    // Only get meetings that exist on zoom.
    $records = $DB->get_records('zoom', ['exists_on_zoom' => ZOOM_MEETING_EXISTS]);
    foreach ($records as $record) {
        $meetings[] = $record;
    }

    return $meetings;
}

/**
 * Get all recordings for a particular meeting.
 *
 * @param int $zoomid Optional. The id of the zoom meeting.
 *
 * @return array All the recordings for the zoom meeting.
 */
function zoom_get_meeting_recordings($zoomid = null) {
    global $DB;

    $params = [];
    if ($zoomid !== null) {
        $params['zoomid'] = $zoomid;
    }

    $records = $DB->get_records('zoom_meeting_recordings', $params);
    $recordings = [];
    foreach ($records as $recording) {
        $recordings[$recording->zoomrecordingid] = $recording;
    }

    return $recordings;
}

/**
 * Get all meeting recordings grouped together.
 *
 * @param int $zoomid Optional. The id of the zoom meeting.
 *
 * @return array All recordings for the zoom meeting grouped together.
 */
function zoom_get_meeting_recordings_grouped($zoomid = null) {
    global $DB;

    $params = [];
    if ($zoomid !== null) {
        $params['zoomid'] = $zoomid;
    }

    $records = $DB->get_records('zoom_meeting_recordings', $params, 'recordingstart ASC');
    $recordings = [];
    foreach ($records as $recording) {
        $recordings[$recording->meetinguuid][$recording->zoomrecordingid] = $recording;
    }

    return $recordings;
}

/**
 * Singleton for Zoom webservice class.
 *
 * @return \mod_zoom\webservice
 */
function zoom_webservice() {
    static $service;

    if (empty($service)) {
        $service = new \mod_zoom\webservice();
    }

    return $service;
}

/**
 * Helper to get a Zoom user, efficiently.
 *
 * @param string|int $identifier The user's email or the user's ID per Zoom API.
 * @return stdClass|false If user is found, returns a Zoom user object. Otherwise, returns false.
 */
function zoom_get_user($identifier) {
    static $users = [];

    if (!isset($users[$identifier])) {
        $users[$identifier] = zoom_webservice()->get_user($identifier);
    }

    return $users[$identifier];
}

/**
 * Helper to get Zoom user settings, efficiently.
 *
 * @param string|int $identifier The user's email or the user's ID per Zoom API.
 * @return stdClass|false If user is found, returns a Zoom user object. Otherwise, returns false.
 */
function zoom_get_user_settings($identifier) {
    static $settings = [];

    if (!isset($settings[$identifier])) {
        $settings[$identifier] = zoom_webservice()->get_user_settings($identifier);
    }

    return $settings[$identifier];
}

/**
 * Get the zoom meeting registrants.
 *
 * @param string $meetingid Zoom meeting ID.
 * @param bool $iswebinar If the session is a webinar.
 * @return stdClass Returns a Zoom object containing the registrants (if found).
 */
function zoom_get_meeting_registrants($meetingid, $iswebinar) {
    $response = zoom_webservice()->get_meeting_registrants($meetingid, $iswebinar);
    return $response;
}

/**
 * Checks if a user has registered for a meeting/webinar based on their email address.
 *
 * @param string $useremail The email address of a user used to determine if they registered or not.
 * @param string $meetingid Zoom meeting ID.
 * @param bool $iswebinar If the session is a webinar.
 * @return bool Returns whether or not the user has registered for the zoom meeting/webinar based on their email address.
 */
function zoom_is_user_registered_for_meeting($useremail, $meetingid, $iswebinar) {
    $registrantjoinurl = zoom_get_registrant_join_url($useremail, $meetingid, $iswebinar);
    return !empty($registrantjoinurl);
}

/**
 * Get the join url for a user for the specified meeting/webinar.
 *
 * @param string $useremail The email address of a user used to determine if they registered or not.
 * @param string $meetingid Zoom meeting ID.
 * @param bool $iswebinar If the session is a webinar.
 * @return string|false Returns the join url for the user (based on email address) for the specified meeting (if found).
 */
function zoom_get_registrant_join_url($useremail, $meetingid, $iswebinar) {
    $response = zoom_get_meeting_registrants($meetingid, $iswebinar);
    if (isset($response->registrants)) {
        foreach ($response->registrants as $registrant) {
            if (strcasecmp($useremail, $registrant->email) == 0) {
                return $registrant->join_url;
            }
        }
    }

    return false;
}

/**
 * Get the display name for a Zoom user.
 * This is wrapped in a function to avoid unnecessary API calls.
 *
 * @param string $zoomuserid Zoom user ID.
 * @return ?string
 */
function zoom_get_user_display_name($zoomuserid) {
    try {
        $hostuser = zoom_get_user($zoomuserid);

        // Compose Moodle user object for host.
        $hostmoodleuser = new stdClass();
        $hostmoodleuser->firstname = $hostuser->first_name;
        $hostmoodleuser->lastname = $hostuser->last_name;
        $hostmoodleuser->alternatename = '';
        $hostmoodleuser->firstnamephonetic = '';
        $hostmoodleuser->lastnamephonetic = '';
        $hostmoodleuser->middlename = '';

        return fullname($hostmoodleuser);
    } catch (moodle_exception $error) {
        return null;
    }
}

====================

file: composer.json
path: composer.json
codice:
{
    "name": "ucla/moodle-mod_zoom",
    "type": "moodle-mod",
    "require": {
        "composer/installers": "~1.0"
    },
    "extra": {
        "installer-name": "zoom"
    }
}

====================

file: lib.php
path: lib.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Library of interface functions and constants for module zoom
 *
 * All the core Moodle functions, neeeded to allow the module to work
 * integrated in Moodle should be placed here.
 *
 * All the zoom specific functions, needed to implement all the module
 * logic, should go to locallib.php. This will help to save some memory when
 * Moodle is performing actions across all modules.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

/* Moodle core API */

/**
 * Returns the information on whether the module supports a feature.
 *
 * @param string $feature FEATURE_xx constant for requested feature
 * @return mixed true if the feature is supported, null if unknown
 */
function zoom_supports($feature) {
    // Adding support for FEATURE_MOD_PURPOSE (MDL-71457) and providing backward compatibility (pre-v4.0).
    if (defined('FEATURE_MOD_PURPOSE') && $feature === FEATURE_MOD_PURPOSE) {
        return MOD_PURPOSE_COMMUNICATION;
    }

    switch ($feature) {
        case FEATURE_BACKUP_MOODLE2:
        case FEATURE_COMPLETION_TRACKS_VIEWS:
        case FEATURE_GRADE_HAS_GRADE:
        case FEATURE_GROUPINGS:
        case FEATURE_GROUPMEMBERSONLY:
        case FEATURE_MOD_INTRO:
        case FEATURE_SHOW_DESCRIPTION:
            return true;
        default:
            return null;
    }
}

/**
 * Saves a new instance of the zoom object into the database.
 *
 * Given an object containing all the necessary data (defined by the form in mod_form.php), this function
 * will create a new instance and return the id number of the new instance.
 *
 * @param stdClass $zoom Submitted data from the form in mod_form.php
 * @param mod_zoom_mod_form|null $mform The form instance (included because the function is used as a callback)
 * @return int The id of the newly inserted zoom record
 */
function zoom_add_instance(stdClass $zoom, ?mod_zoom_mod_form $mform = null) {
    global $CFG, $DB;
    require_once($CFG->dirroot . '/mod/zoom/locallib.php');

    if (defined('PHPUNIT_TEST') && PHPUNIT_TEST) {
        $zoom->id = $DB->insert_record('zoom', $zoom);
        zoom_grade_item_update($zoom);
        zoom_calendar_item_update($zoom);
        return $zoom->id;
    }

    // Deals with password manager issues.
    $zoom->password = $zoom->meetingcode;
    unset($zoom->meetingcode);

    if (empty($zoom->requirepasscode)) {
        $zoom->password = '';
    }

    // Handle weekdays if weekly recurring meeting selected.
    if ($zoom->recurring && $zoom->recurrence_type == ZOOM_RECURRINGTYPE_WEEKLY) {
        $zoom->weekly_days = zoom_handle_weekly_days($zoom);
    }

    $zoom->course = (int) $zoom->course;

    $zoom->breakoutrooms = [];
    if (!empty($zoom->rooms)) {
        $breakoutrooms = zoom_build_instance_breakout_rooms_array_for_api($zoom);
        $zoom->breakoutrooms = $breakoutrooms['zoom'];
    }

    $response = zoom_webservice()->create_meeting($zoom, $zoom->coursemodule);
    $zoom = populate_zoom_from_response($zoom, $response);
    $zoom->timemodified = time();
    if (!empty($zoom->schedule_for)) {
        // Wait until after receiving a successful response from zoom to update the host
        // based on the schedule_for field. Zoom handles the schedule for on their
        // end, but returns the host as the person who created the meeting, not the person
        // that it was scheduled for.
        $correcthostzoomuser = zoom_get_user($zoom->schedule_for);
        $zoom->host_id = $correcthostzoomuser->id;
    }

    if (isset($zoom->recurring) && isset($response->occurrences) && empty($response->occurrences)) {
        // Recurring meetings did not create any occurrencces.
        // This means invalid options selected.
        // Need to rollback created meeting.
        zoom_webservice()->delete_meeting($zoom->meeting_id, $zoom->webinar);

        $redirecturl = new moodle_url('/course/view.php', ['id' => $zoom->course]);
        throw new moodle_exception('erroraddinstance', 'zoom', $redirecturl->out());
    }

    $zoom->id = $DB->insert_record('zoom', $zoom);
    if (!empty($zoom->breakoutrooms)) {
        // We ignore the API response and save the local data for breakout rooms to support dynamic users and groups.
        zoom_insert_instance_breakout_rooms($zoom->id, $breakoutrooms['db']);
    }

    // Store tracking field data for meeting.
    zoom_sync_meeting_tracking_fields($zoom->id, $response->tracking_fields ?? []);

    zoom_calendar_item_update($zoom);
    zoom_grade_item_update($zoom);

    return $zoom->id;
}

/**
 * Updates an instance of the zoom in the database and on Zoom servers.
 *
 * Given an object containing all the necessary data (defined by the form in mod_form.php), this function
 * will update an existing instance with new data.
 *
 * @param stdClass $zoom An object from the form in mod_form.php
 * @param mod_zoom_mod_form|null $mform The form instance (included because the function is used as a callback)
 * @return boolean Success/Failure
 */
function zoom_update_instance(stdClass $zoom, ?mod_zoom_mod_form $mform = null) {
    global $CFG, $DB;
    require_once($CFG->dirroot . '/mod/zoom/locallib.php');

    // The object received from mod_form.php returns instance instead of id for some reason.
    if (isset($zoom->instance)) {
        $zoom->id = $zoom->instance;
    }

    $zoom->timemodified = time();

    // Deals with password manager issues.
    if (isset($zoom->meetingcode)) {
        $zoom->password = $zoom->meetingcode;
        unset($zoom->meetingcode);
    }

    if (property_exists($zoom, 'requirepasscode') && empty($zoom->requirepasscode)) {
        $zoom->password = '';
    }

    // Handle weekdays if weekly recurring meeting selected.
    if ($zoom->recurring && $zoom->recurrence_type == ZOOM_RECURRINGTYPE_WEEKLY) {
        $zoom->weekly_days = zoom_handle_weekly_days($zoom);
    }

    $DB->update_record('zoom', $zoom);

    $zoom->breakoutrooms = [];
    if (!empty($zoom->rooms)) {
        $breakoutrooms = zoom_build_instance_breakout_rooms_array_for_api($zoom);
        zoom_update_instance_breakout_rooms($zoom->id, $breakoutrooms['db']);
        $zoom->breakoutrooms = $breakoutrooms['zoom'];
    }

    $updatedzoomrecord = $DB->get_record('zoom', ['id' => $zoom->id]);
    $zoom->meeting_id = $updatedzoomrecord->meeting_id;
    $zoom->webinar = $updatedzoomrecord->webinar;

    // Update meeting on Zoom.
    try {
        zoom_webservice()->update_meeting($zoom, $zoom->coursemodule);
        if (!empty($zoom->schedule_for)) {
            // Only update this if we actually get a valid user.
            if ($correcthostzoomuser = zoom_get_user($zoom->schedule_for)) {
                $zoom->host_id = $correcthostzoomuser->id;
                $DB->update_record('zoom', $zoom);
            }
        }
    } catch (moodle_exception $error) {
        if (isset($mform)) {
            throw $error;
        } else {
            return false;
        }
    }

    // Get the updated meeting info from zoom, before updating calendar events.
    $response = zoom_webservice()->get_meeting_webinar_info($zoom->meeting_id, $zoom->webinar);
    $zoom = populate_zoom_from_response($zoom, $response);
    $DB->update_record('zoom', $zoom);

    // Update tracking field data for meeting.
    zoom_sync_meeting_tracking_fields($zoom->id, $response->tracking_fields ?? []);

    zoom_calendar_item_update($zoom);
    zoom_grade_item_update($zoom);

    return true;
}

/**
 * Function to handle selected weekdays, for recurring weekly meeting.
 *
 * @param stdClass $zoom The zoom instance
 * @return string The comma separated string for selected weekdays
 */
function zoom_handle_weekly_days($zoom) {
    $weekdaynumbers = [];
    for ($i = 1; $i <= 7; $i++) {
        $key = 'weekly_days_' . $i;
        if (!empty($zoom->$key)) {
            $weekdaynumbers[] = $i;
        }
    }

    return implode(',', $weekdaynumbers);
}

/**
 * Function to unset the weekly options in postprocessing.
 *
 * @param stdClass $data The form data object
 * @return stdClass $data The form data object minus weekly options.
 */
function zoom_remove_weekly_options($data) {
    // Unset the weekly_days options.
    for ($i = 1; $i <= 7; $i++) {
        $key = 'weekly_days_' . $i;
        unset($data->$key);
    }

    return $data;
}

/**
 * Function to unset the monthly options in postprocessing.
 *
 * @param stdClass $data The form data object
 * @return stdClass $data The form data object minus monthly options.
 */
function zoom_remove_monthly_options($data) {
    // Unset the monthly options.
    unset($data->monthly_repeat_option);
    unset($data->monthly_day);
    unset($data->monthly_week);
    unset($data->monthly_week_day);
    return $data;
}

/**
 * Populates a zoom meeting or webinar from a response object.
 *
 * Given a zoom meeting object from mod_form.php, this function uses the response to repopulate some of the object properties.
 *
 * @param stdClass $zoom An object from the form in mod_form.php
 * @param stdClass $response A response from an API call like 'create meeting' or 'update meeting'
 * @return stdClass A $zoom object ready to be added to the database.
 */
function populate_zoom_from_response(stdClass $zoom, stdClass $response) {
    global $CFG;
    // Inlcuded for constants.
    require_once($CFG->dirroot . '/mod/zoom/locallib.php');

    $newzoom = clone $zoom;

    $samefields = ['join_url', 'created_at', 'timezone'];
    foreach ($samefields as $field) {
        if (isset($response->$field)) {
            $newzoom->$field = $response->$field;
        }
    }

    if (isset($response->duration)) {
        $newzoom->duration = $response->duration * 60;
    }

    $newzoom->meeting_id = $response->id;
    // Need to get the meeting name from API call for comparison in the refresh_events function.
    $newzoom->apiresponsename = $response->topic;
    if (isset($response->start_time)) {
        $newzoom->start_time = strtotime($response->start_time);
    }

    $recurringtypes = [
        ZOOM_RECURRING_MEETING,
        ZOOM_RECURRING_FIXED_MEETING,
        ZOOM_RECURRING_WEBINAR,
        ZOOM_RECURRING_FIXED_WEBINAR,
    ];
    $newzoom->recurring = in_array($response->type, $recurringtypes);
    if (!empty($response->occurrences)) {
        $newzoom->occurrences = [];
        // Normalise the occurrence times.
        foreach ($response->occurrences as $occurrence) {
            $occurrence->start_time = strtotime($occurrence->start_time);
            $occurrence->duration = $occurrence->duration * 60;
            $newzoom->occurrences[] = $occurrence;
        }
    }

    if (isset($response->password)) {
        $newzoom->password = $response->password;
    }

    if (isset($response->settings->encryption_type)) {
        $newzoom->option_encryption_type = $response->settings->encryption_type;
    }

    if (isset($response->settings->join_before_host)) {
        $newzoom->option_jbh = $response->settings->join_before_host;
    }

    if (isset($response->settings->participant_video)) {
        $newzoom->option_participants_video = $response->settings->participant_video;
    }

    if (isset($response->settings->alternative_hosts)) {
        $newzoom->alternative_hosts = $response->settings->alternative_hosts;
    }

    if (isset($response->settings->mute_upon_entry)) {
        $newzoom->option_mute_upon_entry = $response->settings->mute_upon_entry;
    }

    if (isset($response->settings->meeting_authentication)) {
        $newzoom->option_authenticated_users = $response->settings->meeting_authentication;
    }

    if (isset($response->settings->waiting_room)) {
        $newzoom->option_waiting_room = $response->settings->waiting_room;
    }

    if (isset($response->settings->auto_recording)) {
        $newzoom->option_auto_recording = $response->settings->auto_recording;
    }

    return $newzoom;
}

/**
 * Removes an instance of the zoom from the database
 *
 * Given an ID of an instance of this module, this function will permanently delete the instance and any data that depends on it.
 *
 * @param int $id Id of the module instance
 * @return boolean Success/Failure
 * @throws moodle_exception if failed to delete and zoom did not issue a not found error
 */
function zoom_delete_instance($id) {
    global $CFG, $DB;
    require_once($CFG->dirroot . '/mod/zoom/locallib.php');

    if (!$zoom = $DB->get_record('zoom', ['id' => $id])) {
        // For some reason already deleted, so let Moodle take care of the rest.
        return true;
    }

    // If the meeting is missing from zoom, don't bother with the webservice.
    if ($zoom->exists_on_zoom == ZOOM_MEETING_EXISTS) {
        try {
            zoom_webservice()->delete_meeting($zoom->meeting_id, $zoom->webinar);
        } catch (\mod_zoom\not_found_exception $error) {
            // Meeting not on Zoom, so continue.
            mtrace('Meeting not on Zoom; continuing');
        }
    }

    // If we delete a meeting instance, do we want to delete the participants?
    $meetinginstances = $DB->get_records('zoom_meeting_details', ['zoomid' => $zoom->id]);
    foreach ($meetinginstances as $meetinginstance) {
        $DB->delete_records('zoom_meeting_participants', ['detailsid' => $meetinginstance->id]);
    }

    $DB->delete_records('zoom_meeting_details', ['zoomid' => $zoom->id]);

    // Delete tracking field data for deleted meetings.
    $DB->delete_records('zoom_meeting_tracking_fields', ['meeting_id' => $zoom->id]);

    // Delete any dependent records here.
    zoom_calendar_item_delete($zoom);
    zoom_grade_item_delete($zoom);

    $DB->delete_records('zoom', ['id' => $zoom->id]);

    // Delete breakout rooms.
    zoom_delete_instance_breakout_rooms($zoom->id);

    return true;
}

/**
 * Callback function to update the Zoom event in the database and on Zoom servers.
 *
 * The function is triggered when the course module name is set via quick edit.
 *
 * @param int $courseid
 * @param stdClass $zoom Zoom Module instance object.
 * @param stdClass $cm Course Module object.
 * @return bool
 */
function zoom_refresh_events($courseid, $zoom, $cm) {
    global $CFG;

    require_once($CFG->dirroot . '/mod/zoom/locallib.php');

    try {
        // Get the updated meeting info from zoom, before updating calendar events.
        $response = zoom_webservice()->get_meeting_webinar_info($zoom->meeting_id, $zoom->webinar);
        $fullzoom = populate_zoom_from_response($zoom, $response);

        // Only if the name has changed, update meeting on Zoom.
        // Before comparing, need to apply filter on the name if applicable.
        $options = [];
        $options['context'] = \context_module::instance($cm->id);
        if (zoom_apply_filter_on_meeting_name($zoom->name, $options) !== $fullzoom->apiresponsename) {
            zoom_webservice()->update_meeting($zoom, $cm->id);
        }

        zoom_calendar_item_update($fullzoom);
        zoom_grade_item_update($fullzoom);
    } catch (moodle_exception $error) {
        return false;
    }

    return true;
}

/**
 * Given a course and a time, this module should find recent activity that has occurred in zoom activities and print it out.
 *
 * @param stdClass $course The course record
 * @param bool $viewfullnames Should we display full names
 * @param int $timestart Print activity since this timestamp
 * @return boolean True if anything was printed, otherwise false
 */
function zoom_print_recent_activity($course, $viewfullnames, $timestart) {
    return false;
}

/**
 * Prepares the recent activity data
 *
 * This callback function is supposed to populate the passed array with
 * custom activity records. These records are then rendered into HTML
 * zoom_print_recent_mod_activity().
 *
 * Returns void, it adds items into $activities and increases $index.
 *
 * @param array $activities sequentially indexed array of objects with added 'cmid' property
 * @param int $index the index in the $activities to use for the next record
 * @param int $timestart append activity since this time
 * @param int $courseid the id of the course we produce the report for
 * @param int $cmid course module id
 * @param int $userid check for a particular user's activity only, defaults to 0 (all users)
 * @param int $groupid check for a particular group's activity only, defaults to 0 (all groups)
 */
function zoom_get_recent_mod_activity(&$activities, &$index, $timestart, $courseid, $cmid, $userid = 0, $groupid = 0) {
}

/**
 * Prints single activity item prepared by zoom_get_recent_mod_activity()
 *
 * @param stdClass $activity activity record with added 'cmid' property
 * @param int $courseid the id of the course we produce the report for
 * @param bool $detail print detailed report
 * @param array $modnames as returned by get_module_types_names()
 * @param bool $viewfullnames display users' full names
 */
function zoom_print_recent_mod_activity($activity, $courseid, $detail, $modnames, $viewfullnames) {
}

/**
 * Returns all other caps used in the module
 *
 * For example, this could be array('moodle/site:accessallgroups') if the
 * module uses that capability.
 *
 * @return array
 */
function zoom_get_extra_capabilities() {
    return [];
}

/**
 * Create or update Moodle calendar event of the Zoom instance.
 *
 * @param stdClass $zoom
 */
function zoom_calendar_item_update(stdClass $zoom) {
    global $CFG, $DB;
    require_once($CFG->dirroot . '/calendar/lib.php');

    // Based on data passed back from zoom, create/update/delete events based on data.
    $newevents = [];
    if (!$zoom->recurring) {
        $newevents[''] = zoom_populate_calender_item($zoom);
    } else if (!empty($zoom->occurrences)) {
        foreach ($zoom->occurrences as $occurrence) {
            $uuid = $occurrence->occurrence_id;
            if ($occurrence->status !== 'deleted') {
                $newevents[$uuid] = zoom_populate_calender_item($zoom, $occurrence);
            }
        }
    }

    // Fetch all the events related to this zoom instance.
    $conditions = [
        'modulename' => 'zoom',
        'instance' => $zoom->id,
    ];
    $events = $DB->get_records('event', $conditions);
    $eventfields = ['name', 'timestart', 'timeduration'];
    foreach ($events as $event) {
        $uuid = $event->uuid;
        if (isset($newevents[$uuid])) {
            // This event already exists in Moodle.
            $changed = false;
            $newevent = $newevents[$uuid];
            // Check if the important fields have actually changed.
            foreach ($eventfields as $field) {
                if ($newevent->$field !== $event->$field) {
                    $changed = true;
                }
            }

            if ($changed) {
                calendar_event::load($event)->update($newevent);
            }

            // Event has been updated, remove from the list.
            unset($newevents[$uuid]);
        } else {
            // Event does not exist in Zoom, so delete from Moodle.
            calendar_event::load($event)->delete();
        }
    }

    // Any remaining events in the array don't exist on Moodle, so create a new event.
    foreach ($newevents as $uuid => $newevent) {
        calendar_event::create($newevent, false);
    }
}

/**
 * Return an array with the days of the week.
 *
 * @return array
 */
function zoom_get_weekday_options() {
    return [
        1 => get_string('sunday', 'calendar'),
        2 => get_string('monday', 'calendar'),
        3 => get_string('tuesday', 'calendar'),
        4 => get_string('wednesday', 'calendar'),
        5 => get_string('thursday', 'calendar'),
        6 => get_string('friday', 'calendar'),
        7 => get_string('saturday', 'calendar'),
    ];
}

/**
 * Return an array with the weeks of the month.
 *
 * @return array
 */
function zoom_get_monthweek_options() {
    return [
        1 => get_string('weekoption_first', 'zoom'),
        2 => get_string('weekoption_second', 'zoom'),
        3 => get_string('weekoption_third', 'zoom'),
        4 => get_string('weekoption_fourth', 'zoom'),
        -1 => get_string('weekoption_last', 'zoom'),
    ];
}

/**
 * Populate the calendar event object, based on the zoom instance
 *
 * @param stdClass $zoom The zoom instance.
 * @param stdClass|null $occurrence The occurrence object passed from the zoom api.
 * @return stdClass The calendar event object.
 */
function zoom_populate_calender_item(stdClass $zoom, ?stdClass $occurrence = null) {
    $event = new stdClass();
    $event->type = CALENDAR_EVENT_TYPE_ACTION;
    $event->modulename = 'zoom';
    $event->eventtype = 'zoom';
    $event->courseid = $zoom->course;
    $event->instance = $zoom->id;
    $event->visible = true;
    $event->name = $zoom->name;
    if ($zoom->intro) {
        $event->description = $zoom->intro;
        $event->format = $zoom->introformat;
    }

    if (!$occurrence) {
        $event->timesort = $zoom->start_time;
        $event->timestart = $zoom->start_time;
        $event->timeduration = $zoom->duration;
    } else {
        $event->timesort = $occurrence->start_time;
        $event->timestart = $occurrence->start_time;
        $event->timeduration = $occurrence->duration;
        $event->uuid = $occurrence->occurrence_id;
    }

    // Recurring meetings/webinars with no fixed time are created as invisible events.
    // For recurring meetings/webinars with a fixed time, we want to see the events on the calendar.
    if ($zoom->recurring && $zoom->recurrence_type == ZOOM_RECURRINGTYPE_NOTIME) {
        $event->visible = false;
    }

    return $event;
}

/**
 * Delete Moodle calendar events of the Zoom instance.
 *
 * @param stdClass $zoom
 */
function zoom_calendar_item_delete(stdClass $zoom) {
    global $CFG, $DB;
    require_once($CFG->dirroot . '/calendar/lib.php');

    $events = $DB->get_records('event', [
        'modulename' => 'zoom',
        'instance' => $zoom->id,
    ]);
    foreach ($events as $event) {
        calendar_event::load($event)->delete();
    }
}

/**
 * This function receives a calendar event and returns the action associated with it, or null if there is none.
 *
 * This is used by block_myoverview in order to display the event appropriately. If null is returned then the event
 * is not displayed on the block.
 *
 * @param calendar_event $event
 * @param \core_calendar\action_factory $factory
 * @param int $userid User id override
 * @return \core_calendar\local\event\entities\action_interface|null
 */
function mod_zoom_core_calendar_provide_event_action(
    calendar_event $event,
    \core_calendar\action_factory $factory,
    $userid = null
) {
    global $CFG, $DB, $USER;

    require_once($CFG->dirroot . '/mod/zoom/locallib.php');

    if (empty($userid)) {
        $userid = $USER->id;
    }

    $cm = get_fast_modinfo($event->courseid, $userid)->instances['zoom'][$event->instance];
    $zoom = $DB->get_record('zoom', ['id' => $cm->instance], '*');
    [$inprogress, $available, $finished] = zoom_get_state($zoom);

    if ($finished) {
        return null; // No point to showing finished meetings in overview.
    } else {
        return $factory->create_instance(
            get_string('join_meeting', 'zoom'),
            new \moodle_url('/mod/zoom/view.php', ['id' => $cm->id]),
            1,
            $available
        );
    }
}

/* Gradebook API */

/**
 * Checks if scale is being used by any instance of zoom.
 *
 * This is used to find out if scale used anywhere.
 *
 * @param int $scaleid ID of the scale
 * @return boolean true if the scale is used by any zoom instance
 */
function zoom_scale_used_anywhere($scaleid) {
    global $DB;

    if ($scaleid && $DB->record_exists('zoom', ['grade' => -$scaleid])) {
        return true;
    } else {
        return false;
    }
}

/**
 * Creates or updates grade item for the given zoom instance
 *
 * Needed by grade_update_mod_grades().
 *
 * @param stdClass $zoom instance object with extra cmidnumber and modname property
 * @param array $grades optional array/object of grade(s); 'reset' means reset grades in gradebook
 * @return void
 */
function zoom_grade_item_update(stdClass $zoom, $grades = null) {
    global $CFG;
    require_once($CFG->libdir . '/gradelib.php');

    $item = [];
    $item['itemname'] = clean_param($zoom->name, PARAM_NOTAGS);
    $item['gradetype'] = GRADE_TYPE_VALUE;

    if ($zoom->grade > 0) {
        $item['gradetype'] = GRADE_TYPE_VALUE;
        $item['grademax'] = $zoom->grade;
        $item['grademin'] = 0;
    } else if ($zoom->grade < 0) {
        $item['gradetype'] = GRADE_TYPE_SCALE;
        $item['scaleid'] = -$zoom->grade;
    } else {
        $gradebook = grade_get_grades($zoom->course, 'mod', 'zoom', $zoom->id);
        // Prevent the gradetype from switching to None if grades exist.
        if (empty($gradebook->items[0]->grades)) {
            $item['gradetype'] = GRADE_TYPE_NONE;
        } else {
            return;
        }
    }

    if ($grades === 'reset') {
        $item['reset'] = true;
        $grades = null;
    }

    grade_update('mod/zoom', $zoom->course, 'mod', 'zoom', $zoom->id, 0, $grades, $item);
}

/**
 * Delete grade item for given zoom instance
 *
 * @param stdClass $zoom instance object
 * @return int
 */
function zoom_grade_item_delete($zoom) {
    global $CFG;
    require_once($CFG->libdir . '/gradelib.php');

    return grade_update('mod/zoom', $zoom->course, 'mod', 'zoom', $zoom->id, 0, null, ['deleted' => 1]);
}

/**
 * Update zoom grades in the gradebook
 *
 * Needed by grade_update_mod_grades().
 *
 * @param stdClass $zoom instance object with extra cmidnumber and modname property
 * @param int $userid update grade of specific user only, 0 means all participants
 */
function zoom_update_grades(stdClass $zoom, $userid = 0) {
    global $CFG;
    require_once($CFG->libdir . '/gradelib.php');

    // Populate array of grade objects indexed by userid.
    if ($zoom->grade == 0) {
        zoom_grade_item_update($zoom);
    } else if ($userid != 0) {
        $grade = grade_get_grades($zoom->course, 'mod', 'zoom', $zoom->id, $userid)->items[0]->grades[$userid];
        $grade->userid = $userid;
        if ($grade->grade == -1) {
            $grade->grade = null;
        }

        zoom_grade_item_update($zoom, $grade);
    } else if ($userid == 0) {
        $context = context_course::instance($zoom->course);
        $enrollusersid = array_keys(get_enrolled_users($context));
        $grades = grade_get_grades($zoom->course, 'mod', 'zoom', $zoom->id, $enrollusersid)->items[0]->grades;
        foreach ($grades as $k => $v) {
            $grades[$k]->userid = $k;
            if ($v->grade == -1) {
                $grades[$k]->grade = null;
            }
        }

        zoom_grade_item_update($zoom, $grades);
    } else {
        zoom_grade_item_update($zoom);
    }
}


/**
 * Removes all zoom grades from gradebook by course id
 *
 * @param int $courseid
 */
function zoom_reset_gradebook($courseid) {
    global $DB;

    $params = [$courseid];

    $sql = "SELECT z.*, cm.idnumber as cmidnumber, z.course as courseid
          FROM {zoom} z
          JOIN {course_modules} cm ON cm.instance = z.id
          JOIN {modules} m ON m.id = cm.module AND m.name = 'zoom'
         WHERE z.course = ?";

    if ($zooms = $DB->get_records_sql($sql, $params)) {
        foreach ($zooms as $zoom) {
            zoom_grade_item_update($zoom, 'reset');
        }
    }
}

/**
 * This function is used by the reset_course_userdata function in moodlelib.
 * This function will remove all user data from zoom activites
 * and clean up any related data.
 *
 * @param object $data the data submitted from the reset course.
 * @return array status array
 */
function zoom_reset_userdata($data) {
    global $CFG, $DB;

    $componentstr = get_string('modulenameplural', 'zoom');
    $status = [];

    if (!empty($data->reset_zoom_all)) {
        // Reset tables that record user data.
        $DB->delete_records_select(
            'zoom_meeting_participants',
            'detailsid IN (SELECT zmd.id
                             FROM {zoom_meeting_details} zmd
                             JOIN {zoom} z ON z.id = zmd.zoomid
                            WHERE z.course = ?)',
            [$data->courseid]
        );
        $status[] = [
            'component' => $componentstr,
            'item' => get_string('meetingparticipantsdeleted', 'zoom'),
            'error' => false,
        ];

        $DB->delete_records_select(
            'zoom_meeting_recordings_view',
            'recordingsid IN (SELECT zmr.id
                             FROM {zoom_meeting_recordings} zmr
                             JOIN {zoom} z ON z.id = zmr.zoomid
                            WHERE z.course = ?)',
            [$data->courseid]
        );
        $status[] = [
            'component' => $componentstr,
            'item' => get_string('meetingrecordingviewsdeleted', 'zoom'),
            'error' => false,
        ];
    }

    return $status;
}

/**
 * Called by course/reset.php
 *
 * @param object $mform the course reset form that is being built.
 */
function zoom_reset_course_form_definition($mform) {
    $mform->addElement('header', 'zoomheader', get_string('modulenameplural', 'zoom'));

    $mform->addElement('checkbox', 'reset_zoom_all', get_string('resetzoomsall', 'zoom'));
}

/**
 * Course reset form defaults.
 *
 * @param object $course data passed by the form.
 * @return array the defaults.
 */
function zoom_reset_course_form_defaults($course) {
    return ['reset_zoom_all' => 1];
}

/* File API */

/**
 * Returns the lists of all browsable file areas within the given module context
 *
 * The file area 'intro' for the activity introduction field is added automatically
 * by file_browser::get_file_info_context_module()
 *
 * @param stdClass $course
 * @param stdClass $cm
 * @param stdClass $context
 * @return array of [(string)filearea] => (string)description
 */
function zoom_get_file_areas($course, $cm, $context) {
    return [];
}

/**
 * File browsing support for zoom file areas
 *
 * @package mod_zoom
 * @category files
 *
 * @param file_browser $browser
 * @param array $areas
 * @param stdClass $course
 * @param stdClass $cm
 * @param stdClass $context
 * @param string $filearea
 * @param int $itemid
 * @param string $filepath
 * @param string $filename
 * @return file_info instance or null if not found
 */
function zoom_get_file_info($browser, $areas, $course, $cm, $context, $filearea, $itemid, $filepath, $filename) {
    return null;
}

/**
 * Serves the files from the zoom file areas
 *
 * @package mod_zoom
 * @category files
 *
 * @param stdClass $course the course object
 * @param stdClass $cm the course module object
 * @param stdClass $context the zoom's context
 * @param string $filearea the name of the file area
 * @param array $args extra arguments (itemid, path)
 * @param bool $forcedownload whether or not force download
 * @param array $options additional options affecting the file serving
 */
function zoom_pluginfile($course, $cm, $context, $filearea, array $args, $forcedownload, array $options = []) {
    if ($context->contextlevel != CONTEXT_MODULE) {
        send_file_not_found();
    }

    require_login($course, true, $cm);

    send_file_not_found();
}

/* Navigation API */

/**
 * Extends the global navigation tree by adding zoom nodes if there is a relevant content
 *
 * This can be called by an AJAX request so do not rely on $PAGE as it might not be set up properly.
 *
 * @param navigation_node $navref An object representing the navigation tree node of the zoom module instance
 * @param stdClass $course current course record
 * @param stdClass $module current zoom instance record
 * @param cm_info $cm course module information
 */
function zoom_extend_navigation(navigation_node $navref, stdClass $course, stdClass $module, cm_info $cm) {
}

/**
 * Extends the settings navigation with the zoom settings
 *
 * This function is called when the context for the page is a zoom module. This is not called by AJAX
 * so it is safe to rely on the $PAGE.
 *
 * @param settings_navigation $settingsnav complete settings navigation tree
 * @param navigation_node|null $zoomnode zoom administration node
 */
function zoom_extend_settings_navigation(settings_navigation $settingsnav, ?navigation_node $zoomnode = null) {
}

/**
 * Get icon mapping for font-awesome.
 *
 * @see https://docs.moodle.org/dev/Moodle_icons
 */
function mod_zoom_get_fontawesome_icon_map() {
    return [
        'mod_zoom:i/calendar' => 'fa-calendar',
    ];
}

/**
 * This function updates the tracking field settings in config_plugins.
 */
function mod_zoom_update_tracking_fields() {
    global $DB;

    try {
        $defaulttrackingfields = zoom_clean_tracking_fields();
        $zoomprops = ['id', 'field', 'required', 'visible', 'recommended_values'];
        $confignames = [];

        if (!empty($defaulttrackingfields)) {
            $zoomtrackingfields = zoom_list_tracking_fields();
            foreach ($zoomtrackingfields as $field => $zoomtrackingfield) {
                if (isset($defaulttrackingfields[$field])) {
                    foreach ($zoomprops as $zoomprop) {
                        $configname = 'tf_' . $field . '_' . $zoomprop;
                        $confignames[] = $configname;
                        if ($zoomprop === 'recommended_values') {
                            $configvalue = implode(', ', $zoomtrackingfield[$zoomprop]);
                        } else {
                            $configvalue = $zoomtrackingfield[$zoomprop];
                        }

                        set_config($configname, $configvalue, 'zoom');
                    }
                }
            }
        }

        $config = get_config('zoom');
        $proparray = get_object_vars($config);
        $properties = array_keys($proparray);
        $oldconfigs = array_diff($properties, $confignames);
        $pattern = '/^tf_(?P<oldfield>.*)_(' . implode('|', $zoomprops) . ')$/';
        foreach ($oldconfigs as $oldconfig) {
            if (preg_match($pattern, $oldconfig, $matches)) {
                set_config($oldconfig, null, 'zoom');
                $DB->delete_records('zoom_meeting_tracking_fields', ['tracking_field' => $matches['oldfield']]);
            }
        }
    } catch (Exception $e) {
        // Fail gracefully because the callback function might be called directly.
        return false;
    }

    return true;
}

/**
 * Insert zoom instance breakout rooms
 *
 * @param int $zoomid
 * @param array $breakoutrooms zoom breakout rooms
 */
function zoom_insert_instance_breakout_rooms($zoomid, $breakoutrooms) {
    global $DB;

    foreach ($breakoutrooms as $breakoutroom) {
        $item = new stdClass();
        $item->name = $breakoutroom['name'];
        $item->zoomid = $zoomid;

        $breakoutroomid = $DB->insert_record('zoom_meeting_breakout_rooms', $item);

        foreach ($breakoutroom['participants'] as $participant) {
            $item = new stdClass();
            $item->userid = $participant;
            $item->breakoutroomid = $breakoutroomid;
            $DB->insert_record('zoom_breakout_participants', $item);
        }

        foreach ($breakoutroom['groups'] as $group) {
            $item = new stdClass();
            $item->groupid = $group;
            $item->breakoutroomid = $breakoutroomid;
            $DB->insert_record('zoom_breakout_groups', $item);
        }
    }
}

/**
 * Update zoom instance breakout rooms
 *
 * @param int $zoomid
 * @param array $breakoutrooms
 */
function zoom_update_instance_breakout_rooms($zoomid, $breakoutrooms) {
    global $DB;

    zoom_delete_instance_breakout_rooms($zoomid);
    zoom_insert_instance_breakout_rooms($zoomid, $breakoutrooms);
}

/**
 * Delete zoom instance breakout rooms
 *
 * @param int $zoomid
 */
function zoom_delete_instance_breakout_rooms($zoomid) {
    global $DB;

    $zoomcurrentbreakoutroomsids = $DB->get_fieldset_select('zoom_meeting_breakout_rooms', 'id', "zoomid = {$zoomid}");

    foreach ($zoomcurrentbreakoutroomsids as $id) {
        $DB->delete_records('zoom_breakout_participants', ['breakoutroomid' => $id]);
        $DB->delete_records('zoom_breakout_groups', ['breakoutroomid' => $id]);
    }

    $DB->delete_records('zoom_meeting_breakout_rooms', ['zoomid' => $zoomid]);
}

/**
 * Build zoom instance breakout rooms array for api
 *
 * @param stdClass $zoom Submitted data from the form in mod_form.php.
 * @return array The meeting breakout rooms array.
 */
function zoom_build_instance_breakout_rooms_array_for_api($zoom) {
    $context = context_course::instance($zoom->course);
    $users = get_enrolled_users($context);
    $groups = groups_get_all_groups($zoom->course);

    // Building meeting breakout rooms array.
    $breakoutrooms = [];
    if (!empty($zoom->rooms)) {
        foreach ($zoom->rooms as $roomid => $roomname) {
            // Getting meeting rooms participants.
            $roomparticipants = [];
            $dbroomparticipants = [];
            if (!empty($zoom->roomsparticipants[$roomid])) {
                foreach ($zoom->roomsparticipants[$roomid] as $participantid) {
                    if (isset($users[$participantid])) {
                        $roomparticipants[] = $users[$participantid]->email;
                        $dbroomparticipants[] = $participantid;
                    }
                }
            }

            // Getting meeting rooms groups members.
            $roomgroupsmembers = [];
            $dbroomgroupsmembers = [];
            if (!empty($zoom->roomsgroups[$roomid])) {
                foreach ($zoom->roomsgroups[$roomid] as $groupid) {
                    if (isset($groups[$groupid])) {
                        $groupmembers = groups_get_members($groupid);
                        $roomgroupsmembers[] = array_column(array_values($groupmembers), 'email');
                        $dbroomgroupsmembers[] = $groupid;
                    }
                }

                $roomgroupsmembers = array_merge(...$roomgroupsmembers);
            }

            $zoomdata = [
                'name' => $roomname,
                'participants' => array_values(array_unique(array_merge($roomparticipants, $roomgroupsmembers))),
            ];

            $dbdata = [
                'name' => $roomname,
                'participants' => $dbroomparticipants,
                'groups' => $dbroomgroupsmembers,
            ];

            $breakoutrooms['zoom'][] = $zoomdata;
            $breakoutrooms['db'][] = $dbdata;
        }
    }

    return $breakoutrooms;
}

/**
 * Build zoom instance breakout rooms array for view.
 *
 * @param int $zoomid
 * @param array $courseparticipants
 * @param array $coursegroups
 * @return array The meeting breakout rooms array.
 */
function zoom_build_instance_breakout_rooms_array_for_view($zoomid, $courseparticipants, $coursegroups) {
    $breakoutrooms = zoom_get_instance_breakout_rooms($zoomid);
    $rooms = [];

    if (!empty($breakoutrooms)) {
        foreach ($breakoutrooms as $key => $breakoutroom) {
            $roomparticipants = $courseparticipants;
            if (!empty($breakoutroom['participants'])) {
                $participants = $breakoutroom['participants'];
                $roomparticipants = array_map(function ($roomparticipant) use ($participants) {
                    if (isset($participants[$roomparticipant['participantid']])) {
                        $roomparticipant['selected'] = true;
                    }

                    return $roomparticipant;
                }, $courseparticipants);
            }

            $roomgroups = $coursegroups;
            if (!empty($breakoutroom['groups'])) {
                $groups = $breakoutroom['groups'];
                $roomgroups = array_map(function ($roomgroup) use ($groups) {
                    if (isset($groups[$roomgroup['groupid']])) {
                        $roomgroup['selected'] = true;
                    }

                    return $roomgroup;
                }, $coursegroups);
            }

            $rooms[] = [
                'roomid' => $breakoutroom['roomid'],
                'roomname' => $breakoutroom['roomname'],
                'courseparticipants' => $roomparticipants,
                'coursegroups' => $roomgroups,
            ];
        }

        $rooms[0]['roomactive'] = true;
    }

    return $rooms;
}

/**
 * Get zoom instance breakout rooms.
 *
 * @param int $zoomid
 * @return array
 */
function zoom_get_instance_breakout_rooms($zoomid) {
    global $DB;

    $breakoutrooms = [];
    $params = [$zoomid];

    $sql = "SELECT id, name
        FROM {zoom_meeting_breakout_rooms}
        WHERE zoomid = ?";

    $rooms = $DB->get_records_sql($sql, $params);

    foreach ($rooms as $room) {
        $breakoutrooms[$room->id] = [
            'roomid' => $room->id,
            'roomname' => $room->name,
            'participants' => [],
            'groups' => [],
        ];

        // Get breakout room participants.
        $params = [$room->id];
        $sql = "SELECT userid
        FROM {zoom_breakout_participants}
        WHERE breakoutroomid = ?";

        $participants = $DB->get_records_sql($sql, $params);

        if (!empty($participants)) {
            foreach ($participants as $participant) {
                $breakoutrooms[$room->id]['participants'][$participant->userid] = $participant->userid;
            }
        }

        // Get breakout room groups.
        $sql = "SELECT groupid
        FROM {zoom_breakout_groups}
        WHERE breakoutroomid = ?";

        $groups = $DB->get_records_sql($sql, $params);

        if (!empty($groups)) {
            foreach ($groups as $group) {
                $breakoutrooms[$room->id]['groups'][$group->groupid] = $group->groupid;
            }
        }
    }

    return $breakoutrooms;
}

/**
 * Print zoom meeting date and time in the course listing page
 *
 * Given a course_module object, this function returns any "extra" information that may be needed
 * when printing this activity in a course listing. See get_array_of_activities() in course/lib.php.
 *
 * @param stdClass $coursemodule The coursemodule object
 * @return cached_cm_info An object on information that the courses will know about
 */
function zoom_get_coursemodule_info($coursemodule) {
    global $DB;

    $dbparams = ['id' => $coursemodule->instance];
    $fields = 'id, intro, introformat, start_time, recurring, recurrence_type, duration';
    if (!$zoom = $DB->get_record('zoom', $dbparams, $fields)) {
        return false;
    }

    $result = new cached_cm_info();

    if ($coursemodule->showdescription) {
        // Convert intro to html. Do not filter cached version, filters run at display time.
        $result->content = format_module_intro('zoom', $zoom, $coursemodule->id, false);
    }

    // Populate some other values that can be used in calendar or on dashboard.
    if ($zoom->start_time) {
        $result->customdata['start_time'] = $zoom->start_time;
    }

    if ($zoom->duration) {
        $result->customdata['duration'] = $zoom->duration;
    }

    // Skip the if condition for recurring and recurrence_type, the values of NULL and 0 are needed in other functions.
    $result->customdata['recurring'] = $zoom->recurring;
    $result->customdata['recurrence_type'] = $zoom->recurrence_type;

    return $result;
}

/**
 * Sets dynamic information about a course module
 *
 * This function is called from cm_info when displaying the module
 *
 * @param cm_info $cm
 */
function zoom_cm_info_dynamic(cm_info $cm) {
    global $CFG, $DB;

    require_once($CFG->dirroot . '/mod/zoom/locallib.php');

    if (method_exists($cm, 'override_customdata')) {
        $moduleinstance = $DB->get_record('zoom', ['id' => $cm->instance], '*', MUST_EXIST);

        // Get meeting state from Zoom.
        [$inprogress, $available, $finished] = zoom_get_state($moduleinstance);

        // For unfinished meetings, override start_time with the next occurrence.
        // If this is a recurring meeting without fixed time, do not override - it will set start_time = 0.
        if (!$finished && $moduleinstance->recurrence_type != ZOOM_RECURRINGTYPE_NOTIME) {
            $cm->override_customdata('start_time', zoom_get_next_occurrence($moduleinstance));
        }
    }
}

/**
 * Apply filter(s) on Zoom activity name if applicable.
 *
 * @param string $name Original name to be processed
 * @param array $options Format_string options
 * @return string Filtered name
 */
function zoom_apply_filter_on_meeting_name($name, $options) {
    return substr(format_string($name, true, $options + ['escape' => false]), 0, 200);
}

====================

file: README.md
path: README.md
codice:
# Intro

[Zoom](https://zoom.us) is a web- and app-based video conferencing service. This
plugin offers tight integration with Moodle, supporting meeting creation,
synchronization, grading and backup/restore.

## Prerequisites

This plugin is designed for Educational or Business Zoom accounts.

To connect to the Zoom APIs, this plugin requires an account-level app to be
created.

### Server-to-Server OAuth
To [create an account-level Server-to-Server OAuth app](https://developers.zoom.us/docs/internal-apps/create/), the `Server-to-server OAuth app`
permission is required. You should create a separate Server-to-Server OAuth app for each Moodle install.

The Server-to-Server OAuth app will generate a client ID, client secret and account ID.

#### Granular scopes
At a minimum, the following scopes are required:

- meeting:read:meeting:admin (Get meeting)
- meeting:read:invitation:admin (Get meeting invitation)
- meeting:delete:meeting:admin (Delete meeting)
- meeting:update:meeting:admin (Update meeting)
- meeting:write:meeting:admin (Create meeting)
- user:read:list_schedulers:admin (List schedulers)
- user:read:settings:admin (Get user settings)
- user:read:user:admin (Get user)

Optional functionality can be enabled by granting additional scopes:

- Meeting registrations
    - meeting:read:list_registrants:admin (Get registrants)
- Reports for meetings / webinars (Licensed accounts and higher)
    - report:read:list_meeting_participants:admin
    - report:read:list_webinar_participants:admin
    - report:read:list_users:admin
    - report:read:user:admin
- Faster reports for meetings / webinars (Business accounts and higher)
    - dashboard:read:list_meeting_participants:admin
    - dashboard:read:list_meetings:admin
    - dashboard:read:list_webinar_participants:admin
    - dashboard:read:list_webinars:admin
- Allow recordings to be viewed (zoom | viewrecordings)
    - cloud_recording:read:list_recording_files:admin
    - cloud_recording:read:list_user_recordings:admin
    - cloud_recording:read:recording_settings:admin
- Tracking fields (zoom | defaulttrackingfields)
    - tracking_field:read:list_tracking_fields:admin
- Recycle licenses (zoom | utmost), (zoom | recycleonjoin), (zoom | protectedgroups)
    - group:read:list_groups:admin
    - user:read:list_users:admin
    - user:update:user:admin
- Webinars (zoom | showwebinars), (zoom | webinardefault)
    - webinar:read:list_registrants:admin
    - webinar:read:webinar:admin
    - webinar:delete:webinar:admin
    - webinar:update:webinar:admin
    - webinar:write:webinar:admin

#### Classic scopes
At a minimum, the following scopes are required:

- meeting:read:admin (Read meeting details)
- meeting:write:admin (Create/Update meetings)
- user:read:admin (Read user details)

Optional functionality can be enabled by granting additional scopes:

- Reports for meetings / webinars
    - dashboard_meetings:read:admin (Business accounts and higher)
    - dashboard_webinars:read:admin  (Business accounts and higher)
    - report:read:admin (Pro accounts and higher)
- Allow recordings to be viewed (zoom | viewrecordings)
    - recording:read:admin
- Tracking fields (zoom | defaulttrackingfields)
    - tracking_fields:read:admin
- Recycle licenses (zoom | utmost), (zoom | recycleonjoin), (zoom | protectedgroups)
    - group:read:admin
    - user:write:admin
- Webinars (zoom | showwebinars), (zoom | webinardefault)
    - webinar:read:admin
    - webinar:write:admin

## Installation

1. [Install plugin](https://docs.moodle.org/en/Installing_plugins#Installing_a_plugin) to the /mod/zoom folder in Moodle.
2. After installing the plugin, the following settings need to be configured to use the plugin:

- Zoom account ID (mod_zoom | accountid)
- Zoom client ID (mod_zoom | clientid)
- Zoom client secret (mod_zoom | clientsecret)

If you get "Access token is expired" errors, make sure the date/time on your
server is properly synchronized with the time servers.

====================

file: zoom.php
path: lang/en/zoom.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * English strings for zoom.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die();

$string['accountid'] = 'Zoom account ID';
$string['accountid_desc'] = '';
$string['actions'] = 'Actions';
$string['activitydate:ended'] = 'Ended: ';
$string['activitydate:started'] = 'Started: ';
$string['activitydate:starts'] = 'Starts: ';
$string['addparticipant'] = 'Add a participant';
$string['addparticipantgroup'] = 'Add a group of participants';
$string['addroom'] = 'Add a room';
$string['addroomalert'] = 'Add a room by clicking';
$string['addtocalendar'] = 'Add to calendar';
$string['allmeetings'] = 'All meetings';
$string['allmeetings_desc'] = 'With this setting, you can control if a link to the Zoom activity index page will be shown at the bottom of every activity instance overview page or not. This setting only affects the presentation of the link on the Zoom activity overview pages. Even if you decide not to show the link there, the user might still be able to access the Zoom activity index page through other links within the course.';
$string['allmeetings_disable'] = 'Disable all meetings link';
$string['allmeetings_enable'] = 'Enable all meetings link';
$string['alternative_hosts'] = 'Alternative Hosts';
$string['alternative_hosts_desc'] = 'With this setting, you can control if the option to choose alternative hosts is shown to users in the activity instance settings or not. Two types of widgets are available: A plain input field which accepts comma-separated email addresses. And a user picker with autocompletion which provides easy selection of users who are enrolled into the course, have a Zoom account and have a role out of {$a->roles}. Alternative hosts which might have been set by the teacher in Zoom directly but are not selectable from within the Moodle user picker are still shown on the activity overview page and are also preserved when a meeting is updated from within Moodle.';
$string['alternative_hosts_disable'] = 'Disable alternative hosts option';
$string['alternative_hosts_help'] = "The alternative host option allows you to schedule meetings and designate other Zoom user(s) to start the meeting as well. These users will receive an email from Zoom notifying them that they've been added as an alternative host, with a link to start the meeting.\n\nAs input format, please provide the email address(es) of the alternative host(s). You can separate multiple emails by a comma (without spaces).";
$string['alternative_hosts_inputfield'] = 'Show alternative hosts option as plain input field';
$string['alternative_hosts_picker'] = 'Show alternative hosts option as user picker with autocompletion';
$string['alternative_hosts_picker_help'] = "The alternative host option allows you to schedule meetings and designate other Zoom user(s) enrolled in this course to start the meeting as well. These users will receive an email from Zoom notifying them that they've been added as an alternative host, with a link to start the meeting.\n\nYou can pick one or multiple alternative hosts based on your meeting needs.\n\nIf you can't find a particular user in this user picker, this user either is not enrolled into this course with an appropriate role or does not have an eligible account on Zoom.";
$string['alternative_hosts_picker_noneselected'] = 'No alternative host selected';
$string['alternative_hosts_picker_placeholder'] = 'Select user(s)';
$string['apiendpoint'] = 'Zoom API Endpoint';
$string['apiendpoint_desc'] = 'Choose which Zoom API endpoint the Zoom activity will use to connect. The global API endpoint should work for all users. The European Union (EU) API endpoint is only intended for users who have a Zoom license with the EU provisioning option. If you are unsure, use the global API endpoint.';
$string['apiendpoint_eu'] = 'EU API Endpoint';
$string['apiendpoint_global'] = 'Global API Endpoint';
$string['apiidentifier'] = 'Zoom API Identifier';
$string['apiidentifier_desc'] = 'The identifier field to use when making a call to the Zoom API';
$string['apiurl'] = 'Zoom API url';
$string['apiurl_desc'] = '';
$string['audio_both'] = 'Computer audio and Telephone';
$string['audio_telephony'] = 'Telephone only';
$string['audio_voip'] = 'Computer audio only';
$string['audiodefault'] = 'Audio default';
$string['authentication'] = 'Authentication';
$string['autorecording_cloud'] = 'Cloud';
$string['autorecording_local'] = 'Local';
$string['autorecording_none'] = 'None';
$string['autorecording_userdefault'] = 'Use default Zoom user settings';
$string['autorecordingoptionsupdate'] = 'Update auto recording options';
$string['breakoutrooms'] = 'Breakout rooms';
$string['cachedef_oauth'] = 'Zoom OAuth token cache';
$string['cachedef_zoomid'] = 'Zoom user id mappings';
$string['cachedef_zoommeetingsecurity'] = 'Zoom meeting security settings, including meeting password requirements of the account';
$string['calendardescriptionintro'] = "\nDescription:\n{\$a}";
$string['calendariconalt'] = 'Calendar icon';
$string['calendarjoinurl'] = 'Meeting join URL: {$a}.';
$string['changehost'] = 'Change host';
$string['clickjoin'] = 'Clicked join meeting button';
$string['clientid'] = 'Zoom client ID';
$string['clientid_desc'] = '';
$string['clientsecret'] = 'Zoom client secret';
$string['clientsecret_desc'] = '';
$string['connectionfailed'] = 'Connection failed: ';
$string['connectionok'] = 'Connection working.';
$string['connectionsettings'] = 'Connection settings';
$string['connectionsettings_desc'] = 'These settings define how Moodle connects to Zoom.';
$string['connectionstatus'] = 'Connection status';
$string['day'] = 'Day(s)';
$string['defaultsettings'] = 'Default Zoom settings';
$string['defaultsettings_help'] = 'These settings define the defaults for all new Zoom meetings and webinars.';
$string['deletemeetingrecordings'] = 'Delete meeting recordings from Moodle';
$string['deleteroom'] = 'Delete room';
$string['displayfirstname'] = 'First name only';
$string['displayfullname'] = 'Full name';
$string['displayid'] = '(user id) only';
$string['displayidfullname'] = '(user id) followed by fullname';
$string['displayleadtime'] = 'Display lead time';
$string['displayleadtime_desc'] = 'If enabled, the leadtime will be displayed to the users. This way, users are informed that / when they can join the meeting before the scheduled start time. This might keep users from constantly reloading the page until they can join.';
$string['displayleadtime_nohideif'] = 'Please note: This setting is only processed if the \'{$a}\' setting is set to a value greater than zero.';
$string['displaypassword'] = 'Display passcode';
$string['displaypassword_help'] = 'If enabled the meeting passcode will always be displayed to non-hosts.';
$string['downloadical'] = 'Download iCal';
$string['downloadical_desc'] = 'With this setting, you can control if a link to download an iCal file for the meeting will be shown on the activity instance overview page or not. This setting only affects the possibility to download an iCal file for third-party calendar tools. Regardless of this setting, the Zoom meeting activity will add a calendar entry into the Moodle calendar as soon as a meeting start date is set.';
$string['downloadical_disable'] = 'Disable download iCal link';
$string['downloadical_enable'] = 'Enable download iCal link';
$string['duration'] = 'Duration';
$string['encryptiontype'] = 'Encryption type';
$string['encryptiontype_alwaysshow'] = 'Always show encryption type chooser regardless if the user can use end-to-end encryption or not';
$string['encryptiontype_desc'] = 'With this setting, you can control if the option to choose end-to-end encryption over enhanced encryption is shown to users in the activity instance settings or not. This setting only affects the Moodle activity instance settings. Even if you decide to always show the option, the user will still need end-to-end encryption in Zoom to finally enable end-to-end encryption.';
$string['encryptiontype_disable'] = 'Disable encryption type chooser';
$string['encryptiontype_showonlyife2epossible'] = 'Show encryption type chooser only if the user can use end-to-end encryption';
$string['end_date_option_after'] = 'After';
$string['end_date_option_by'] = 'By';
$string['end_date_option_occurrences'] = 'occurrences';
$string['enddate'] = 'End date';
$string['endtime'] = 'End time';
$string['err_downloadicaldisabled'] = 'Downloading Zoom meeting iCal files was disabled.';
$string['err_downloadicalrecurringempty'] = 'Downloading Zoom meeting iCal file is not possible for this meeting as it does not contain at least a single occurrence.';
$string['err_downloadicalrecurringnofixed'] = 'Downloading Zoom meeting iCal file is not possible for this meeting as it is a recurring meeting with no fixed time.';
$string['err_duration_nonpositive'] = 'The duration must be positive.';
$string['err_duration_too_long'] = 'The duration cannot exceed 150 hours.';
$string['err_end_date'] = 'Recurrence end date cannot be in the past';
$string['err_end_date_before_start'] = 'Recurrence end date cannot be before start date';
$string['err_invalid_password'] = 'Passcode contains invalid characters.';
$string['err_long_timeframe'] = 'Requested time frame too long, showing results of latest month in range.';
$string['err_password'] = 'Passcode may only contain the following characters: [a-z A-Z 0-9 @ - _ *]. Max of 10 characters.';
$string['err_password_required'] = 'Passcode is required.';
$string['err_registration'] = 'The current user is not permitted to create a meeting/webinar that requires registration.';
$string['err_repeat_monthly_interval'] = 'Max interval for monthly meeting is 3 months';
$string['err_repeat_weekly_interval'] = 'Max interval for weekly meeting is 12 weeks';
$string['err_start_time_past'] = 'The start date cannot be in the past.';
$string['err_start_time_past_recurring'] = 'For recurring meetings, the date portion of this field is the earliest possible date for the next meeting. This date must be today or in the future.';
$string['err_weekly_days'] = 'Select day(s) for the recurring weekly meeting';
$string['erroraddinstance'] = 'Could not create new zoom meeting. Invalid options selected for a recurring meeting.';
$string['errorwebservice'] = 'Zoom webservice error: {$a}.';
$string['errorwebservice_badrequest'] = 'Zoom received a bad request: {$a}';
$string['errorwebservice_notfound'] = 'The resource does not exist: {$a}';
$string['export'] = 'Export';
$string['externaluser'] = 'External user';
$string['firstjoin'] = 'First able to join';
$string['firstjoin_desc'] = 'The earliest a user can join a scheduled meeting (minutes before start).';
$string['getmeetingrecordings'] = 'Get meeting recordings from Zoom';
$string['getmeetingreports'] = 'Get meeting report from Zoom';
$string['globalsettings'] = 'Global settings';
$string['globalsettings_desc'] = 'These settings apply to the Zoom plugin as a whole.';
$string['grading_needgrade'] = "The following users need to be graded manually as they could not be identified:\n";
$string['grading_notenrolled'] = "The following users joined the meeting but were not recognized as enroled users:\n";
$string['grading_notfound'] = "List of users who clicked to join the meeting, but were not recognized in the participant report:\n";
$string['gradingentry'] = 'Upon entry';
$string['gradinglink'] = 'Review or update grades';
$string['gradingmessagebody'] = 'For Zoom Meeting session: {$a->zoomurl};
<br>
Number of users that have been automatically graded according to their duration in the meeting: {$a->graded}.
<br>
Number of users that were already graded: {$a->alreadygraded}.
<br>
{$a->needgrade}<br>
Review or update users grades here: {$a->gradeurl}
<br>
{$a->notfound}
<br>
{$a->notenrolled}';
$string['gradingmessagesubject'] = 'User grades for Zoom meeting: {$a->name}';
$string['gradingmethod'] = 'Grading method';
$string['gradingmethod_heading'] = 'Options for grading method';
$string['gradingmethod_heading_help'] = 'Decide which method to use when grading Zoom participation.';
$string['gradingmethod_help'] = 'Choose the method to use when grading student participation.<br>
Upon entry: the student receives full marks (max grade) when they click to join the meeting in Moodle.<br>
Attendance duration: the student receives a score based on the percentage of their meeting attendance compared to the total meeting duration.<br>
Notes regarding Attendance duration method:<br>
- This method requires the display name to contain id or fullname.<br>
- It is recommended to set the setting \'zoom | defaultjoinbeforehost\' to (No) so the meeting duration is accurate.<br>
- Some students who are already signed in to the Zoom client with details not matching those in Moodle must be graded manually after reviewing the meeting report.';
$string['gradingperiod'] = 'Attendance Duration';
$string['gradingsmallmeassage'] = 'User grades quick report for {$a->name}:
<br>
Need manual grading: {$a->number}
<br>
Graded users: {$a->graded + $a->alreadygraded}';
$string['host'] = 'Host';
$string['hostintro'] = '<a target="_blank" href="https://support.zoom.us/hc/en-us/articles/208220166">Alternative Hosts</a> can start Zoom meetings and manage the Waiting Room.';
$string['indicator:cognitivedepth'] = 'Zoom cognitive';
$string['indicator:cognitivedepth_help'] = 'This indicator is based on the cognitive depth reached by the student in a Zoom activity.';
$string['indicator:socialbreadth'] = 'Zoom social';
$string['indicator:socialbreadth_help'] = 'This indicator is based on the social breadth reached by the student in a Zoom activity.';
$string['instanceusers'] = 'Check instance users';
$string['instanceusers_desc'] = 'If Redefine licenses is enabled, only check licensed users on this Moodle instance. Useful for setups where separate instances are dividing up a single pool of Zoom licenses.';
$string['invalid_status'] = 'Status invalid, check the database.';
$string['invalidscheduleuser'] = 'You cannot schedule for the specified user.';
$string['invitation_dialin'] = 'Dial in pattern';
$string['invitation_dialin_help'] = 'The regex pattern to find the Zoom meeting dial in numbers.';
$string['invitation_h323'] = 'H.323 message pattern';
$string['invitation_h323_help'] = 'The regex pattern to find the Zoom meeting H.323 information. If your invitations do not contain SIP or H.323 elements, set the matching regular expression pattern to an empty string. (This especially applies to servers with debugging enabled, because it can break the format of special file types like the iCal export.)';
$string['invitation_icallink'] = 'iCal link message pattern';
$string['invitation_icallink_help'] = 'The regex pattern to find the Zoom meeting iCal link.';
$string['invitation_invite'] = 'Invite message pattern';
$string['invitation_invite_help'] = 'The regex pattern to find the Zoom meeting introduction message.';
$string['invitation_joinurl'] = 'Join URL pattern';
$string['invitation_joinurl_help'] = 'The regex pattern to find the Zoom meeting join url.';
$string['invitation_onetapmobile'] = 'One tap mobile pattern';
$string['invitation_onetapmobile_help'] = 'The regex pattern to find the Zoom meeting one tap mobile details.';
$string['invitation_sip'] = 'SIP pattern';
$string['invitation_sip_help'] = 'The regex pattern to find the Zoom meeting SIP information. If your invitations do not contain SIP or H.323 elements, set the matching regular expression pattern to an empty string. (This especially applies to servers with debugging enabled, because it can break the format of special file types like the iCal export.)';
$string['invitationmatchnotfound'] = 'No match found in zoom invitation for element: "{$a->element}" with pattern: "{$a->pattern}".';
$string['invitationmodificationfailed'] = 'Error in regex for zoom invitation element: "{$a->element}" with pattern: "{$a->pattern}".';
$string['invitationregex'] = 'Zoom invitation regex and capabilities';
$string['invitationregex_help'] = 'Define the regex patterns to isolate each part of a zoom invitation so the information can be controlled by capabilities.';
$string['invitationregex_nohideif'] = 'Please note: The regex patterns will only be used if the \'{$a}\' setting is enabled.';
$string['invitationregexenabled'] = 'Enable zoom invitation regex and capabilities.';
$string['invitationregexenabled_help'] = 'When enabled, the zoom invitation shown in the activity will be broken up into elements using the following regex and capabilities will be used to decide which parts to display to each user. See zoom/viewjoinurl and zoom/viewdialin capabilities.';
$string['invitationremoveicallink'] = 'Remove zoom invitation iCal link';
$string['invitationremoveicallink_help'] = 'If enabled, the iCal link which may be included in the zoom meeting email message will be stripped using the invitation_icallink regex pattern.';
$string['invitationremoveinvite'] = 'Remove zoom invitation invite message';
$string['invitationremoveinvite_help'] = 'If enabled, the introduction sentence in the zoom meeting email message will be stripped using the invitation_invite regex pattern.';
$string['join'] = 'Join';
$string['join_meeting'] = 'Join Meeting';
$string['joinbeforehost'] = 'Join meeting before host';
$string['joinbeforehostenable'] = 'Allow participants to join anytime';
$string['joinlink'] = 'Join link';
$string['jointime'] = 'Join time';
$string['leavetime'] = 'Leave time';
$string['licenseonjoin'] = 'Select this option if you would like the host to receive a license upon starting the meeting, <i>as well as</i> upon creation.';
$string['licensesettings'] = 'License settings';
$string['licensesettings_desc'] = 'These settings define the way how Moodle handles your Zoom license.';
$string['licensesnumber'] = 'Number of licenses';
$string['lowlicenses'] = 'If the number of your licenses exceeds those required, then when you create each new activity by the user, it will be assigned a PRO license by lowering the status of another user. The option is effective when the number of active PRO-licenses is more than 5.';
$string['maskparticipantdata'] = 'Mask participant data';
$string['maskparticipantdata_help'] = 'Prevents participant data from appearing in reports (useful for sites that mask participant data, e.g., for HIPAA).';
$string['media'] = 'Media';
$string['meeting_finished'] = 'Finished';
$string['meeting_invite'] = 'Phone/Dial-In info';
$string['meeting_invite_hide'] = 'Hide meeting invitation';
$string['meeting_invite_show'] = 'Show meeting invitation';
$string['meeting_nonexistent_on_zoom'] = 'Nonexistent on Zoom';
$string['meeting_not_started'] = 'Not started';
$string['meeting_started'] = 'In progress';
$string['meeting_time'] = 'Start Time';
$string['meetingactivityurl'] = 'Meeting activity URL: <a href="{$a}">{$a}</a>';
$string['meetingcapacitywarning'] = 'Meeting capacity warning';
$string['meetingcapacitywarning_desc'] = 'With this setting, you can show a warning notification if there are more active and enrolled participants in the course than the host\'s Zoom license meeting capacity is. The notification will be shown to the host (and alternative hosts) on the Zoom activity overview page. It will recommend the host to turn to the Zoom account owner to obtain a larger Zoom license if necessary. You can change this message through Moodle language customization.';
$string['meetingcapacitywarning_disable'] = 'Disable meeting capacity warning';
$string['meetingcapacitywarning_enable'] = 'Enable meeting capacity warning';
$string['meetingcapacitywarningbodyalthost'] = 'The Zoom license of this meeting\'s host, {$a->hostname}, has a capacity of <strong>{$a->meetingcapacity} meeting participants</strong>, but this course has <strong><a href="{$a->courseparticipantsurl}">{$a->eligiblemeetingparticipants} enrolled and active participants</a></strong>.';
$string['meetingcapacitywarningbodyrealhost'] = 'Your Zoom license has a capacity of <strong><a href="{$a->zoomprofileurl}" target="_blank">{$a->meetingcapacity} meeting participants</a></strong>, but this course has <strong><a href="{$a->courseparticipantsurl}">{$a->eligiblemeetingparticipants} enrolled and active participants</a></strong>.';
$string['meetingcapacitywarningcontactalthost'] = 'Please ask the host to turn to the Zoom account owner to obtain a larger Zoom license if all of these course participants need to join the meeting.';
$string['meetingcapacitywarningcontactrealhost'] = 'Please turn to the Zoom account owner to obtain a larger Zoom license if all of these course participants need to join the meeting.';
$string['meetingcapacitywarningheading'] = 'Meeting capacity warning:';
$string['meetingparticipantsdeleted'] = 'Meeting participant user data deleted.';
$string['meetingrecordingviewsdeleted'] = 'Meeting recording user view data deleted.';
$string['messageprovider:ical_notifications'] = 'Send iCal invitations for a newly created Zoom event to participants.';
$string['messageprovider:teacher_notification'] = 'Notify teachers about user grades (according to duration) in a Zoom session';
$string['modulename'] = 'Zoom meeting';
$string['modulename_help'] = 'Zoom is a video and web conferencing platform that gives authorized users the ability to host online meetings.';
$string['modulenameplural'] = 'Zoom Meetings';
$string['month'] = 'Month(s)';
$string['month_day_text'] = 'of the month';
$string['newmeetings'] = 'New Meetings';
$string['nextoccurrence'] = 'Next occurrence';
$string['nomeetinginstances'] = 'No sessions found for this meeting.';
$string['nonrecognizedusergrade'] = '(Name: {$a->userid}, grade: {$a->grade})';
$string['nooccurrenceleft'] = 'The last occurrence is already over';
$string['noparticipants'] = 'No participants found for this session at this time.';
$string['norecordings'] = 'No recordings found for this meeting at this time.';
$string['norooms'] = 'No Rooms';
$string['nosessions'] = 'No sessions found for specified range.';
$string['nozooms'] = 'No meetings';
$string['nozoomsfound'] = 'No meetings found for the given course.';
$string['occurson'] = 'Occurs On';
$string['off'] = 'Off';
$string['oldmeetings'] = 'Concluded Meetings';
$string['on'] = 'On';
$string['option_allow_recording_change'] = 'Allow change recording';
$string['option_allow_recording_change_help'] = 'Allow the user to change recording setup at activity creation time';
$string['option_audio'] = 'Audio options';
$string['option_audio_help'] = 'With this option, you can allow users to call in using Telephone only, Computer audio only or both';
$string['option_authenticated_users'] = 'Require authentication to join';
$string['option_authenticated_users_help'] = "Enabling this option requires all attendees to sign in with their authorized zoom account to be able to join the meeting. It does <em>not</em> relate to logging into Moodle in any way.";
$string['option_auto_recording'] = 'Automatic recording';
$string['option_auto_recording_help'] = 'Enabling this option will automatically record the meeting';
$string['option_encryption_type'] = 'Encryption';
$string['option_encryption_type_endtoendencryption'] = 'End-to-end encryption';
$string['option_encryption_type_enhancedencryption'] = 'Enhanced encryption';
$string['option_encryption_type_help'] = "With this option, you control the level of encryption and privacy of this meeting.\n\n*Enhanced encryption* means that the encryption key is stored in the Zoom cloud.\n\n*End-to-end encryption* means that the encryption key is stored on your local device and no one else can obtain your encryption key, not even Zoom.\n\nPlease note that when you enable end-to-end encryption, several features will not be available from within the meeting - [See details in the Zoom documentation](https://support.zoom.us/hc/en-us/articles/360048660871).";
$string['option_host_video'] = 'Host video';
$string['option_host_video_help'] = 'Enabling this option will enable the host\'s video when joining the meeting. Even if you choose off, the host will have the option to start his/her video.';
$string['option_jbh'] = 'Join before host';
$string['option_jbh_help'] = "Enabling this option allows attendees to join the meeting before the host joins or when the host cannot attend the meeting.\n\nThis option is mutually exclusive with the 'Waiting room' option, so selecting one will disable the other.";
$string['option_mute_upon_entry'] = 'Mute participants upon entry';
$string['option_mute_upon_entry_help'] = 'Enabling this option wil automatically mute all participants when they join the meeting. Participants can unmute themselves after joining the meeting.';
$string['option_participants_video'] = 'Participants video';
$string['option_participants_video_help'] = 'Enabling this option will enable the participants\' video when joining the meeting. Even if you choose off, the participants will have the option to start their video.';
$string['option_proxyhost'] = 'Use proxy';
$string['option_proxyhost_desc'] = 'The proxy set here as \'<code>&lt;hostname&gt;:&lt;port&gt;</code>\' is used only for communicating with Zoom. Leave empty to use the Moodle default proxy settings. You only need to set this if you do not want to set a global proxy in Moodle.';
$string['option_view_recordings'] = 'Allow recordings to be viewed';
$string['option_waiting_room'] = 'Waiting room';
$string['option_waiting_room_help'] = "Enabling this option allows the host to control when a participant joins the meeting.\n\nThis option is mutually exclusive with the 'Join before host' option, so selecting one will disable the other.";
$string['participantdatanotavailable'] = 'Details not available';
$string['participantdatanotavailable_help'] = 'Participant data is not available for this Zoom session (e.g., due to HIPAA-compliance).';
$string['participantgroups'] = 'Participant groups';
$string['participants'] = 'Participants';
$string['password'] = 'Passcode';
$string['password_allowed_char'] = 'Passcode may only contain the following characters: [a-z A-Z 0-9 @ - _ *].';
$string['password_consecutive'] = 'Maximum of {$a} consecutive characters (abcd, 1111, 1234, etc.).';
$string['password_length'] = 'Minimum of {$a} character(s).';
$string['password_letter'] = 'Passcode must contain at least 1 letter.';
$string['password_lower_upper'] = 'Passcode must include both lower and uppercase characters.';
$string['password_max_length'] = 'Maximum of 10 characters.';
$string['password_number'] = 'Passcode must contain at least 1 number.';
$string['password_only_numeric'] = 'Passcode may only contain numbers and no other characters.';
$string['password_special'] = 'Passcode must have at least 1 special character (@-_*).';
$string['passwordprotected'] = 'Passcode Protected';
$string['pluginadministration'] = 'Manage Zoom meeting';
$string['pluginname'] = 'Zoom meeting';
$string['privacy:metadata:zoom_breakout_participants'] = 'The database table to store a list of zoom meeting breakout rooms participants';
$string['privacy:metadata:zoom_breakout_participants:userid'] = 'The id of the participant user';
$string['privacy:metadata:zoom_meeting_details'] = 'The database table that stores information about each meeting instance.';
$string['privacy:metadata:zoom_meeting_details:topic'] = 'The name of the meeting that the user attended.';
$string['privacy:metadata:zoom_meeting_participants'] = 'The database table that stores information about meeting participants.';
$string['privacy:metadata:zoom_meeting_participants:duration'] = 'How long the participant was in the meeting';
$string['privacy:metadata:zoom_meeting_participants:join_time'] = 'The time that the participant joined the meeting';
$string['privacy:metadata:zoom_meeting_participants:leave_time'] = 'The time that the participant left the meeting';
$string['privacy:metadata:zoom_meeting_participants:name'] = 'The name of the participant';
$string['privacy:metadata:zoom_meeting_participants:user_email'] = 'The email of the participant';
$string['privacy:metadata:zoom_meeting_view'] = 'The database table to track users that view the meeting recordings';
$string['privacy:metadata:zoom_meeting_view:userid'] = 'The id of the user that viewed the recording';
$string['protectedgroups'] = 'Protect groups';
$string['protectedgroups_desc'] = 'Select Zoom groups to protect member users from license redefining';
$string['recording'] = 'Recording';
$string['recordingadd'] = 'Add Recording';
$string['recordingdate'] = 'Recording Date';
$string['recordingdelete'] = 'Are you sure you want to delete the recording "{$a}"?';
$string['recordinghide'] = 'Hide Recording (Currently Visible)';
$string['recordinglink'] = 'Recording Link';
$string['recordingname'] = 'Title';
$string['recordingnotfound'] = 'Recording could not be found';
$string['recordingnotvisible'] = 'Recording is not visible. Please contact your System Administrator if you believe this is an error';
$string['recordingpasscode'] = 'Recording Passcode';
$string['recordings'] = 'Recordings';
$string['recordingshow'] = 'Show Recording (Currently Hidden)';
$string['recordingshowtoggle'] = 'Toggle Show Recording';
$string['recordingtype_active_speaker'] = 'Active Speaker';
$string['recordingtype_audio_interpretation'] = 'Audio Interpretation';
$string['recordingtype_audio_only'] = 'Audio Only';
$string['recordingtype_audio_transcript'] = 'Audio Transcript';
$string['recordingtype_chat'] = 'Chat File';
$string['recordingtype_closed_caption'] = 'Closed Caption';
$string['recordingtype_gallery'] = 'Gallery View';
$string['recordingtype_poll'] = 'Poll';
$string['recordingtype_production_studio'] = 'Production Studio';
$string['recordingtype_shared'] = 'Shared Screen';
$string['recordingtype_shared_gallery'] = 'Shared Screen with Gallery View';
$string['recordingtype_shared_speaker'] = 'Shared Screen with Speaker View';
$string['recordingtype_shared_speaker_cc'] = 'Shared Screen with Speaker View (CC)';
$string['recordingtype_sign'] = 'Sign Interpretation';
$string['recordingtype_speaker'] = 'Speaker View';
$string['recordingtype_summary'] = 'Summary';
$string['recordingtype_summary_next_steps'] = 'Summary Next Steps';
$string['recordingtype_summary_smart_chapters'] = 'Summary Smart Chapters';
$string['recordingtype_timeline'] = 'Timeline';
$string['recordingurl'] = 'Recording URL';
$string['recordingview'] = 'View Recordings';
$string['recordingvisibility'] = 'Are recordings for this meeting visible by default?';
$string['recordingvisibility_help'] = 'When new recordings for this meeting are fetched, should they be visible in Moodle by default?';
$string['recreatesuccessful'] = 'Sucessfully recreated meeting';
$string['recurrence_option_daily'] = 'Daily';
$string['recurrence_option_monthly'] = 'Monthly';
$string['recurrence_option_no_time'] = 'No Fixed Time';
$string['recurrence_option_weekly'] = 'Weekly';
$string['recurrencetype'] = 'Recurrence';
$string['recurringmeeting'] = 'Recurring meeting';
$string['recurringmeeting_help'] = 'Enabling this option will make the meeting a recurring meeting without an end date or time. It can then be accessed anytime.';
$string['recurringmeetingexplanation'] = 'The meeting does not have an end date or time';
$string['recurringmeetinglong'] = 'Recurring meeting (meeting with no end date or time)';
$string['recurringmeetingthisis'] = 'This is a recurring meeting';
$string['recycleonjoin'] = 'Recycle license upon join';
$string['redefinelicenses'] = 'Redefine licenses';
$string['refreshreports'] = 'Refresh session reports';
$string['register'] = 'Register';
$string['registration'] = 'Require registration';
$string['registration_help'] = 'Enabling this option will force participants to register for the Zoom meeting/webinar before joining.';
$string['registration_text'] = 'Force participants to register for the meeting/webinar';
$string['repeatinterval'] = 'Repeat Every';
$string['report'] = 'Reports';
$string['reportapicalls'] = 'Report API calls exhausted';
$string['requirepasscode'] = 'Require meeting passcode';
$string['requirepasscode_help'] = 'Enabling this option will require that the host sets a passcode for the meeting. Joining participants will be required to input this before joining the meeting. Participants who enter the meeting from within the Moodle activity do not need to input this passcode.';
$string['resetapicalls'] = 'Reset the number of available API calls';
$string['resetzoomsall'] = 'Delete all user grades, recording user view data, and meeting participant user data.';
$string['room'] = 'Room';
$string['roomname'] = 'Room name';
$string['rooms'] = 'Rooms';
$string['schedule'] = 'Schedule';
$string['schedulefor'] = 'Schedule meeting for';
$string['schedulefor_help'] = 'You can schedule meetings on behalf of another user. As a prerequisite, this user must have assigned you scheduling privilege in Zoom. The selected user will be the host of the meeting and will be the one whose Zoom license will be used for the meeting.';
$string['scheduleforself'] = 'Yourself';
$string['schedulingprivilege'] = 'Scheduling privilege';
$string['schedulingprivilege_desc'] = 'With this setting, you can control if the scheduling privilege option is shown to users in the activity instance settings or not. This setting only affects the Moodle activity instance settings. Even if you decide to show the option, the user will still need to get the scheduling privilege granted by another user in Zoom to finally schedule a meeting for the other user.';
$string['schedulingprivilege_disable'] = 'Disable scheduling privilege option';
$string['schedulingprivilege_enable'] = 'Enable scheduling privilege option';
$string['search:activity'] = 'Zoom - activity information';
$string['security'] = 'Security';
$string['selectionarea'] = 'No selection';
$string['sendicalnotifications'] = 'Send iCal Notifications';
$string['sendicalnotifications_help'] = "Enabling this option will allow iCal Notifications to be sent via the 'Send iCal Notification' scheduled task.";
$string['sendicalnotifications_warning'] = "Attachments must be enabled in Site administration / Server / Email / Outgoing mail configuration to use this option.";
$string['sessions'] = 'Sessions';
$string['sessionsreport'] = 'Sessions report';
$string['sesskeyinvalid'] = 'Invalid session detected. Cannot proceed further.';
$string['setpasscode'] = 'Set passcode';
$string['showmedia'] = 'Show Media section';
$string['showmedia_help'] = 'Enabling this option will show the Media section on the meeting activity page.';
$string['showmediaonview'] = 'Show Media section on meeting page';
$string['showschedule'] = 'Show Schedule section';
$string['showschedule_help'] = 'Enabling this option will show the Schedule section on the meeting activity page.';
$string['showscheduleonview'] = 'Show Schedule section on meeting page';
$string['showsecurity'] = 'Show Security section';
$string['showsecurity_help'] = 'Enabling this option will show the Security section on the meeting activity page.';
$string['showsecurityonview'] = 'Show Security section on meeting page';
$string['start'] = 'Start';
$string['start_meeting'] = 'Start Meeting';
$string['start_time'] = 'When';
$string['starthostjoins'] = 'Start video when host joins';
$string['startpartjoins'] = 'Start video when participant joins';
$string['starttime'] = 'Start time';
$string['status'] = 'Status';
$string['supplementaryfeaturessettings'] = 'Supplementary features settings';
$string['supplementaryfeaturessettings_desc'] = 'These settings control if and how supplementary Zoom features are provided to the users.';
$string['title'] = 'Title';
$string['topic'] = 'Topic';
$string['trackingfields'] = 'Tracking fields';
$string['trackingfields_help'] = 'Enter the tracking field name(s)/label(s), separated by commas, to enable for Zoom activities.';
$string['trackingfields_recommendedvalues'] = 'Recommended values: ';
$string['unamedisplay'] = 'User display name';
$string['unamedisplay_help'] = 'How the name of a user should be displayed in meetings (only works for users who are not logged in to the Zoom client).';
$string['unavailable'] = 'You are unable to join at this time.';
$string['unavailablefinished'] = 'The meeting has finished already.';
$string['unavailablefirstjoin'] = 'You can join {$a->mins} minutes before the scheduled start time at the earliest.';
$string['unavailablenotstartedyet'] = 'The meeting has not started yet.';
$string['updatemeetings'] = 'Update meeting settings from Zoom';
$string['updatetrackingfields'] = 'Update tracking field settings from Zoom';
$string['usepersonalmeeting'] = 'Use personal meeting ID {$a}';
$string['waitingroom'] = 'Waiting room';
$string['waitingroomenable'] = 'Enable waiting room';
$string['webinar'] = 'Webinar';
$string['webinar_already_false'] = '<p><b>This module was already set as a meeting, not webinar. You cannot toggle this setting after creating the meeting.</b></p>';
$string['webinar_already_true'] = '<p><b>This module was already set as a webinar, not meeting. You cannot toggle this setting after creating the webinar.</b></p>';
$string['webinar_alwaysshow'] = 'Always show webinar option regardless if the user has a license to host webinars';
$string['webinar_by_default'] = 'Webinar by default';
$string['webinar_by_default_desc'] = 'Create Zoom instance as a webinar by default.';
$string['webinar_desc'] = 'With this setting, you can control if the option to create a webinar is shown to users during the creation of a meeting or not. This setting only affects the Moodle activity instance settings. Even if you decide to always show the option, the user will still need a valid license for webinars to finally host a webinar.';
$string['webinar_disable'] = 'Disable webinars';
$string['webinar_help'] = "Webinars give hosts enhanced control and flexibility for hosting meetings with larger audiences.\n\nThis option is only available to pre-authorized Zoom accounts.";
$string['webinar_showonlyiflicense'] = 'Show webinar option only if the user has a license to host webinars';
$string['webinarthisis'] = 'This is a webinar';
$string['week'] = 'Week(s)';
$string['weekoption_first'] = 'First';
$string['weekoption_fourth'] = 'Fourth';
$string['weekoption_last'] = 'Last';
$string['weekoption_second'] = 'Second';
$string['weekoption_third'] = 'Third';
$string['zoom:addinstance'] = 'Add a new Zoom meeting';
$string['zoom:eligiblealternativehost'] = 'Selectable as alternative host within Zoom meetings';
$string['zoom:refreshsessions'] = 'Refresh Zoom meeting reports';
$string['zoom:view'] = 'View Zoom meetings';
$string['zoom:viewdialin'] = 'View Zoom dial-in information';
$string['zoom:viewjoinurl'] = 'View Zoom join url';
$string['zoomerr'] = 'An error occured with Zoom.';
$string['zoomerr_alternativehostusernotfound'] = 'User {$a} was not found on Zoom.';
$string['zoomerr_apilimit'] = 'Reached the maximum daily rate limit for this API. Retry at {$a}';
$string['zoomerr_field_missing'] = '{$a} not found';
$string['zoomerr_id_missing'] = 'You must specify a course_module ID or an instance ID';
$string['zoomerr_licensesnumber_missing'] = 'Zoom utmost setting found but, licensesnumber setting not found';
$string['zoomerr_maxretries'] = 'Retried {$a->maxretries} times to make the call, but failed: {$a->response}';
$string['zoomerr_meetingnotfound'] = 'This meeting cannot be found on Zoom. You can <a href="{$a->recreate}">recreate it here</a> or <a href="{$a->delete}">delete it completely</a>.';
$string['zoomerr_meetingnotfound_info'] = 'This meeting cannot be found on Zoom. Please contact the meeting host if you have questions.';
$string['zoomerr_no_access_token'] = 'No access token returned';
$string['zoomerr_scopes'] = 'The Zoom OAuth configuration is missing these required scopes: {$a}';
$string['zoomerr_usernotfound'] = 'Unable to find your account on Zoom. If you are using Zoom for the first time, you must activate your Zoom account by logging into <a href="{$a}" target="_blank">{$a}</a>. Once you\'ve activated your Zoom account, reload this page and continue setting up your meeting. Else make sure your email on Zoom matches your email on this system.';
$string['zoomerr_viewrecordings_off'] = 'View Recordings is switched off, task cannot run';
$string['zoomurl'] = 'Zoom home page URL';
$string['zoomurl_desc'] = '';

====================

file: report.php
path: report.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * List all zoom meetings.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

require(__DIR__ . '/../../config.php');
require_once(__DIR__ . '/lib.php');
require_once(__DIR__ . '/locallib.php');
require_once(__DIR__ . '/mod_form.php');
require_once($CFG->libdir . '/moodlelib.php');

require_login();
// Additional access checks in zoom_get_instance_setup().
[$course, $cm, $zoom] = zoom_get_instance_setup();

// Check capability.
$context = context_module::instance($cm->id);
require_capability('mod/zoom:addinstance', $context);

$PAGE->set_url('/mod/zoom/report.php', ['id' => $cm->id]);

$strname = $zoom->name;
$strtitle = get_string('sessions', 'mod_zoom');
$PAGE->navbar->add($strtitle);
$PAGE->set_title("$course->shortname: $strname");
$PAGE->set_heading($course->fullname);
$PAGE->set_pagelayout('incourse');

echo $OUTPUT->header();
echo $OUTPUT->heading($strname);
echo $OUTPUT->heading($strtitle, 4);

$sessions = zoom_get_sessions_for_display($zoom->id);
if (!empty($sessions)) {
    $maskparticipantdata = get_config('zoom', 'maskparticipantdata');
    $table = new html_table();
    $table->head = [
        get_string('title', 'mod_zoom'),
        get_string('starttime', 'mod_zoom'),
        get_string('endtime', 'mod_zoom'),
        get_string('duration', 'mod_zoom'),
        get_string('participants', 'mod_zoom'),
    ];
    $table->align = ['left', 'left', 'left', 'left', 'left'];
    $format = get_string('strftimedatetimeshort', 'langconfig');

    foreach ($sessions as $uuid => $meet) {
        $row = [];
        $row[] = $meet['topic'];
        $row[] = $meet['starttime'];
        $row[] = $meet['endtime'];
        $row[] = format_time($meet['duration']);

        if ($meet['count'] > 0) {
            if ($maskparticipantdata) {
                $row[] = $meet['count']
                         . ' ['
                         . get_string('participantdatanotavailable', 'mod_zoom')
                         . '] '
                         . $OUTPUT->help_icon('participantdatanotavailable', 'mod_zoom');
            } else {
                $url = new moodle_url('/mod/zoom/participants.php', ['id' => $cm->id, 'uuid' => $uuid]);
                $row[] = html_writer::link($url, $meet['count']);
            }
        } else {
            $row[] = 0;
        }

        $table->data[] = $row;
    }
}

if (!empty($table->data)) {
    echo html_writer::table($table);
} else {
    echo $OUTPUT->notification(get_string('nomeetinginstances', 'mod_zoom'), 'notifymessage');
}

echo $OUTPUT->footer();

====================

file: get_meeting_report.php
path: cli/get_meeting_report.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * CLI script to manually get the meeting report.
 *
 * @package    mod_zoom
 * @copyright  2020 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

define('CLI_SCRIPT', true);

require(__DIR__ . '/../../../config.php');
require_once($CFG->libdir . '/clilib.php');

// Now get cli options.
[$options, $unrecognized] = cli_get_params(
    [
        'help' => false,
        'start' => false,
        'end' => false,
        'hostuuid' => false,
        'courseid' => false,
    ],
    [
        'h' => 'help',
    ]
);

if ($unrecognized) {
    $unrecognized = implode("\n  ", $unrecognized);
    cli_error(get_string('cliunknowoption', 'admin', $unrecognized));
}

if ($options['help'] || empty($options['start'] || empty($options['end']))) {
    $help = "CLI script to manually get the meeting report for a given start and end date.

Options:
-h, --help          Print out this help
--start             Required. In YYYY-MM-DD format
--end               Required. In YYYY-MM-DD format
--hostuuid          Optional. Specific host we want to get meetings for.
--courseid          Optional. If given, will find all hosts for course and get meeting reports.

Example:
\$sudo -u www-data /usr/bin/php mod/zoom/cli/get_meeting_report.php --start=2020-03-31 --end=2020-04-01
";
    cli_error($help);
}

$hostuuids = null;
if (!empty($options['hostuuid'])) {
    $hostuuids = [$options['hostuuid']];
} else if (!empty($options['courseid'])) {
    // Find all hosts for course.
    $hostuuids = $DB->get_fieldset_select('zoom', 'DISTINCT host_id', 'course=:courseid', ['courseid' => $options['courseid']]);
    if (empty($hostuuids)) {
        cli_writeln(get_string('nozoomsfound', 'mod_zoom'));
        cli_error('No hosts found for course');
    }
}

// Turn on debugging so we can see the detailed progress.
set_debugging(DEBUG_DEVELOPER, true);

$meetingtask = new mod_zoom\task\get_meeting_reports();
$meetingtask->execute($options['start'], $options['end'], $hostuuids);

cli_writeln('DONE!');

====================

file: styles.css
path: styles.css
codice:
#page-mod-zoom-view a .btn-primary .icon {
    color: white;
}

#mod-zoom-old-meetings-header {
    float: left;
}

#mod-zoom-meeting-room-participants,
#mod-zoom-meeting-room-participant-groups {
    list-style-type: none;
}

#mod-zoom-meeting-rooms-list .empty-alert {
    margin: auto;
    width: 80%;
    padding: 40% 0;
}

#mod-zoom-breakout-rooms-table {
    width: 100%;
    height: 400px;
}

#mod-zoom-breakout-rooms-table td:first-child {
    width: 20%;
}

#mod-zoom-breakout-rooms-table td:nth-child(2) {
    width: 80%;
}

#mod-zoom-breakout-rooms-table .delete-room {
    margin: -34px 5px;
    background: transparent;
    border: none;
}

#page-mod-zoom-participants .mimetypeicon {
    width: 24px;
    height: 24px;
}


====================

file: version.php
path: version.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Defines the version and other meta-info about the plugin.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die();

$plugin->component = 'mod_zoom';
$plugin->version = 2025101600;
$plugin->release = 'v5.4.5';
$plugin->requires = 2019052000;
$plugin->maturity = MATURITY_STABLE;
$plugin->cron = 0;

====================

file: ci.yml
path: .github/workflows/ci.yml
codice:
name: Moodle Plugin CI

on: [push, pull_request]

jobs:
  test:
    runs-on: 'ubuntu-latest'

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: 'postgres'
          POSTGRES_HOST_AUTH_METHOD: 'trust'
        ports:
          - 5432:5432
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 3

      mariadb:
        image: mariadb:10
        env:
          MYSQL_USER: 'root'
          MYSQL_ALLOW_EMPTY_PASSWORD: "true"
          MYSQL_CHARACTER_SET_SERVER: "utf8mb4"
          MYSQL_COLLATION_SERVER: "utf8mb4_unicode_ci"
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval 10s --health-timeout 5s --health-retries 3

    strategy:
      fail-fast: false
      matrix:
        include:
          - php: '8.4'
            moodle-branch: 'main'
            database: 'mariadb'
          - php: '8.4'
            moodle-branch: 'MOODLE_501_STABLE'
            database: 'pgsql'
          - php: '8.4'
            moodle-branch: 'MOODLE_500_STABLE'
            database: 'mariadb'
          - php: '8.3'
            moodle-branch: 'MOODLE_405_STABLE'
            database: 'pgsql'
          - php: '8.2'
            moodle-branch: 'MOODLE_404_STABLE'
            database: 'mariadb'
          - php: '8.0'
            moodle-branch: 'MOODLE_401_STABLE'
            database: 'pgsql'

    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
        with:
          path: plugin

      - name: Setup PHP ${{ matrix.php }}
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ matrix.php }}
          extensions: ${{ matrix.extensions }}
          ini-values: max_input_vars=5000
          # If you are not using code coverage, keep "none". Otherwise, use "pcov" (Moodle 3.10 and up) or "xdebug".
          # If you try to use code coverage with "none", it will fallback to phpdbg (which has known problems).
          coverage: none

      - name: Initialise moodle-plugin-ci
        if: ${{ matrix.php >= '7.4' }}
        run: |
          composer create-project -n --no-dev --prefer-dist moodlehq/moodle-plugin-ci ci ^4

      - name: Initialise moodle-plugin-ci v3
        if: ${{ matrix.php < '7.4' }}
        run: |
          composer create-project -n --no-dev --prefer-dist moodlehq/moodle-plugin-ci ci ^3

      - name: Set up environment
        run: |
          echo $(cd ci/bin; pwd) >> $GITHUB_PATH
          echo $(cd ci/vendor/bin; pwd) >> $GITHUB_PATH
          sudo locale-gen en_AU.UTF-8
          echo "NVM_DIR=$HOME/.nvm" >> $GITHUB_ENV

      - name: Install moodle-plugin-ci
        id: install_ci
        run: |
          moodle-plugin-ci install --plugin ./plugin --db-host=127.0.0.1
        env:
          DB: ${{ matrix.database }}
          MOODLE_BRANCH: ${{ matrix.moodle-branch }}
          MUSTACHE_IGNORE_NAMES: 'mobile_view_page_latest.mustache,mobile_view_page_ionic3.mustache'
          # Uncomment this to run Behat tests using the Moodle App.
          # MOODLE_APP: 'true'

      - name: PHP Lint
        if: ${{ !cancelled() && steps.install_ci.outcome == 'success' }}
        run: moodle-plugin-ci phplint

      - name: PHP Mess Detector
        continue-on-error: true # This step will show errors but will not fail
        if: ${{ !cancelled() && steps.install_ci.outcome == 'success' }}
        run: moodle-plugin-ci phpmd

      - name: Moodle Code Checker
        if: ${{ !cancelled() && steps.install_ci.outcome == 'success' }}
        run: moodle-plugin-ci codechecker --max-warnings 0

      - name: Moodle PHPDoc Checker
        if: ${{ !cancelled() && steps.install_ci.outcome == 'success' && matrix.php >= '7.4' }}
        run: moodle-plugin-ci phpdoc --max-warnings 0

      - name: Moodle PHPDoc Checker v3
        if: ${{ !cancelled() && steps.install_ci.outcome == 'success' && matrix.php < '7.4' }}
        run: moodle-plugin-ci phpdoc

      - name: Validating
        if: ${{ !cancelled() && steps.install_ci.outcome == 'success' }}
        run: moodle-plugin-ci validate

      - name: Check upgrade savepoints
        if: ${{ !cancelled() && steps.install_ci.outcome == 'success' }}
        run: moodle-plugin-ci savepoints

      - name: Mustache Lint
        if: ${{ !cancelled() && steps.install_ci.outcome == 'success' }}
        run: moodle-plugin-ci mustache

      - name: Grunt
        if: ${{ !cancelled() && steps.install_ci.outcome == 'success' }}
        run: moodle-plugin-ci grunt --max-lint-warnings 0 || [ "$MOODLE_BRANCH" = 'MOODLE_39_STABLE' ] || [ "$MOODLE_BRANCH" = 'MOODLE_311_STABLE' ]
        env:
          MOODLE_BRANCH: ${{ matrix.moodle-branch }}

      - name: PHPUnit tests
        if: ${{ !cancelled() && steps.install_ci.outcome == 'success' }}
        run: moodle-plugin-ci phpunit --fail-on-warning

      - name: Behat features
        id: behat
        if: ${{ !cancelled() && steps.install_ci.outcome == 'success' }}
        run: moodle-plugin-ci behat --profile chrome

      - name: Upload Behat Faildump
        if: ${{ failure() && steps.behat.outcome == 'failure' }}
        uses: actions/upload-artifact@v4
        with:
          name: Behat Faildump (${{ join(matrix.*, ', ') }})
          path: ${{ github.workspace }}/moodledata/behat_dump
          retention-days: 7
          if-no-files-found: ignore

      - name: Make sure cancelled jobs are marked as failures.
        if: ${{ cancelled() }}
        run: exit 1

====================

file: mobile_view_page_ionic3.mustache
path: templates/mobile_view_page_ionic3.mustache
codice:
{{!
    This file is part of Moodle - http://moodle.org/

    Moodle is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Moodle is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
}}
{{!
    @template mod_zoom/mobile_view_page_ionic3

    Page to view a zoom meeting

    Classes required for JS:
    * none

    Data attributes required for JS:
    * none

    Example context (json):
    {
        "zoom": {
            "intro": "Introduction String",
            "password": "9836451",
            "recurring": 1,
            "webinar": 1,
            "option_host_video": 1,
            "option_jbh": 1,
            "option_participants_video": 1
        },
        "available": true,
        "status": "Finished",
        "start_time": "Tuesday, June 29, 2021, 1:30 PM",
        "duration": "1 hour",
        "option_audio": "Computer audio and Telephone",
        "cmid": 3,
        "courseid": 3
    }
}}
{{=<% %>=}}
<div>
    <core-course-module-description description="<% zoom.intro %>" component="mod_zoom" componentId="<% cmid %>"></core-course-module-description>

    <ion-list>
        <%#available%>
            <ion-item>
                <button ion-button block color="light" core-site-plugins-call-ws name="mod_zoom_grade_item_update" [params]="{zoomid: <% cmid %>}" [preSets]="{getFromCache: 0, saveToCache: 0}" (onSuccess)="loadMeeting($event)">
                    {{ 'plugin.mod_zoom.join_meeting' | translate }}
                </button>
            </ion-item>
        <%/available%>
        <%^available%>
            <ion-item>
                <p>{{ 'plugin.mod_zoom.unavailable' | translate }}</p>
            </ion-item>
        <%/available%>

        <%#zoom.recurring%>
            <ion-item>
                <p class="item-heading">{{ 'plugin.mod_zoom.recurringmeetinglong' | translate }}</p>
            </ion-item>
        <%/zoom.recurring%>
        <%^zoom.recurring%>
            <ion-item>
                <p class="item-heading">{{ 'plugin.mod_zoom.meeting_time' | translate }}</p>
                <p><% start_time %></p>
            </ion-item>
            <ion-item>
                <p class="item-heading">{{ 'plugin.mod_zoom.duration' | translate }}</p>
                <p><% duration %></p>
            </ion-item>
        <%/zoom.recurring%>

        <ion-item>
            <p class="item-heading">{{ 'plugin.mod_zoom.passwordprotected' | translate }}</p>
            <%#zoom.password%><p>{{ 'core.yes' | translate }}</p><%/zoom.password%>
            <%^zoom.password%><p>{{ 'core.no' | translate }}</p><%/zoom.password%>
        </ion-item>

        <%^zoom.webinar%>
            <ion-item>
                <p class="item-heading">{{ 'plugin.mod_zoom.joinbeforehost' | translate }}</p>
                <%#zoom.option_jbh%><p>{{ 'core.yes' | translate }}</p><%/zoom.option_jbh%>
                <%^zoom.option_jbh%><p>{{ 'core.no' | translate }}</p><%/zoom.option_jbh%>
            </ion-item>
            <ion-item>
                <p class="item-heading">{{ 'plugin.mod_zoom.starthostjoins' | translate }}</p>
                <%#zoom.option_host_video%><p>{{ 'core.yes' | translate }}</p><%/zoom.option_host_video%>
                <%^zoom.option_host_video%><p>{{ 'core.no' | translate }}</p><%/zoom.option_host_video%>
            </ion-item>
            <ion-item>
                <p class="item-heading">{{ 'plugin.mod_zoom.startpartjoins' | translate }}</p>
                <%#zoom.option_participants_video%><p>{{ 'core.yes' | translate }}</p><%/zoom.option_participants_video%>
                <%^zoom.option_participants_video%><p>{{ 'core.no' | translate }}</p><%/zoom.option_participants_video%>
            </ion-item>
        <%/zoom.webinar%>

        <ion-item>
            <p class="item-heading">{{ 'plugin.mod_zoom.option_audio' | translate }}</p>
            <p><% option_audio %></p>
        </ion-item>

        <%^zoom.recurring%>
            <ion-item>
                <p class="item-heading">{{ 'plugin.mod_zoom.status' | translate }}</p>
                <p><% status %></p>
            </ion-item>
        <%/zoom.recurring%>
    </ion-list>
</div>

====================

file: breakoutrooms_rooms.mustache
path: templates/breakoutrooms_rooms.mustache
codice:
{{!
    This file is part of Moodle - http://moodle.org/

    Moodle is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Moodle is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
}}
{{!
    @template mod_zoom/breakoutrooms_rooms

    Context variables required for this template:
    * roomscount Number of rooms.
    * rooms Array of rooms.
    * roomtoclone Room that is being cloned.
      
    Example context (json):
    {
        "roomscount": 1,
        "rooms": [
            {
                "roomid": "1",
                "roomname": "room1",
                "roomactive": true,
                "courseparticipants": [
                    {
                        "participantid": "2",
                        "participantname": "John Doe",
                        "selected": true
                    }
                ],
                "coursegroups": [
                    {
                        "groupid": "3",
                        "groupname": "group3",
                        "selected": true
                    }
                ]
            }
        ],
        "roomtoclone": [
            {
                "toclone": "toclone",
                "courseparticipants": [
                    {
                        "participantid": "2",
                        "participantname": "John Doe"
                    }
                ],
                "coursegroups": [
                    {
                        "groupid": "3",
                        "groupname": "group3"
                    }
                ]
            }
        ]
    }
}}
<table id="mod-zoom-breakout-rooms-table" class="table table-bordered">
  <tr>
    <td>
      <div id="mod-zoom-meeting-rooms-list" data-initial-rooms-count="{{roomscount}}">
        <div class="mb-2">
          <span>{{#str}} rooms, zoom {{/str}}</span>
          <button id="add-room" type="button" title="{{#str}} addroom, zoom {{/str}}" class="btn btn-default btn-sm">
            <span class="fa fa-plus-circle fa-lg" aria-hidden="true"></span>
          </button>
        </div>
        <ul class="nav nav-pills flex-column" role="tablist">
          {{#rooms}}
          <li id="tab-{{roomid}}" class="nav-item">
            <a class="nav-link {{#roomactive}}active{{/roomactive}}" href="#link{{roomid}}" data-toggle="tab" role="tab">
              <span class="tab-name">{{roomname}}</span>
            </a>
            <button type="button" class="pull-right delete-room" title="{{#str}} deleteroom, zoom {{/str}}">
              <span class="fa fa-trash-o fa-lg" aria-hidden="true"></span>
            </button>
          </li>
          {{/rooms}}
        </ul>
        <div class="empty-alert text-center hidden">
          <p><strong>{{#str}} norooms, zoom {{/str}}</strong></p>
          <span>
            {{#str}} addroomalert, zoom {{/str}}
            <span class="fa fa-plus-circle" aria-hidden="true"></span>
          </span>
        </div>
      </div>
    </td>
    <td>
      <div id="mod-zoom-meeting-rooms-data">
        <div class="tab-content">
          {{#rooms}}
          <div class="tab-pane {{#roomactive}}active{{/roomactive}}" id="link{{roomid}}" role="tabpanel">
              {{> zoom/breakoutrooms_room_data }}
          </div>
          {{/rooms}}
        </div>
      </div>
    </td>
  </tr>
</table>

{{#roomtoclone}}
{{> zoom/breakoutrooms_room_datatoclone }}
{{/roomtoclone}}

====================

file: breakoutrooms_room_groups.mustache
path: templates/breakoutrooms_room_groups.mustache
codice:
{{!
    This file is part of Moodle - http://moodle.org/

    Moodle is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Moodle is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
}}
{{!
    @template mod_zoom/breakoutrooms_room_groups

    Context variables required for this template:
    * roomid Room ID.
    * roomname Room name.
    * coursegroups Array of groups. 

    Example context (json):
    {
        "roomid": "1",
        "roomname": "room1",
        "coursegroups": [
            {
                "groupid": "3",
                "groupname": "group3",
                "selected": true
            }
        ]
    }
}}
<div class="card">
    <div class="card-body">
        <select id="groups-{{roomid}}" class="room-groups" name="{{toclone}}roomsgroups[{{roomid}}][]" multiple>
            {{#coursegroups}}
            <option value="{{groupid}}" {{#selected}}selected{{/selected}}>{{groupname}}</option>
            {{/coursegroups}}
        </select>
    </div>
</div>

====================

file: mobile_view_page_latest.mustache
path: templates/mobile_view_page_latest.mustache
codice:
{{!
    This file is part of Moodle - http://moodle.org/

    Moodle is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Moodle is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
}}
{{!
    @template mod_zoom/mobile_view_page_latest

    Page to view a zoom meeting

    Classes required for JS:
    * none

    Data attributes required for JS:
    * none

    Example context (json):
    {
        "zoom": {
            "intro": "Introduction String",
            "password": "9836451",
            "recurring": 1,
            "webinar": 1,
            "option_host_video": 1,
            "option_jbh": 1,
            "option_participants_video": 1
        },
        "available": true,
        "status": "Finished",
        "start_time": "Tuesday, June 29, 2021, 1:30 PM",
        "duration": "1 hour",
        "option_audio": "Computer audio and Telephone",
        "cmid": 3,
        "courseid": 3
    }
}}
{{=<% %>=}}
<div>
    <%#canusemoduleinfo%>
        <core-course-module-info [module]="module" description="<% zoom.intro %>" component="mod_zoom" componentId="<% cmid %>" [courseId]="courseId">
        </core-course-module-info>
    <%/canusemoduleinfo%>
    <%^canusemoduleinfo%>
        <core-course-module-description description="<% zoom.intro %>" component="mod_zoom" componentId="<% cmid %>"></core-course-module-description>
    <%/canusemoduleinfo%>

    <ion-list>
        <%#available%>
            <ion-button class="ion-margin" expand="block" color="light" core-site-plugins-call-ws name="mod_zoom_grade_item_update" [params]="{zoomid: <% cmid %>}" [preSets]="{getFromCache: 0, saveToCache: 0}" (onSuccess)="loadMeeting($event)">
                {{ 'plugin.mod_zoom.join_meeting' | translate }}
            </ion-button>
        <%/available%>
        <%^available%>
            <ion-item>
                <ion-label>
                    <p>{{ 'plugin.mod_zoom.unavailable' | translate }}</p>
                </ion-label>
            </ion-item>
        <%/available%>

        <%#zoom.recurring%>
            <ion-item>
                <ion-label>
                    <p class="item-heading">{{ 'plugin.mod_zoom.recurringmeetinglong' | translate }}</p>
                </ion-label>
            </ion-item>
        <%/zoom.recurring%>
        <%^zoom.recurring%>
            <ion-item>
                <ion-label>
                    <p class="item-heading">{{ 'plugin.mod_zoom.meeting_time' | translate }}</p>
                    <p><% start_time %></p>
                </ion-label>
            </ion-item>
            <ion-item>
                <ion-label>
                    <p class="item-heading">{{ 'plugin.mod_zoom.duration' | translate }}</p>
                    <p><% duration %></p>
                </ion-label>
            </ion-item>
        <%/zoom.recurring%>

        <ion-item>
            <ion-label>
                <p class="item-heading">{{ 'plugin.mod_zoom.passwordprotected' | translate }}</p>
                <%#zoom.password%><p>{{ 'core.yes' | translate }}</p><%/zoom.password%>
                <%^zoom.password%><p>{{ 'core.no' | translate }}</p><%/zoom.password%>
            </ion-label>
        </ion-item>

        <%^zoom.webinar%>
            <ion-item>
                <ion-label>
                    <p class="item-heading">{{ 'plugin.mod_zoom.joinbeforehost' | translate }}</p>
                    <%#zoom.option_jbh%><p>{{ 'core.yes' | translate }}</p><%/zoom.option_jbh%>
                    <%^zoom.option_jbh%><p>{{ 'core.no' | translate }}</p><%/zoom.option_jbh%>
                </ion-label>
            </ion-item>
            <ion-item>
                <ion-label>
                    <p class="item-heading">{{ 'plugin.mod_zoom.starthostjoins' | translate }}</p>
                    <%#zoom.option_host_video%><p>{{ 'core.yes' | translate }}</p><%/zoom.option_host_video%>
                    <%^zoom.option_host_video%><p>{{ 'core.no' | translate }}</p><%/zoom.option_host_video%>
                </ion-label>
            </ion-item>
            <ion-item>
                <ion-label>
                    <p class="item-heading">{{ 'plugin.mod_zoom.startpartjoins' | translate }}</p>
                    <%#zoom.option_participants_video%><p>{{ 'core.yes' | translate }}</p><%/zoom.option_participants_video%>
                    <%^zoom.option_participants_video%><p>{{ 'core.no' | translate }}</p><%/zoom.option_participants_video%>
                </ion-label>
            </ion-item>
        <%/zoom.webinar%>

        <ion-item>
            <ion-label>
                <p class="item-heading">{{ 'plugin.mod_zoom.option_audio' | translate }}</p>
                <p><% option_audio %></p>
            </ion-label>
        </ion-item>

        <%^zoom.recurring%>
            <ion-item>
                <ion-label>
                    <p class="item-heading">{{ 'plugin.mod_zoom.status' | translate }}</p>
                    <p><% status %></p>
                </ion-label>
            </ion-item>
        <%/zoom.recurring%>
    </ion-list>
</div>

====================

file: breakoutrooms_room_participants.mustache
path: templates/breakoutrooms_room_participants.mustache
codice:
{{!
    This file is part of Moodle - http://moodle.org/

    Moodle is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Moodle is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
}}
{{!
    @template mod_zoom/breakoutrooms_room_participants

    Context variables required for this template:
    * roomid Room ID.
    * roomname Room name.
    * courseparticipants Array of participants.

    Example context (json):
    {
        "roomid": "1",
        "roomname": "room1",
        "courseparticipants": [
            {
                "participantid": "2",
                "participantname": "John Doe",
                "selected": true
            }
        ]
    }
}}
<div class="card">
    <div class="card-body">
        <select id="participants-{{roomid}}" class="room-participants" name="{{toclone}}roomsparticipants[{{roomid}}][]" multiple>
            {{#courseparticipants}}
            <option value="{{participantid}}" {{#selected}}selected{{/selected}}>{{participantname}}</option>
            {{/courseparticipants}}
        </select>
    </div>
</div>

====================

file: breakoutrooms_room_datatoclone.mustache
path: templates/breakoutrooms_room_datatoclone.mustache
codice:
{{!
    This file is part of Moodle - http://moodle.org/

    Moodle is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Moodle is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
}}
{{!
    @template mod_zoom/breakoutrooms_room_datatoclone

    Context variables required for this template:
    * roomid Room ID.
    * roomname Room name.
    * courseparticipants Array of participants.
    * coursegroups Array of groups. 
      
    Example context (json):
    {
        "roomid": "1",
        "roomname": "room1",
        "courseparticipants": [
            {
                "participantid": "2",
                "participantname": "John Doe",
                "selected": true
            }
        ],
        "coursegroups": [
            {
                "groupid": "3",
                "groupname": "group3",
                "selected": true
            }
        ]
    }
}}
<div id="data-to-clone" class="hidden">
    <ul id="rooms-list-item" role="tablist">
        <li class="nav-item">
            <a class="nav-link" href="" data-toggle="tab" role="tab">
                <span class="tab-name"></span>
            </a>
            <button type="button" class="pull-right delete-room" title="{{#str}} deleteroom, zoom {{/str}}">
              <span class="fa fa-trash-o fa-lg" aria-hidden="true"></span>
            </button>
        </li>
    </ul>
    <div id="rooms-list-item-data">
        <div class="tab-pane" role="tabpanel">
            {{> zoom/breakoutrooms_room_data }}
        </div>
    </div>
</div>

====================

file: breakoutrooms_room_data.mustache
path: templates/breakoutrooms_room_data.mustache
codice:
{{!
    This file is part of Moodle - http://moodle.org/

    Moodle is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Moodle is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
}}
{{!
    @template mod_zoom/breakoutrooms_room_data

    Context variables required for this template:
    * roomid Room ID.
    * roomname Room name.
    * courseparticipants Array of participants.
    * coursegroups Array of groups.
      
    Example context (json):
    {
        "roomid": "1",
        "roomname": "room1",
        "courseparticipants": [
            {
                "participantid": "2",
                "participantname": "John Doe",
                "selected": true
            }
        ],
        "coursegroups": [
            {
                "groupid": "3",
                "groupname": "group3",
                "selected": true
            }
        ]
    }
}}
<label for="room-name-{{roomid}}">{{#str}} roomname, zoom {{/str}}</label>
<input type="text" class="form-control col-sm-6 room-name" id="room-name-{{roomid}}" name="room-name-{{roomid}}" value="{{roomname}}">
<input type="hidden" name="{{toclone}}rooms[{{roomid}}]" value="{{roomname}}">
<hr>
<span>{{#str}} participants, zoom {{/str}}</span>
{{> zoom/breakoutrooms_room_participants }}
<hr>
<span>{{#str}} participantgroups, zoom {{/str}}</span>
{{> zoom/breakoutrooms_room_groups }}

====================

file: mobile.php
path: classes/output/mobile.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Mobile support for zoom.
 *
 * @package     mod_zoom
 * @copyright   2018 Nick Stefanski <nmstefanski@gmail.com>
 * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\output;

use context_module;
use mod_zoom\external;

/**
 * Mobile output class for zoom
 */
class mobile {
    /**
     * Returns the zoom course view for the mobile app,
     *  including meeting details and launch button (if applicable).
     * @param  array $args Arguments from tool_mobile_get_content WS
     *
     * @return array   HTML, javascript and otherdata
     */
    public static function mobile_course_view($args) {
        global $OUTPUT, $DB;

        $args = (object) $args;
        $versionname = $args->appversioncode >= 3950 ? 'latest' : 'ionic3';
        $cm = get_coursemodule_from_id('zoom', $args->cmid);

        // Capabilities check.
        require_login($args->courseid, false, $cm, true, true);

        $context = context_module::instance($cm->id);

        require_capability('mod/zoom:view', $context);
        // Right now we're just implementing basic viewing, otherwise we may
        // need to check other capabilities.
        $zoom = $DB->get_record('zoom', ['id' => $cm->instance]);

        // WS to get zoom state.
        try {
            $zoomstate = external::get_state($cm->id);
        } catch (\Exception $e) {
            $zoomstate = [];
        }

        // Format date and time.
        $starttime = userdate($zoom->start_time);
        $duration = format_time($zoom->duration);

        // Get audio option string.
        $optionaudio = get_string('audio_' . $zoom->option_audio, 'mod_zoom');

        $data = [
            'zoom' => $zoom,
            'available' => $zoomstate['available'],
            'status' => $zoomstate['status'],
            'start_time' => $starttime,
            'duration' => $duration,
            'option_audio' => $optionaudio,
            'cmid' => $cm->id,
            'courseid' => $args->courseid,
            'canusemoduleinfo' => $args->appversioncode >= 44000,
        ];

        return [
            'templates' => [
                [
                    'id' => 'main',
                    'html' => $OUTPUT->render_from_template("mod_zoom/mobile_view_page_$versionname", $data),
                ],
            ],
            'javascript' => "this.loadMeeting = function(result) { window.open(result.joinurl, '_system'); };",
            // This JS will redirect to a joinurl passed by the mod_zoom_grade_item_update WS.
            'otherdata' => '',
            'files' => '',
        ];
    }
}

====================

file: webservice_exception.php
path: classes/webservice_exception.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Exception class for Zoom API errors.
 *
 * @package   mod_zoom
 * @copyright 2023 Jonathan Champ <jrchamp@ncsu.edu>
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

use moodle_exception;

/**
 * Webservice exception class.
 */
class webservice_exception extends moodle_exception {
    /**
     * Web service response.
     * @var string
     */
    public $response = null;

    /**
     * Web service error code.
     * @var int
     */
    public $zoomerrorcode = null;

    /**
     * Constructor
     *
     * @param string $response Webservice response body.
     * @param int $zoomerrorcode Webservice response error code.
     * @param string $errorcode The name of the string from error.php to print
     * @param string $module name of module
     * @param string $link The url where the user will be directed. Else, the user will be directed to the site index page.
     * @param mixed $a Extra words and phrases that might be required in the error string
     * @param string $debuginfo optional debugging information
     */
    public function __construct($response, $zoomerrorcode, $errorcode, $module = '', $link = '', $a = null, $debuginfo = null) {
        $this->response = $response;
        $this->zoomerrorcode = $zoomerrorcode;

        parent::__construct($errorcode, $module, $link, $a, $debuginfo);
    }
}

====================

file: social_breadth.php
path: classes/analytics/indicator/social_breadth.php
codice:
<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Social breadth indicator.
 *
 * @package   mod_zoom
 * @copyright 2020 Catalyst IT
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\analytics\indicator;

use cm_info;
use lang_string;

/**
 * Social breadth indicator.
 */
class social_breadth extends activity_base {
    /**
     * Returns the name.
     *
     * If there is a corresponding '_help' string this will be shown as well.
     *
     * @return object
     */
    public static function get_name(): lang_string {
        return new lang_string('indicator:socialbreadth', 'mod_zoom');
    }

    /**
     * Returns the indicator type.
     *
     * @return integer
     */
    public function get_indicator_type() {
        return self::INDICATOR_SOCIAL;
    }

    /**
     * Returns the social breadth level.
     *
     * @param cm_info $cm
     *
     * @return integer
     */
    public function get_social_breadth_level(cm_info $cm) {
        return self::SOCIAL_LEVEL_2;
    }
}

====================

file: activity_base.php
path: classes/analytics/indicator/activity_base.php
codice:
<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Activity base class.
 *
 * @package   mod_zoom
 * @copyright 2020 Catalyst IT
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\analytics\indicator;

use core_analytics\local\indicator\community_of_inquiry_activity;

/**
 * Activity base class.
 */
abstract class activity_base extends community_of_inquiry_activity {
    /**
     * Grading not implemented.
     *
     * @return bool
     */
    public function feedback_check_grades() {
        return false;
    }
}

====================

file: cognitive_depth.php
path: classes/analytics/indicator/cognitive_depth.php
codice:
<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Cognitive depth indicator - zoom.
 *
 * @package   mod_zoom
 * @copyright 2020 Catalyst IT
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\analytics\indicator;

use cm_info;
use lang_string;

/**
 * Cognitive depth indicator - zoom.
 */
class cognitive_depth extends activity_base {
    /**
     * Returns the name.
     *
     * @return object
     */
    public static function get_name(): lang_string {
        return new lang_string('indicator:cognitivedepth', 'mod_zoom');
    }

    /**
     * Returns the indicator type.
     *
     * @return integer
     */
    public function get_indicator_type() {
        return self::INDICATOR_COGNITIVE;
    }

    /**
     * Returns the cognitive depth level.
     *
     * @param cm_info $cm
     *
     * @return integer
     */
    public function get_cognitive_depth_level(cm_info $cm) {
        return self::COGNITIVE_LEVEL_1;
    }
}

====================

file: external.php
path: classes/external.php
codice:
<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Zoom external API
 *
 * @package    mod_zoom
 * @category   external
 * @author     Nick Stefanski <nstefanski@escoffier.edu>
 * @copyright  2017 Auguste Escoffier School of Culinary Arts {@link https://www.escoffier.edu}
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 * @since      Moodle 3.1
 */

namespace mod_zoom;

defined('MOODLE_INTERNAL') || die;

require_once("$CFG->libdir/externallib.php");

use context_module;
use external_api;
use external_function_parameters;
use external_single_structure;
use external_value;
use external_warnings;
use invalid_response_exception;

/**
 * Zoom external functions
 */
class external extends external_api {
    /**
     * Returns description of method parameters
     *
     * @return external_function_parameters
     * @since Moodle 3.1
     */
    public static function get_state_parameters() {
        return new external_function_parameters(
            [
                'zoomid' => new external_value(PARAM_INT, 'zoom course module id'),
            ]
        );
    }

    /**
     * Determine if a zoom meeting is available, meeting status, and the start time, duration, and other meeting options.
     * This function grabs most of the options to display for users in /mod/zoom/view.php
     * Host functions are not currently supported
     *
     * @param int $zoomid the zoom course module id
     * @return array of warnings and status result
     * @since Moodle 3.1
     * @throws moodle_exception
     */
    public static function get_state($zoomid) {
        global $DB, $CFG;
        require_once($CFG->dirroot . "/mod/zoom/locallib.php");

        $params = self::validate_parameters(
            self::get_state_parameters(),
            [
                'zoomid' => $zoomid,
            ]
        );
        $warnings = [];

        // Request and permission validation.
        $cm = $DB->get_record('course_modules', ['id' => $params['zoomid']], '*', MUST_EXIST);
        $zoom = $DB->get_record('zoom', ['id' => $cm->instance], '*', MUST_EXIST);

        $context = context_module::instance($cm->id);
        self::validate_context($context);

        require_capability('mod/zoom:view', $context);

        // Call the zoom/locallib API.
        [$inprogress, $available, $finished] = zoom_get_state($zoom);

        $result = [];
        $result['available'] = $available;

        if ($zoom->recurring) {
            $result['start_time'] = 0;
            $result['duration'] = 0;
        } else {
            $result['start_time'] = $zoom->start_time;
            $result['duration'] = $zoom->duration;
        }

        $result['haspassword'] = (isset($zoom->password) && $zoom->password !== '');
        $result['joinbeforehost'] = $zoom->option_jbh;
        $result['startvideohost'] = $zoom->option_host_video;
        $result['startvideopart'] = $zoom->option_participants_video;
        $result['audioopt'] = $zoom->option_audio;

        if (!$zoom->recurring) {
            if ($zoom->exists_on_zoom == ZOOM_MEETING_EXPIRED) {
                $status = get_string('meeting_nonexistent_on_zoom', 'mod_zoom');
            } else if ($finished) {
                $status = get_string('meeting_finished', 'mod_zoom');
            } else if ($inprogress) {
                $status = get_string('meeting_started', 'mod_zoom');
            } else {
                $status = get_string('meeting_not_started', 'mod_zoom');
            }
        } else {
            $status = get_string('recurringmeetinglong', 'mod_zoom');
        }

        $result['status'] = $status;

        $result['warnings'] = $warnings;
        return $result;
    }

    /**
     * Returns description of method result value
     *
     * @return external_description
     * @since Moodle 3.1
     */
    public static function get_state_returns() {
        return new external_single_structure(
            [
                'available' => new external_value(PARAM_BOOL, 'if true, run grade_item_update and redirect to meeting url'),

                'start_time' => new external_value(PARAM_INT, 'meeting start time as unix timestamp (0 if recurring)'),
                'duration' => new external_value(PARAM_INT, 'meeting duration in seconds (0 if recurring)'),

                'haspassword' => new external_value(PARAM_BOOL, ''),
                'joinbeforehost' => new external_value(PARAM_BOOL, ''),
                'startvideohost' => new external_value(PARAM_BOOL, ''),
                'startvideopart' => new external_value(PARAM_BOOL, ''),
                'audioopt' => new external_value(PARAM_TEXT, ''),

                'status' => new external_value(PARAM_TEXT, 'meeting status: not_started, started, finished, expired, recurring'),

                'warnings' => new external_warnings(),
            ]
        );
    }

    /**
     * Returns description of method parameters
     *
     * @return external_function_parameters
     * @since Moodle 3.1
     */
    public static function grade_item_update_parameters() {
        return new external_function_parameters(
            [
                'zoomid' => new external_value(PARAM_INT, 'zoom course module id'),
            ]
        );
    }

    /**
     * Creates or updates grade item for the given zoom instance and returns join url.
     * This function grabs most of the options to display for users in /mod/zoom/view.php
     *
     * @param int $zoomid the zoom course module id
     * @return array of warnings and status result
     * @since Moodle 3.1
     * @throws moodle_exception
     */
    public static function grade_item_update($zoomid) {
        global $CFG;
        require_once($CFG->dirroot . '/mod/zoom/locallib.php');

        $params = self::validate_parameters(
            self::get_state_parameters(),
            [
                'zoomid' => $zoomid,
            ]
        );
        $warnings = [];

        $context = context_module::instance($params['zoomid']);
        self::validate_context($context);

        // Call load meeting function, do not use start url on mobile.
        $meetinginfo = zoom_load_meeting($params['zoomid'], $context, $usestarturl = false);

        // Pass url to join zoom meeting in order to redirect user.
        $result = [];
        if ($meetinginfo['nexturl']) {
            $result['status'] = true;
            $result['joinurl'] = $meetinginfo['nexturl']->__toString();
        } else {
            $warningmsg = clean_param($meetinginfo['error'], PARAM_TEXT);
            throw new invalid_response_exception($warningmsg);
        }

        $result['warnings'] = $warnings;
        return $result;
    }

    /**
     * Returns description of method result value
     *
     * @return external_description
     * @since Moodle 3.1
     */
    public static function grade_item_update_returns() {
        return new external_single_structure(
            [
                'status' => new external_value(PARAM_BOOL, 'status: true if success'),
                'joinurl' => new external_value(PARAM_RAW, 'Zoom meeting join url'),
                'warnings' => new external_warnings(),
            ]
        );
    }
}

====================

file: provider.php
path: classes/privacy/provider.php
codice:
<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Contains class mod_zoom\privacy\provider
 *
 * @package    mod_zoom
 * @copyright  2018 UC Regents
 * @author     Kubilay Agi
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\privacy;

use context;
use context_module;
use core_privacy\local\metadata\collection;
use core_privacy\local\metadata\provider as metadata_provider;
use core_privacy\local\request\approved_contextlist;
use core_privacy\local\request\approved_userlist;
use core_privacy\local\request\contextlist;
use core_privacy\local\request\core_userlist_provider;
use core_privacy\local\request\helper;
use core_privacy\local\request\plugin\provider as request_plugin_provider;
use core_privacy\local\request\transform;
use core_privacy\local\request\userlist;
use core_privacy\local\request\writer;

/**
 * Ad hoc task that performs the actions for approved data privacy requests.
 */
class provider implements core_userlist_provider, metadata_provider, request_plugin_provider {
    /**
     * Returns meta data about this system.
     *
     * @param   collection $coll The collection to add metadata to.
     * @return  collection  The array of metadata
     */
    public static function get_metadata(collection $coll): collection {
        // Add all user data fields to the collection.

        $coll->add_database_table('zoom_meeting_participants', [
            'name' => 'privacy:metadata:zoom_meeting_participants:name',
            'user_email' => 'privacy:metadata:zoom_meeting_participants:user_email',
            'join_time' => 'privacy:metadata:zoom_meeting_participants:join_time',
            'leave_time' => 'privacy:metadata:zoom_meeting_participants:leave_time',
            'duration' => 'privacy:metadata:zoom_meeting_participants:duration',
        ], 'privacy:metadata:zoom_meeting_participants');

        $coll->add_database_table(
            'zoom_meeting_details',
            ['topic' => 'privacy:metadata:zoom_meeting_details:topic'],
            'privacy:metadata:zoom_meeting_details'
        );

        $coll->add_database_table(
            'zoom_meeting_recordings_view',
            ['userid' => 'privacy:metadata:zoom_meeting_view:userid'],
            'privacy:metadata:zoom_meeting_view'
        );

        $coll->add_database_table(
            'zoom_breakout_participants',
            ['userid' => 'privacy:metadata:zoom_breakout_participants:userid'],
            'privacy:metadata:zoom_breakout_participants'
        );

        return $coll;
    }

    /**
     * Get the list of contexts that contain user information for the specified user.
     *
     * @param   int $userid The user to search.
     * @return  contextlist   $contextlist  The list of contexts used in this plugin.
     */
    public static function get_contexts_for_userid(int $userid): contextlist {
        // Query the database for context IDs give a specific user ID and return these to the user.

        $contextlist = new contextlist();

        $sql = 'SELECT c.id
                  FROM {context} c
            INNER JOIN {course_modules} cm ON cm.id = c.instanceid AND c.contextlevel = :contextlevel
            INNER JOIN {modules} m ON m.id = cm.module AND m.name = :modname
            INNER JOIN {zoom} z ON z.id = cm.instance
            LEFT JOIN {zoom_meeting_details} zmd ON zmd.zoomid = z.id
            LEFT JOIN {zoom_meeting_participants} zmp ON zmp.detailsid = zmd.id
            LEFT JOIN {zoom_meeting_recordings} zmr ON zmr.zoomid = z.id
            LEFT JOIN {zoom_meeting_recordings_view} zmrv ON zmrv.recordingsid = zmr.id
                 WHERE zmp.userid = :userid1 OR zmrv.userid = :userid2
        ';

        $params = [
            'modname' => 'zoom',
            'contextlevel' => CONTEXT_MODULE,
            'userid1' => $userid,
            'userid2' => $userid,
        ];

        $contextlist->add_from_sql($sql, $params);

        return $contextlist;
    }

    /**
     * Get the list of users who have data within a context.
     *
     * @param   userlist    $userlist   The userlist containing the list of users who have data in this context/plugin combination.
     */
    public static function get_users_in_context(userlist $userlist) {
        $context = $userlist->get_context();

        if (!($context instanceof context_module)) {
            return;
        }

        $params = [
            'instanceid' => $context->instanceid,
            'modulename' => 'zoom',
        ];

        $sql = "SELECT zmp.userid
                  FROM {zoom_meeting_participants} zmp
                  JOIN {zoom_meeting_details} zmd ON zmd.id = zmp.detailsid
                  JOIN {zoom} z ON zmd.zoomid = z.id
                  JOIN {modules} m ON m.name = :modulename
                  JOIN {course_modules} cm ON z.id = cm.instance AND m.id = cm.module
                 WHERE cm.id = :instanceid";

        $userlist->add_from_sql('userid', $sql, $params);

        $sql = "SELECT zmrv.userid
                  FROM {zoom_meeting_recordings_view} zmrv
                  JOIN {zoom_meeting_recordings} zmr ON zmr.id = zmrv.recordingsid
                  JOIN {zoom} z ON zmr.zoomid = z.id
                  JOIN {modules} m ON m.name = :modulename
                  JOIN {course_modules} cm ON z.id = cm.instance AND m.id = cm.module
                 WHERE cm.id = :instanceid";

        $userlist->add_from_sql('userid', $sql, $params);

        $sql = "SELECT zbp.userid
                  FROM {zoom_breakout_participants} zbp
                  JOIN {zoom_meeting_breakout_rooms} zmbr ON zbp.breakoutroomid = zmbr.id
                  JOIN {zoom} z ON zmbr.zoomid = z.id
                  JOIN {modules} m ON m.name = :modulename
                  JOIN {course_modules} cm ON z.id = cm.instance AND m.id = cm.module
                 WHERE cm.id = :instanceid";

        $userlist->add_from_sql('userid', $sql, $params);
    }

    /**
     * Export all user data for the specified user, in the specified contexts, using the supplied exporter instance.
     *
     * @param   approved_contextlist    $contextlist    The approved contexts to export information for.
     * @link http://tandl.churchward.ca/2018/06/implementing-moodles-privacy-api-in.html
     */
    public static function export_user_data(approved_contextlist $contextlist) {
        global $DB;

        if (empty($contextlist->count())) {
            return;
        }

        $user = $contextlist->get_user();

        [$contextsql, $contextparams] = $DB->get_in_or_equal($contextlist->get_contextids(), SQL_PARAMS_NAMED);

        $sql = "SELECT zmp.id,
                       zmd.topic,
                       zmp.name,
                       zmp.user_email,
                       zmp.join_time,
                       zmp.leave_time,
                       zmp.duration,
                       cm.id AS cmid
                  FROM {context} c
            INNER JOIN {course_modules} cm ON cm.id = c.instanceid AND c.contextlevel = :contextlevel
            INNER JOIN {modules} m ON m.id = cm.module AND m.name = :modname
            INNER JOIN {zoom} z ON z.id = cm.instance
            INNER JOIN {zoom_meeting_details} zmd ON zmd.zoomid = z.id
            INNER JOIN {zoom_meeting_participants} zmp ON zmp.detailsid = zmd.id
                 WHERE c.id $contextsql
                       AND zmp.userid = :userid
              ORDER BY cm.id ASC
        ";

        $params = [
            'modname' => 'zoom',
            'contextlevel' => CONTEXT_MODULE,
            'userid' => $user->id,
        ] + $contextparams;

        $participantinstances = $DB->get_recordset_sql($sql, $params);
        foreach ($participantinstances as $participantinstance) {
            $context = context_module::instance($participantinstance->cmid);
            $contextdata = helper::get_context_data($context, $user);

            $instancedata = [
                'topic' => $participantinstance->topic,
                'participant_name' => $participantinstance->name,
                'user_email' => $participantinstance->user_email,
                'join_time' => transform::datetime($participantinstance->join_time),
                'leave_time' => transform::datetime($participantinstance->leave_time),
                'duration' => $participantinstance->duration,
            ];

            $contextdata = (object) array_merge((array) $contextdata, $instancedata);
            writer::with_context($context)->export_data([], $contextdata);
        }

        $participantinstances->close();

        $sql = "SELECT zmrv.id,
                       zmr.name,
                       zmrv.userid,
                       zmrv.viewed,
                       zmrv.timemodified,
                       cm.id AS cmid
                  FROM {context} c
            INNER JOIN {course_modules} cm ON cm.id = c.instanceid AND c.contextlevel = :contextlevel
            INNER JOIN {modules} m ON m.id = cm.module AND m.name = :modname
            INNER JOIN {zoom} z ON z.id = cm.instance
            INNER JOIN {zoom_meeting_recordings} zmr ON zmr.zoomid = z.id
            INNER JOIN {zoom_meeting_recordings_view} zmrv ON zmrv.recordingsid = zmr.id
                 WHERE c.id $contextsql
                       AND zmrv.userid = :userid
              ORDER BY cm.id ASC
        ";

        $params = [
            'modname' => 'zoom',
            'contextlevel' => CONTEXT_MODULE,
            'userid' => $user->id,
        ] + $contextparams;

        $recordingviewinstances = $DB->get_recordset_sql($sql, $params);
        foreach ($recordingviewinstances as $recordingviewinstance) {
            $context = context_module::instance($recordingviewinstance->cmid);
            $contextdata = helper::get_context_data($context, $user);

            $instancedata = [
                'recording_name' => $recordingviewinstance->name,
                'userid' => $recordingviewinstance->userid,
                'viewed' => $recordingviewinstance->viewed,
                'timemodified' => transform::datetime($recordingviewinstance->timemodified),
            ];

            $contextdata = (object) array_merge((array) $contextdata, $instancedata);
            writer::with_context($context)->export_data([], $contextdata);
        }

        $recordingviewinstances->close();
    }

    /**
     * Delete all personal data for all users in the specified context.
     *
     * @param context $context Context to delete data from.
     */
    public static function delete_data_for_all_users_in_context(context $context) {
        global $DB;

        if (!($context instanceof context_module)) {
            return;
        }

        // We delete each participant entry manually because deletes do not cascade.
        if ($cm = get_coursemodule_from_id('zoom', $context->instanceid)) {
            $meetingdetails = $DB->get_records('zoom_meeting_details', ['zoomid' => $cm->instance]);
            foreach ($meetingdetails as $meetingdetail) {
                $DB->delete_records('zoom_meeting_participants', ['detailsid' => $meetingdetail->id]);
            }

            $DB->delete_records('zoom_meeting_details', ['zoomid' => $cm->instance]);

            $meetingrecordings = $DB->get_records('zoom_meeting_recordings', ['zoomid' => $cm->instance]);
            foreach ($meetingrecordings as $recording) {
                $DB->delete_records('zoom_meeting_recordings_view', ['recordingsid' => $recording->id]);
            }

            $DB->delete_records('zoom_meeting_recordings', ['zoomid' => $cm->instance]);

            $breakoutrooms = $DB->get_records('zoom_meeting_breakout_rooms', ['zoomid' => $cm->instance]);
            foreach ($breakoutrooms as $room) {
                $DB->delete_records('zoom_breakout_participants', ['breakoutroomid' => $room->id]);
            }

            $DB->delete_records('zoom_meeting_breakout_rooms', ['zoomid' => $cm->instance]);
        }
    }

    /**
     * Delete all user data for the specified user, in the specified contexts.
     *
     * @param   approved_contextlist    $contextlist    The approved contexts and user information to delete information for.
     */
    public static function delete_data_for_user(approved_contextlist $contextlist) {
        global $DB;

        if (empty($contextlist->count())) {
            return;
        }

        $user = $contextlist->get_user();

        foreach ($contextlist->get_contexts() as $context) {
            if (!($context instanceof context_module)) {
                continue;
            }

            if ($cm = get_coursemodule_from_id('zoom', $context->instanceid)) {
                $meetingdetails = $DB->get_records('zoom_meeting_details', ['zoomid' => $cm->instance]);
                foreach ($meetingdetails as $meetingdetail) {
                    $DB->delete_records('zoom_meeting_participants', ['detailsid' => $meetingdetail->id, 'userid' => $user->id]);
                }

                $meetingrecordings = $DB->get_records('zoom_meeting_recordings', ['zoomid' => $cm->instance]);
                foreach ($meetingrecordings as $recording) {
                    $DB->delete_records('zoom_meeting_recordings_view', ['recordingsid' => $recording->id, 'userid' => $user->id]);
                }

                $breakoutrooms = $DB->get_records('zoom_meeting_breakout_rooms', ['zoomid' => $cm->instance]);
                foreach ($breakoutrooms as $room) {
                    $DB->delete_records('zoom_breakout_participants', ['breakoutroomid' => $room->id, 'userid' => $user->id]);
                }
            }
        }
    }

    /**
     * Delete multiple users within a single context.
     *
     * @param   approved_userlist       $userlist The approved context and user information to delete information for.
     */
    public static function delete_data_for_users(approved_userlist $userlist) {
        global $DB;
        $context = $userlist->get_context();

        if (!($context instanceof context_module)) {
            return;
        }

        // Prepare SQL to gather all completed IDs.
        $userids = $userlist->get_userids();
        [$insql, $inparams] = $DB->get_in_or_equal($userids, SQL_PARAMS_NAMED);
        $params = array_merge($inparams, ['contextid' => $context->id, 'modlevel' => CONTEXT_MODULE]);

        $sql = "SELECT zmd.id
                  FROM {zoom_meeting_details} zmd
                  JOIN {zoom} z ON zmd.zoomid = z.id
                  JOIN {modules} m ON m.name = 'zoom'
                  JOIN {course_modules} cm ON z.id = cm.instance AND m.id = cm.module
                  JOIN {context} ctx ON ctx.instanceid = cm.id AND ctx.contextlevel = :modlevel
                 WHERE ctx.id = :contextid";

        $DB->delete_records_select('zoom_meeting_participants', "userid $insql AND detailsid IN ($sql)", $params);

        $sql = "SELECT zmr.id
                  FROM {zoom_meeting_recordings} zmr
                  JOIN {zoom} z ON zmr.zoomid = z.id
                  JOIN {modules} m ON m.name = 'zoom'
                  JOIN {course_modules} cm ON z.id = cm.instance AND m.id = cm.module
                  JOIN {context} ctx ON cm.id = ctx.instanceid AND ctx.contextlevel = :modlevel
                 WHERE ctx.id = :contextid";

        $DB->delete_records_select('zoom_meeting_recordings_view', "userid $insql AND recordingsid IN ($sql)", $params);

        $sql = "SELECT zmbr.id
                  FROM {zoom_meeting_breakout_rooms} zmbr
                  JOIN {zoom} z ON zmbr.zoomid = z.id
                  JOIN {modules} m ON m.name = 'zoom'
                  JOIN {course_modules} cm ON z.id = cm.instance AND m.id = cm.module
                  JOIN {context} ctx ON ctx.instanceid = cm.id AND ctx.contextlevel = :modlevel
                 WHERE ctx.id = :contextid";

        $DB->delete_records_select('zoom_breakout_participants', "userid $insql AND breakoutroomid IN ($sql)", $params);
    }
}

====================

file: dates.php
path: classes/dates.php
codice:
<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Contains the class for fetching the important dates in mod_zoom for a given module instance and a user.
 *
 * @package   mod_zoom
 * @copyright 2021 Shamim Rezaie <shamim@moodle.com>
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

declare(strict_types=1);

namespace mod_zoom;

use core\activity_dates;

/**
 * Class for fetching the important dates in mod_zoom for a given module instance and a user.
 *
 * @copyright 2021 Shamim Rezaie <shamim@moodle.com>
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class dates extends activity_dates {
    /**
     * Returns a list of important dates in mod_zoom
     *
     * @return array
     */
    protected function get_dates(): array {
        $starttime = $this->cm->customdata['start_time'] ?? null;
        $duration = $this->cm->customdata['duration'] ?? null;
        $recurring = $this->cm->customdata['recurring'] ?? null;
        $recurrencetype = $this->cm->customdata['recurrence_type'] ?? null;

        // For meeting with no fixed time, no time info needed on course page.
        if ($recurring && $recurrencetype == \ZOOM_RECURRINGTYPE_NOTIME) {
            return [];
        }

        $dates = [];

        if ($starttime) {
            $now = time();
            if ($duration && $starttime + $duration < $now) {
                // Meeting has ended.
                $dataid = 'end_date_time';
                $labelid = 'activitydate:ended';
                $meetimgtimestamp = $starttime + $duration;
            } else {
                // Meeting hasn't started / in progress.
                $dataid = 'start_time';
                $labelid = $starttime > $now ? 'activitydate:starts' : 'activitydate:started';
                $meetimgtimestamp = $starttime;
            }

            $dates[] = [
                'dataid' => $dataid,
                'label' => get_string($labelid, 'mod_zoom'),
                'timestamp' => $meetimgtimestamp,
            ];
        }

        return $dates;
    }
}

====================

file: webservice.php
path: classes/webservice.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Handles API calls to Zoom REST API.
 *
 * @package   mod_zoom
 * @copyright 2015 UC Regents
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot . '/mod/zoom/lib.php');
require_once($CFG->dirroot . '/mod/zoom/locallib.php');
require_once($CFG->libdir . '/filelib.php');

use cache;
use core_user;
use curl;
use moodle_exception;
use stdClass;

/**
 * Web service class.
 */
class webservice {
    /**
     * API calls: maximum number of retries.
     * @var int
     */
    public const MAX_RETRIES = 5;

    /**
     * Default meeting_password_requirement object.
     * @var array
     */
    public const DEFAULT_MEETING_PASSWORD_REQUIREMENT = [
        'length' => 0,
        'consecutive_characters_length' => 0,
        'have_letter' => false,
        'have_number' => false,
        'have_upper_and_lower_characters' => false,
        'have_special_character' => false,
        'only_allow_numeric' => false,
        'weak_enhance_detection' => false,
    ];

    /**
     * Client ID
     * @var string
     */
    protected $clientid;

    /**
     * Client secret
     * @var string
     */
    protected $clientsecret;

    /**
     * Account ID
     * @var string
     */
    protected $accountid;

    /**
     * API base URL.
     * @var string
     */
    protected $apiurl;

    /**
     * Whether to recycle licenses.
     * @var bool
     */
    protected $recyclelicenses;

    /**
     * Whether to check instance users
     * @var bool
     */
    protected $instanceusers;

    /**
     * Zoom group to protect from licenses redefining
     * @var array
     */
    protected $protectedgroups;

    /**
     * Maximum limit of paid users
     * @var int
     */
    protected $numlicenses;

    /**
     * List of users
     * @var array
     */
    protected static $userslist;

    /**
     * Number of retries we've made for make_call
     * @var int
     */
    protected $makecallretries = 0;

    /**
     * Granted OAuth scopes
     * @var array
     */
    protected $scopes;

    /**
     * The constructor for the webservice class.
     * @throws moodle_exception Moodle exception is thrown for missing config settings.
     */
    public function __construct() {
        $config = get_config('zoom');

        $requiredfields = [
            'clientid',
            'clientsecret',
            'accountid',
        ];

        try {
            // Get and remember each required field.
            foreach ($requiredfields as $requiredfield) {
                if (!empty($config->$requiredfield)) {
                    $this->$requiredfield = $config->$requiredfield;
                } else {
                    throw new moodle_exception('zoomerr_field_missing', 'mod_zoom', '', get_string($requiredfield, 'mod_zoom'));
                }
            }

            // Get and remember the API URL.
            $this->apiurl = zoom_get_api_url();

            // Get and remember the plugin settings to recycle licenses.
            if (!empty($config->utmost)) {
                $this->recyclelicenses = $config->utmost;
                $this->instanceusers = !empty($config->instanceusers);
                $this->protectedgroups = !empty($config->protectedgroups) ? explode(',', $config->protectedgroups) : [];
            }

            if ($this->recyclelicenses) {
                if (!empty($config->licensesnumber)) {
                    $this->numlicenses = $config->licensesnumber;
                } else {
                    throw new moodle_exception('zoomerr_licensesnumber_missing', 'mod_zoom');
                }
            }
        } catch (moodle_exception $exception) {
            throw new moodle_exception('errorwebservice', 'mod_zoom', '', $exception->getMessage());
        }
    }

    /**
     * Makes the call to curl using the specified method, url, and parameter data.
     * This has been moved out of make_call to make unit testing possible.
     *
     * @param \curl $curl The curl object used to make the request.
     * @param string $method The HTTP method to use.
     * @param string $url The URL to append to the API URL
     * @param array|string $data The data to attach to the call.
     * @return stdClass The call's result.
     */
    protected function make_curl_call(&$curl, $method, $url, $data) {
        return $curl->$method($url, $data);
    }

    /**
     * Gets a curl object in order to make API calls. This function was created
     * to enable unit testing for the webservice class.
     * @return curl The curl object used to make the API calls
     */
    protected function get_curl_object() {
        global $CFG;

        $proxyhost = get_config('zoom', 'proxyhost');

        if (!empty($proxyhost)) {
            $cfg = new stdClass();
            $cfg->proxyhost = $CFG->proxyhost;
            $cfg->proxyport = $CFG->proxyport;
            $cfg->proxyuser = $CFG->proxyuser;
            $cfg->proxypassword = $CFG->proxypassword;
            $cfg->proxytype = $CFG->proxytype;

            // Parse string as host:port, delimited by a colon (:).
            [$host, $port] = explode(':', $proxyhost);

            // Temporarily set new values on the global $CFG.
            $CFG->proxyhost = $host;
            $CFG->proxyport = $port;
            $CFG->proxytype = 'HTTP';
            $CFG->proxyuser = '';
            $CFG->proxypassword = '';
        }

        // Create $curl, which implicitly uses the proxy settings from $CFG.
        $curl = new curl();

        if (!empty($proxyhost)) {
            // Restore the stored global proxy settings from above.
            $CFG->proxyhost = $cfg->proxyhost;
            $CFG->proxyport = $cfg->proxyport;
            $CFG->proxyuser = $cfg->proxyuser;
            $CFG->proxypassword = $cfg->proxypassword;
            $CFG->proxytype = $cfg->proxytype;
        }

        return $curl;
    }

    /**
     * Makes a REST call.
     *
     * @param string $path The path to append to the API URL
     * @param array|string $data The data to attach to the call.
     * @param string $method The HTTP method to use.
     * @return stdClass The call's result in JSON format.
     * @throws moodle_exception Moodle exception is thrown for curl errors.
     */
    private function make_call($path, $data = [], $method = 'get') {
        $url = $this->apiurl . $path;
        $method = strtolower($method);

        $token = $this->get_access_token();

        $curl = $this->get_curl_object();
        $curl->setHeader('Authorization: Bearer ' . $token);
        $curl->setHeader('Accept: application/json');

        if ($method != 'get') {
            $curl->setHeader('Content-Type: application/json');
            $data = is_array($data) ? json_encode($data) : $data;
        }

        $attempts = 0;
        do {
            if ($attempts > 0) {
                sleep(1);
                debugging('retrying after curl error 35, retry attempt ' . $attempts);
            }

            $rawresponse = $this->make_curl_call($curl, $method, $url, $data);
            $attempts++;
        } while ($curl->get_errno() === 35 && $attempts <= self::MAX_RETRIES);

        if ($curl->get_errno()) {
            throw new moodle_exception('errorwebservice', 'mod_zoom', '', $curl->error);
        }

        $response = json_decode($rawresponse);

        $httpstatus = $curl->get_info()['http_code'];

        if ($httpstatus >= 400) {
            switch ($httpstatus) {
                case 400:
                    $errorstring = '';
                    if (!empty($response->errors)) {
                        foreach ($response->errors as $error) {
                            $errorstring .= ' ' . $error->message;
                        }
                    }
                    throw new bad_request_exception($response->message . $errorstring, $response->code);

                case 404:
                    throw new not_found_exception($response->message, $response->code);

                case 429:
                    $this->makecallretries += 1;
                    if ($this->makecallretries > self::MAX_RETRIES) {
                        throw new retry_failed_exception($response->message, $response->code);
                    }

                    $header = $curl->getResponse();
                    // Header can have mixed case, normalize it.
                    $header = array_change_key_case($header, CASE_LOWER);

                    // Default to 1 second for max requests per second limit.
                    $timediff = 1;

                    // Check if we hit the max requests per minute (only for Dashboard API).
                    if (
                        array_key_exists('x-ratelimit-type', $header) &&
                        $header['x-ratelimit-type'] == 'QPS' &&
                        strpos($path, 'metrics') !== false
                    ) {
                        $timediff = 60; // Try the next minute.
                    } else if (array_key_exists('retry-after', $header)) {
                        $retryafter = strtotime($header['retry-after']);
                        $timediff = $retryafter - time();
                        // If we have no API calls remaining, save retry-after.
                        if ($header['x-ratelimit-remaining'] == 0 && !empty($retryafter)) {
                            set_config('retry-after', $retryafter, 'zoom');
                            throw new api_limit_exception($response->message, $response->code, $retryafter);
                        } else if (!(defined('PHPUNIT_TEST') && PHPUNIT_TEST)) {
                            // When running CLI we might want to know how many calls remaining.
                            debugging('x-ratelimit-remaining = ' . $header['x-ratelimit-remaining']);
                        }
                    }

                    debugging('Received 429 response, sleeping ' . strval($timediff) .
                            ' seconds until next retry. Current retry: ' . $this->makecallretries);
                    if ($timediff > 0 && !(defined('PHPUNIT_TEST') && PHPUNIT_TEST)) {
                        sleep($timediff);
                    }
                    return $this->make_call($path, $data, $method);

                default:
                    if ($response) {
                        throw new webservice_exception(
                            $response->message,
                            $response->code,
                            'errorwebservice',
                            'mod_zoom',
                            '',
                            $response->message
                        );
                    } else {
                        throw new moodle_exception('errorwebservice', 'mod_zoom', '', "HTTP Status $httpstatus");
                    }
            }
        }

        $this->makecallretries = 0;

        return $response;
    }

    /**
     * Makes a paginated REST call.
     * Makes a call like make_call() but specifically for GETs with paginated results.
     *
     * @param string $url The URL to append to the API URL
     * @param array $data The data to attach to the call.
     * @param string $datatoget The name of the array of the data to get.
     * @return array The retrieved data.
     * @see make_call()
     */
    private function make_paginated_call($url, $data, $datatoget) {
        $aggregatedata = [];
        $data['page_size'] = ZOOM_MAX_RECORDS_PER_CALL;
        do {
            $callresult = null;
            $moredata = false;
            $callresult = $this->make_call($url, $data);

            if ($callresult) {
                $aggregatedata = array_merge($aggregatedata, $callresult->$datatoget);
                if (!empty($callresult->next_page_token)) {
                    $data['next_page_token'] = $callresult->next_page_token;
                    $moredata = true;
                } else if (!empty($callresult->page_number) && $callresult->page_number < $callresult->page_count) {
                    $data['page_number'] = $callresult->page_number + 1;
                    $moredata = true;
                }
            }
        } while ($moredata);

        return $aggregatedata;
    }

    /**
     * Autocreate a user on Zoom.
     *
     * @param stdClass $user The user to create.
     * @param string $action The account create action: create, autoCreate, custCreate or ssoCreate.
     * @param int $type The user type number.
     * @return bool Whether the user was succesfully created.
     * @see https://github.com/yedidiaklein/moodle-local_zoomsyncusers An external plugin that depends on mod_zoom uses this method.
     */
    public function autocreate_user($user, $action = 'autoCreate', $type = ZOOM_USER_TYPE_PRO) {
        // Classic: user:write:admin.
        // Granular: user:write:user:admin.
        $url = 'users';
        $data = ['action' => $action];
        $data['user_info'] = [
            'email' => zoom_get_api_identifier($user),
            'type' => $type,
            'first_name' => $user->firstname,
            'last_name' => $user->lastname,
            'password' => base64_encode(random_bytes(16)),
        ];

        try {
            $this->make_call($url, $data, 'post');
        } catch (moodle_exception $error) {
            // If the user already exists, the error will contain 'User already in the account'.
            if (strpos($error->getMessage(), 'User already in the account') === true) {
                return false;
            } else {
                throw $error;
            }
        }

        return true;
    }

    /**
     * Get users list.
     *
     * @return array An array of users.
     */
    public function list_users() {
        if (empty(self::$userslist)) {
            // Classic: user:read:admin.
            // Granular: user:read:list_users:admin.
            self::$userslist = $this->make_paginated_call('users', [], 'users');
        }

        return self::$userslist;
    }

    /**
     * Checks whether the paid user license limit has been reached.
     *
     * Incrementally retrieves the active paid users and compares against $numlicenses.
     * @see $numlicenses
     * @return bool Whether the paid user license limit has been reached.
     */
    private function paid_user_limit_reached() {
        $userslist = $this->list_users();
        $numusers = 0;
        foreach ($userslist as $user) {
            if ($user->type != ZOOM_USER_TYPE_BASIC) {
                // Count the user if we're including all users or if the user is on this instance.
                if (!$this->instanceusers || core_user::get_user_by_email($user->email)) {
                    $numusers++;
                    if ($numusers >= $this->numlicenses) {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /**
     * Gets the ID of the user, of all the paid users, with the oldest last login time.
     *
     * @return string|false If user is found, returns the User ID. Otherwise, returns false.
     */
    private function get_least_recently_active_paid_user_id() {
        $usertimes = [];

        // Classic: user:read:admin.
        // Granular: user:read:list_users:admin.
        $userslist = $this->list_users();

        foreach ($userslist as $user) {
            // Skip Basic user accounts.
            if ($user->type == ZOOM_USER_TYPE_BASIC) {
                continue;
            }

            // Skip the users of protected groups.
            if (!empty(array_intersect($this->protectedgroups, $user->group_ids ?? []))) {
                continue;
            }

            // We need the login time.
            if (!isset($user->last_login_time)) {
                continue;
            }

            // Count the user only if we're including all users or if the user is on this instance.
            if (!$this->instanceusers || core_user::get_user_by_email($user->email)) {
                $usertimes[$user->id] = strtotime($user->last_login_time);
            }
        }

        if (!empty($usertimes)) {
            return array_search(min($usertimes), $usertimes);
        }

        return false;
    }

    /**
     * Get a list of Zoom groups
     *
     * @return array Group information.
     */
    public function get_groups() {
        $groups = [];

        // Classic: group:read:admin.
        // Granular: group:read:list_groups:admin.
        // Not essential scope, execute only if scope has been granted.
        if ($this->has_scope(['group:read:list_groups:admin', 'group:read:admin'])) {
            try {
                $response = $this->make_call('/groups');
                $groups = $response->groups ?? [];
            } catch (moodle_exception $error) {
                // Only available for Paid accounts, so ignore error.
                $response = '';
            }
        }

        return $groups;
    }

    /**
     * Gets a user's settings.
     *
     * @param string $userid The user's ID.
     * @return stdClass The call's result in JSON format.
     */
    public function get_user_settings($userid) {
        // Classic: user:read:admin.
        // Granular: user:read:settings:admin.
        return $this->make_call('users/' . $userid . '/settings');
    }

    /**
     * Gets the user's meeting security settings, including password requirements.
     *
     * @param string $userid The user's ID.
     * @return stdClass The call's result in JSON format.
     */
    public function get_account_meeting_security_settings($userid) {
        // Classic: user:read:admin.
        // Granular: user:read:settings:admin.
        $url = 'users/' . $userid . '/settings?option=meeting_security';
        try {
            $response = $this->make_call($url);
            $meetingsecurity = $response->meeting_security;
        } catch (moodle_exception $error) {
            // Only available for Paid account, return default settings.
            $meetingsecurity = new stdClass();
            // If some other error, show debug message.
            if (isset($error->zoomerrorcode) && $error->zoomerrorcode != 200) {
                debugging($error->getMessage());
            }
        }

        // Set a default meeting password requirment if it is not present.
        if (!isset($meetingsecurity->meeting_password_requirement)) {
              $meetingsecurity->meeting_password_requirement = (object) self::DEFAULT_MEETING_PASSWORD_REQUIREMENT;
        }

        // Set a default encryption setting if it is not present.
        if (!isset($meetingsecurity->end_to_end_encrypted_meetings)) {
            $meetingsecurity->end_to_end_encrypted_meetings = false;
        }

        return $meetingsecurity;
    }

    /**
     * Gets a user.
     *
     * @param string|int $identifier The user's email or the user's ID per Zoom API.
     * @return stdClass|false If user is found, returns the User object. Otherwise, returns false.
     */
    public function get_user($identifier) {
        $founduser = false;

        // Classic: user:read:admin.
        // Granular: user:read:user:admin.
        $url = 'users/' . $identifier;

        try {
            $founduser = $this->make_call($url);
        } catch (webservice_exception $error) {
            if (zoom_is_user_not_found_error($error)) {
                return false;
            } else {
                throw $error;
            }
        }

        return $founduser;
    }

    /**
     * Gets a list of users that the given person can schedule meetings for.
     *
     * @param string $identifier The user's email or the user's ID per Zoom API.
     * @return array|false If schedulers are returned array of {id,email} objects. Otherwise returns false.
     */
    public function get_schedule_for_users($identifier) {
        // Classic: user:read:admin.
        // Granular: user:read:list_schedulers:admin.
        $url = "users/{$identifier}/schedulers";

        $schedulerswithoutkey = [];
        $schedulers = [];
        try {
            $response = $this->make_call($url);
            if (is_array($response->schedulers)) {
                $schedulerswithoutkey = $response->schedulers;
            }

            foreach ($schedulerswithoutkey as $s) {
                $schedulers[$s->id] = $s;
            }
        } catch (moodle_exception $error) {
            // We don't care if this throws an exception.
            $schedulers = [];
        }

        return $schedulers;
    }

    /**
     * Converts a zoom object from database format to API format.
     *
     * The database and the API use different fields and formats for the same information. This function changes the
     * database fields to the appropriate API request fields.
     *
     * @param stdClass $zoom The zoom meeting to format.
     * @param ?int $cmid The cmid if available.
     * @return array The formatted meetings for the meeting.
     */
    private function database_to_api($zoom, $cmid) {
        global $CFG;

        $options = [];
        if (!empty($cmid)) {
            $options['context'] = \context_module::instance($cmid);
        }

        $data = [
            // Process the meeting topic with proper filter.
            'topic' => zoom_apply_filter_on_meeting_name($zoom->name, $options),
            'settings' => [
                'host_video' => (bool) ($zoom->option_host_video),
                'audio' => $zoom->option_audio,
            ],
        ];
        if (isset($zoom->intro)) {
            // Process the description text with proper filter and then convert to plain text.
            $data['agenda'] = substr(content_to_text(format_text(
                $zoom->intro,
                FORMAT_MOODLE,
                $options
            ), false), 0, 2000);
        }

        if (isset($CFG->timezone) && !empty($CFG->timezone)) {
            $data['timezone'] = $CFG->timezone;
        } else {
            $data['timezone'] = date_default_timezone_get();
        }

        if (isset($zoom->password)) {
            $data['password'] = $zoom->password;
        }

        if (isset($zoom->schedule_for)) {
            $data['schedule_for'] = $zoom->schedule_for;
        }

        if (isset($zoom->alternative_hosts)) {
            $data['settings']['alternative_hosts'] = $zoom->alternative_hosts;
        }

        if (isset($zoom->option_authenticated_users)) {
            $data['settings']['meeting_authentication'] = (bool) $zoom->option_authenticated_users;
        }

        if (isset($zoom->registration)) {
            $data['settings']['approval_type'] = $zoom->registration;
            if ($zoom->registration != ZOOM_REGISTRATION_OFF) {
                $data['settings']['use_pmi'] = false;
            }
        }

        if (!empty($zoom->webinar)) {
            if ($zoom->recurring) {
                if ($zoom->recurrence_type == ZOOM_RECURRINGTYPE_NOTIME) {
                    $data['type'] = ZOOM_RECURRING_WEBINAR;
                } else {
                    $data['type'] = ZOOM_RECURRING_FIXED_WEBINAR;
                }
            } else {
                $data['type'] = ZOOM_SCHEDULED_WEBINAR;
            }
        } else {
            if ($zoom->recurring) {
                if ($zoom->recurrence_type == ZOOM_RECURRINGTYPE_NOTIME) {
                    $data['type'] = ZOOM_RECURRING_MEETING;
                } else {
                    $data['type'] = ZOOM_RECURRING_FIXED_MEETING;
                }
            } else {
                $data['type'] = ZOOM_SCHEDULED_MEETING;
            }
        }

        if (!empty($zoom->option_auto_recording)) {
            $data['settings']['auto_recording'] = $zoom->option_auto_recording;
        } else {
            $recordingoption = get_config('zoom', 'recordingoption');
            if ($recordingoption === ZOOM_AUTORECORDING_USERDEFAULT) {
                if (isset($zoom->schedule_for)) {
                    $zoomuser = zoom_get_user($zoom->schedule_for);
                    $zoomuserid = $zoomuser->id;
                } else {
                    $zoomuserid = $zoom->host_id;
                }

                $autorecording = zoom_get_user_settings($zoomuserid)->recording->auto_recording;
                $data['settings']['auto_recording'] = $autorecording;
            } else {
                $data['settings']['auto_recording'] = $recordingoption;
            }
        }

        // Add fields which are effective for meetings only, but not for webinars.
        if (empty($zoom->webinar)) {
            $data['settings']['participant_video'] = (bool) ($zoom->option_participants_video);
            $data['settings']['join_before_host'] = (bool) ($zoom->option_jbh);
            $data['settings']['encryption_type'] = (isset($zoom->option_encryption_type) &&
                    $zoom->option_encryption_type === ZOOM_ENCRYPTION_TYPE_E2EE) ?
                    ZOOM_ENCRYPTION_TYPE_E2EE : ZOOM_ENCRYPTION_TYPE_ENHANCED;
            $data['settings']['waiting_room'] = (bool) ($zoom->option_waiting_room);
            $data['settings']['mute_upon_entry'] = (bool) ($zoom->option_mute_upon_entry);
        }

        // Add recurrence object.
        if ($zoom->recurring && $zoom->recurrence_type != ZOOM_RECURRINGTYPE_NOTIME) {
            $data['recurrence']['type'] = (int) $zoom->recurrence_type;
            $data['recurrence']['repeat_interval'] = (int) $zoom->repeat_interval;
            if ($zoom->recurrence_type == ZOOM_RECURRINGTYPE_WEEKLY) {
                $data['recurrence']['weekly_days'] = $zoom->weekly_days;
            }

            if ($zoom->recurrence_type == ZOOM_RECURRINGTYPE_MONTHLY) {
                if ($zoom->monthly_repeat_option == ZOOM_MONTHLY_REPEAT_OPTION_DAY) {
                    $data['recurrence']['monthly_day'] = (int) $zoom->monthly_day;
                } else {
                    $data['recurrence']['monthly_week'] = (int) $zoom->monthly_week;
                    $data['recurrence']['monthly_week_day'] = (int) $zoom->monthly_week_day;
                }
            }

            if ($zoom->end_date_option == ZOOM_END_DATE_OPTION_AFTER) {
                $data['recurrence']['end_times'] = (int) $zoom->end_times;
            } else {
                $data['recurrence']['end_date_time'] = gmdate('Y-m-d\TH:i:s\Z', $zoom->end_date_time);
            }
        }

        if (
            $data['type'] === ZOOM_SCHEDULED_MEETING ||
            $data['type'] === ZOOM_RECURRING_FIXED_MEETING ||
            $data['type'] === ZOOM_SCHEDULED_WEBINAR ||
            $data['type'] === ZOOM_RECURRING_FIXED_WEBINAR
        ) {
            // Convert timestamp to ISO-8601. The API seems to insist that it end with 'Z' to indicate UTC.
            $data['start_time'] = gmdate('Y-m-d\TH:i:s\Z', $zoom->start_time);
            $data['duration'] = (int) ceil($zoom->duration / 60);
        }

        // Add tracking field to data.
        $defaulttrackingfields = zoom_clean_tracking_fields();
        $tfarray = [];
        foreach ($defaulttrackingfields as $key => $defaulttrackingfield) {
            if (isset($zoom->$key)) {
                $tf = new stdClass();
                $tf->field = $defaulttrackingfield;
                $tf->value = $zoom->$key;
                $tfarray[] = $tf;
            }
        }

        $data['tracking_fields'] = $tfarray;

        if (isset($zoom->breakoutrooms)) {
            $breakoutroom = ['enable' => true, 'rooms' => $zoom->breakoutrooms];
            $data['settings']['breakout_room'] = $breakoutroom;
        }

        return $data;
    }

    /**
     * Provide a user with a license if needed and recycling is enabled.
     *
     * @param stdClass $zoomuserid The Zoom user to upgrade.
     * @return void
     */
    public function provide_license($zoomuserid) {
        // Checks whether we need to recycle licenses and acts accordingly.
        // Classic: user:read:admin.
        // Granular: user:read:user:admin.
        if ($this->recyclelicenses && $this->make_call("users/$zoomuserid")->type == ZOOM_USER_TYPE_BASIC) {
            $licenseisavailable = !$this->paid_user_limit_reached();
            if (!$licenseisavailable) {
                $leastrecentlyactivepaiduserid = $this->get_least_recently_active_paid_user_id();
                // Changes least_recently_active_user to a basic user so we can use their license.
                if ($leastrecentlyactivepaiduserid) {
                    $this->make_call("users/$leastrecentlyactivepaiduserid", ['type' => ZOOM_USER_TYPE_BASIC], 'patch');
                    $licenseisavailable = true;
                }
            }

            // Changes current user to pro so they can make a meeting.
            // Classic: user:write:admin.
            // Granular: user:update:user:admin.
            if ($licenseisavailable) {
                $this->make_call("users/$zoomuserid", ['type' => ZOOM_USER_TYPE_PRO], 'patch');
            }
        }
    }

    /**
     * Create a meeting/webinar on Zoom.
     * Take a $zoom object as returned from the Moodle form and respond with an object that can be saved to the database.
     *
     * @param stdClass $zoom The meeting to create.
     * @param ?int $cmid The cmid if available.
     * @return stdClass The call response.
     */
    public function create_meeting($zoom, $cmid) {
        // Provide license if needed.
        $this->provide_license($zoom->host_id);

        // Classic: meeting:write:admin.
        // Granular: meeting:write:meeting:admin.
        // Classic: webinar:write:admin.
        // Granular: webinar:write:webinar:admin.
        $url = "users/$zoom->host_id/" . (!empty($zoom->webinar) ? 'webinars' : 'meetings');
        return $this->make_call($url, $this->database_to_api($zoom, $cmid), 'post');
    }

    /**
     * Update a meeting/webinar on Zoom.
     *
     * @param stdClass $zoom The meeting to update.
     * @param ?int $cmid The cmid if available.
     * @return void
     */
    public function update_meeting($zoom, $cmid) {
        // Classic: meeting:write:admin.
        // Granular: meeting:update:meeting:admin.
        // Classic: webinar:write:admin.
        // Granular: webinar:update:webinar:admin.
        $url = ($zoom->webinar ? 'webinars/' : 'meetings/') . $zoom->meeting_id;
        $this->make_call($url, $this->database_to_api($zoom, $cmid), 'patch');
    }

    /**
     * Delete a meeting or webinar on Zoom.
     *
     * @param int $id The meeting_id or webinar_id of the meeting or webinar to delete.
     * @param bool $webinar Whether the meeting or webinar you want to delete is a webinar.
     * @return void
     */
    public function delete_meeting($id, $webinar) {
        // Classic: meeting:write:admin.
        // Granular: meeting:delete:meeting:admin.
        // Classic: webinar:write:admin.
        // Granular: webinar:delete:webinar:admin.
        $url = ($webinar ? 'webinars/' : 'meetings/') . $id . '?schedule_for_reminder=false';
        $this->make_call($url, null, 'delete');
    }

    /**
     * Get a meeting or webinar's information from Zoom.
     *
     * @param int $id The meeting_id or webinar_id of the meeting or webinar to retrieve.
     * @param bool $webinar Whether the meeting or webinar whose information you want is a webinar.
     * @return stdClass The meeting's or webinar's information.
     */
    public function get_meeting_webinar_info($id, $webinar) {
        // Classic: meeting:read:admin.
        // Granular: meeting:read:meeting:admin.
        // Classic: webinar:read:admin.
        // Granular: webinar:read:webinar:admin.
        $url = ($webinar ? 'webinars/' : 'meetings/') . $id;
        $response = $this->make_call($url);
        return $response;
    }

    /**
     * Get the meeting invite note that was sent for a specific meeting from Zoom.
     *
     * @param stdClass $zoom The zoom meeting
     * @return \mod_zoom\invitation The meeting's invitation.
     */
    public function get_meeting_invitation($zoom) {
        global $CFG;
        require_once($CFG->dirroot . '/mod/zoom/classes/invitation.php');

        // Webinar does not have meeting invite info.
        if ($zoom->webinar) {
            return new invitation(null);
        }

        // Classic: meeting:read:admin.
        // Granular: meeting:read:invitation:admin.
        $url = 'meetings/' . $zoom->meeting_id . '/invitation';

        try {
            $response = $this->make_call($url);
        } catch (moodle_exception $error) {
            debugging($error->getMessage());
            return new invitation(null);
        }

        return new invitation($response->invitation);
    }

    /**
     * Retrieve ended meetings report for a specified user and period. Handles multiple pages.
     *
     * @param string $userid Id of user of interest
     * @param string $from Start date of period in the form YYYY-MM-DD
     * @param string $to End date of period in the form YYYY-MM-DD
     * @return array The retrieved meetings.
     */
    public function get_user_report($userid, $from, $to) {
        // Classic: report:read:admin.
        // Granular: report:read:user:admin.
        $url = 'report/users/' . $userid . '/meetings';
        $data = ['from' => $from, 'to' => $to];
        return $this->make_paginated_call($url, $data, 'meetings');
    }

    /**
     * List all meeting or webinar information for a user.
     *
     * @param string $userid The user whose meetings or webinars to retrieve.
     * @param boolean $webinar Whether to list meetings or to list webinars.
     * @return array An array of meeting information.
     * @deprecated Has never been used by internal code.
     */
    public function list_meetings($userid, $webinar) {
        // Classic: meeting:read:admin.
        // Granular: meeting:read:list_meetings:admin.
        // Classic: webinar:read:admin.
        // Granular: webinar:read:list_webinars:admin.
        $url = 'users/' . $userid . ($webinar ? '/webinars' : '/meetings');
        $instances = $this->make_paginated_call($url, [], ($webinar ? 'webinars' : 'meetings'));
        return $instances;
    }

    /**
     * Get the participants who attended a meeting
     * @param string $meetinguuid The meeting or webinar's UUID.
     * @param bool $webinar Whether the meeting or webinar whose information you want is a webinar.
     * @return array An array of meeting participant objects.
     */
    public function get_meeting_participants($meetinguuid, $webinar) {
        $meetinguuid = $this->encode_uuid($meetinguuid);

        $meetingtype = ($webinar ? 'webinars' : 'meetings');
        $meetingtypesingular = ($webinar ? 'webinar' : 'meeting');

        $reportscopes = [
            // Classic.
            'report:read:admin',

            // Granular.
            'report:read:list_' . $meetingtypesingular . '_participants:admin',
        ];

        $dashboardscopes = [
            // Classic.
            'dashboard_' . $meetingtype . ':read:admin',

            // Granular.
            'dashboard:read:list_' . $meetingtypesingular . '_participants:admin',
        ];

        if ($this->has_scope($reportscopes)) {
            $apitype = 'report';
            $data = [];
        } else if ($this->has_scope($dashboardscopes)) {
            $apitype = 'metrics';
            $data = [
                'type' => 'past',
            ];
        } else {
            mtrace('Missing OAuth scopes required for reports.');
            return [];
        }

        $url = $apitype . '/' . $meetingtype . '/' . $meetinguuid . '/participants';
        return $this->make_paginated_call($url, $data, 'participants');
    }

    /**
     * Retrieve the UUIDs of hosts that were active in the last 30 days.
     *
     * @param int $from The time to start the query from, in Unix timestamp format.
     * @param int $to The time to end the query at, in Unix timestamp format.
     * @return array An array of UUIDs.
     */
    public function get_active_hosts_uuids($from, $to) {
        // Classic: report:read:admin.
        // Granular: report:read:list_users:admin.
        $users = $this->make_paginated_call('report/users', ['type' => 'active', 'from' => $from, 'to' => $to], 'users');
        $uuids = [];
        foreach ($users as $user) {
            $uuids[] = $user->id;
        }

        return $uuids;
    }

    /**
     * Retrieve past meetings that occurred in specified time period.
     *
     * Ignores meetings that were attended only by one user.
     *
     * NOTE: Requires Business or a higher plan and have "Dashboard" feature
     * enabled. This query is rated "Resource-intensive"
     *
     * @param int $from Start date in YYYY-MM-DD format.
     * @param int $to End date in YYYY-MM-DD format.
     * @return array An array of meeting objects.
     */
    public function get_meetings($from, $to) {
        // Classic: dashboard_meetings:read:admin.
        // Granular: dashboard:read:list_meetings:admin.
        return $this->make_paginated_call(
            'metrics/meetings',
            [
                'type' => 'past',
                'from' => $from,
                'to' => $to,
                'query_date_type' => 'end_time',
            ],
            'meetings'
        );
    }

    /**
     * Retrieve past meetings that occurred in specified time period.
     *
     * Ignores meetings that were attended only by one user.
     *
     * NOTE: Requires Business or a higher plan and have "Dashboard" feature
     * enabled. This query is rated "Resource-intensive"
     *
     * @param int $from Start date in YYYY-MM-DD format.
     * @param int $to End date in YYYY-MM-DD format.
     * @return array An array of meeting objects.
     */
    public function get_webinars($from, $to) {
        // Classic: dashboard_webinars:read:admin.
        // Granular: dashboard:read:list_webinars:admin.
        return $this->make_paginated_call('metrics/webinars', ['type' => 'past', 'from' => $from, 'to' => $to], 'webinars');
    }

    /**
     * Lists tracking fields configured on the account.
     *
     * @return ?stdClass The call's result in JSON format.
     */
    public function list_tracking_fields() {
        $response = null;
        try {
            // Classic: tracking_fields:read:admin.
            // Granular: tracking_field:read:list_tracking_fields:admin.
            $response = $this->make_call('tracking_fields');
        } catch (moodle_exception $error) {
            debugging($error->getMessage());
        }

        return $response;
    }

    /**
     * If the UUID begins with a / or contains // in it we need to double encode it when using it for API calls.
     *
     * See https://devforum.zoom.us/t/cant-retrieve-data-when-meeting-uuid-contains-double-slash/2776
     *
     * @param string $uuid
     * @return string
     */
    public function encode_uuid($uuid) {
        if (substr($uuid, 0, 1) === '/' || strpos($uuid, '//') !== false) {
            // Use similar function to JS encodeURIComponent, see https://stackoverflow.com/a/1734255/6001.
            $encodeuricomponent = function ($str) {
                $revert = ['%21' => '!', '%2A' => '*', '%27' => "'", '%28' => '(', '%29' => ')'];
                return strtr(rawurlencode($str), $revert);
            };
            $uuid = $encodeuricomponent($encodeuricomponent($uuid));
        }

        return $uuid;
    }

    /**
     * Returns the download URLs and recording types for the cloud recording if one exists on zoom for a particular meeting id.
     * There can be more than one url for the same meeting if the host stops the recording in the middle
     * of the meeting and then starts recording again without ending the meeting.
     *
     * @param string $meetingid The string meeting UUID.
     * @return array Returns the list of recording URLs and the type of recording that is being sent back.
     * @throws moodle_exception
     */
    public function get_recording_url_list($meetingid) {
        $recordings = [];

        // Only pick the video recording and audio only recordings.
        // The transcript is available in both of these, so the extra file is unnecessary.
        $allowedrecordingtypes = [
            'MP4' => 'video',
            'M4A' => 'audio',
            'TRANSCRIPT' => 'transcript',
            'CHAT' => 'chat',
            'CC' => 'captions',
        ];

        // Classic: recording:read:admin.
        // Granular: cloud_recording:read:list_recording_files:admin.
        $url = 'meetings/' . $this->encode_uuid($meetingid) . '/recordings';
        $response = $this->make_call($url);

        if (!empty($response->recording_files)) {
            foreach ($response->recording_files as $recording) {
                $url = $recording->play_url ?? $recording->download_url ?? null;
                if (!empty($url) && isset($allowedrecordingtypes[$recording->file_type])) {
                    $recordinginfo = new stdClass();
                    $recordinginfo->recordingid = $recording->id;
                    $recordinginfo->meetinguuid = $response->uuid;
                    $recordinginfo->url = $url;
                    $recordinginfo->filetype = $recording->file_type;
                    $recordinginfo->recordingtype = $recording->recording_type ?? 'null';
                    $recordinginfo->passcode = $response->password;
                    $recordinginfo->recordingstart = strtotime($recording->recording_start);

                    $recordings[$recording->id] = $recordinginfo;
                }
            }
        }

        return $recordings;
    }

    /**
     * Retrieve recordings for a specified user and period. Handles multiple pages.
     *
     * @param string $userid User ID.
     * @param string $from Start date of period in the form YYYY-MM-DD
     * @param string $to End date of period in the form YYYY-MM-DD
     * @return array
     */
    public function get_user_recordings($userid, $from, $to) {
        $recordings = [];

        // Only pick the video recording and audio only recordings.
        // The transcript is available in both of these, so the extra file is unnecessary.
        $allowedrecordingtypes = [
            'MP4' => 'video',
            'M4A' => 'audio',
            'TRANSCRIPT' => 'transcript',
            'CHAT' => 'chat',
            'CC' => 'captions',
        ];

        try {
            // Classic: recording:read:admin.
            // Granular: cloud_recording:read:list_user_recordings:admin.
            $url = 'users/' . $userid . '/recordings';
            $data = ['from' => $from, 'to' => $to];
            $response = $this->make_paginated_call($url, $data, 'meetings');

            foreach ($response as $meeting) {
                foreach ($meeting->recording_files as $recording) {
                    $url = $recording->play_url ?? $recording->download_url ?? null;
                    if (!empty($url) && isset($allowedrecordingtypes[$recording->file_type])) {
                        $recordinginfo = new stdClass();
                        $recordinginfo->recordingid = $recording->id;
                        $recordinginfo->meetingid = $meeting->id;
                        $recordinginfo->meetinguuid = $meeting->uuid;
                        $recordinginfo->url = $url;
                        $recordinginfo->filetype = $recording->file_type;
                        $recordinginfo->recordingtype = $recording->recording_type ?? 'null';
                        $recordinginfo->recordingstart = strtotime($recording->recording_start);

                        $recordings[$recording->id] = $recordinginfo;
                    }
                }
            }
        } catch (moodle_exception $error) {
            // No recordings found for this user.
            $recordings = [];
        }

        return $recordings;
    }

    /**
     * Returns a server to server oauth access token, good for 1 hour.
     *
     * @throws moodle_exception
     * @return string access token
     */
    protected function get_access_token() {
        $cache = cache::make('mod_zoom', 'oauth');
        $token = $cache->get('accesstoken');
        $expires = $cache->get('expires');
        if (empty($token) || empty($expires) || time() >= $expires) {
            $token = $this->oauth($cache);
        } else {
            $this->scopes = $cache->get('scopes');
        }

        return $token;
    }

    /**
     * Has one of the required OAuth scopes been granted?
     *
     * @param array $scopes OAuth scopes.
     * @throws moodle_exception
     * @return bool
     */
    public function has_scope($scopes) {
        if (!isset($this->scopes)) {
            $this->get_access_token();
        }

        mtrace('checking has_scope(' . implode(' || ', $scopes) . ')');

        $matchingscopes = \array_intersect($scopes, $this->scopes);
        return !empty($matchingscopes);
    }

    /**
     * Check for Zoom scopes
     *
     * @param string $requiredscopes Required Zoom scopes.
     * @throws moodle_exception
     * @return array missingscopes
     */
    public function check_scopes($requiredscopes) {
        if (!isset($this->scopes)) {
            $this->get_access_token();
        }

        $scopetype = $this->get_scope_type($this->scopes);

        $missingscopes = array_diff($requiredscopes[$scopetype], $this->scopes);
        return $missingscopes;
    }

    /**
     * Checks for the type of scope (classic or granular) of the user.
     *
     * @param array $scopes
     * @return string scope type
     */
    private function get_scope_type($scopes) {
        return in_array('meeting:read:admin', $scopes, true) ? 'classic' : 'granular';
    }

    /**
     * Stores token and expiration in cache, returns token from OAuth call.
     *
     * @param cache $cache
     * @throws moodle_exception
     * @return string access token
     */
    private function oauth($cache) {
        $curl = $this->get_curl_object();
        $curl->setHeader('Authorization: Basic ' . base64_encode($this->clientid . ':' . $this->clientsecret));
        $curl->setHeader('Accept: application/json');

        // Force HTTP/1.1 to avoid HTTP/2 "stream not closed" issue.
        $curl->setopt([
            'CURLOPT_HTTP_VERSION' => \CURL_HTTP_VERSION_1_1,
        ]);

        $timecalled = time();
        $data = [
            'grant_type' => 'account_credentials',
            'account_id' => $this->accountid,
        ];
        $response = $this->make_curl_call($curl, 'post', 'https://zoom.us/oauth/token', $data);

        if ($curl->get_errno()) {
            throw new moodle_exception('errorwebservice', 'mod_zoom', '', $curl->error);
        }

        $response = json_decode($response);

        if (empty($response->access_token)) {
            throw new moodle_exception('errorwebservice', 'mod_zoom', '', get_string('zoomerr_no_access_token', 'mod_zoom'));
        }

        $scopes = explode(' ', $response->scope);

        // Keep the scope information in memory.
        $this->scopes = $scopes;

        // Assume that we are using granular scopes.
        $requiredscopes = [
            'granular' => [
                'meeting:read:meeting:admin',
                'meeting:read:invitation:admin',
                'meeting:delete:meeting:admin',
                'meeting:update:meeting:admin',
                'meeting:write:meeting:admin',
                'user:read:list_schedulers:admin',
                'user:read:settings:admin',
                'user:read:user:admin',
            ],
            'classic' => [
                'meeting:read:admin',
                'meeting:write:admin',
                'user:read:admin',
            ],
        ];

        $missingscopes = $this->check_scopes($requiredscopes);

        if (!empty($missingscopes)) {
            $missingscopes = implode(', ', $missingscopes);
            throw new moodle_exception('errorwebservice', 'mod_zoom', '', get_string('zoomerr_scopes', 'mod_zoom', $missingscopes));
        }

        $token = $response->access_token;

        if (isset($response->expires_in)) {
            $expires = $response->expires_in + $timecalled;
        } else {
            $expires = 3599 + $timecalled;
        }

        $cache->set_many([
            'accesstoken' => $token,
            'expires' => $expires,
            'scopes' => $scopes,
        ]);

        return $token;
    }

    /**
     * List the meeting or webinar registrants from Zoom.
     *
     * @param string $id The meeting_id or webinar_id of the meeting or webinar to retrieve.
     * @param bool $webinar Whether the meeting or webinar whose information you want is a webinar.
     * @return stdClass The meeting's or webinar's information.
     */
    public function get_meeting_registrants($id, $webinar) {
        // Classic: meeting:read:admin.
        // Granular: meeting:read:list_registrants:admin.
        // Classic: webinar:read:admin.
        // Granular: webinar:read:list_registrants:admin.
        $url = ($webinar ? 'webinars/' : 'meetings/') . $id . '/registrants';
        $response = $this->make_call($url);
        return $response;
    }

    /**
     * Get the recording settings for a meeting.
     *
     * @param string $meetinguuid The UUID of a meeting with recordings.
     * @return stdClass The meeting's recording settings.
     */
    public function get_recording_settings($meetinguuid) {
        // Classic: recording:read:admin.
        // Granular: cloud_recording:read:recording_settings:admin.
        $url = 'meetings/' . $this->encode_uuid($meetinguuid) . '/recordings/settings';
        $response = $this->make_call($url);
        return $response;
    }

    /**
     * Returns whether or not the current user is permitted to create a meeting/webinar that requires registration.
     * @return boolean
     */
    public function is_user_permitted_to_require_registration() {
        global $USER;
        $zoomuser = zoom_get_user(zoom_get_api_identifier($USER));
        if ($zoomuser && $zoomuser->type == ZOOM_USER_TYPE_PRO) {
            return true;
        }
        return false;
    }
}

====================

file: invitation.php
path: classes/invitation.php
codice:
<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Represents a Zoom invitation.
 *
 * @package    mod_zoom
 * @author     Andrew Madden <andrewmadden@catalyst-au.net>
 * @copyright  2021 Catalyst IT
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

use coding_exception;
use context_module;
use moodle_exception;

/**
 * Invitation class.
 */
class invitation {
    /**
     * Invitation settings prefix.
     * @var string
     */
    public const PREFIX = 'invitation_';

    /** @var string|null $invitation The unaltered zoom invitation text. */
    private $invitation;

    /** @var array $configregex Array of regex patterns defined in plugin settings. */
    private $configregex;

    /**
     * invitation constructor.
     *
     * @param string|null $invitation Zoom invitation returned from
     * https://marketplace.zoom.us/docs/api-reference/zoom-api/meetings/meetinginvitation.
     */
    public function __construct($invitation) {
        $this->invitation = $invitation;
    }

    /**
     * Get the display string to show on the module page.
     *
     * @param int $coursemoduleid Course module where the user will view the invitation.
     * @param int|null $userid Optionally supply the intended user to view the string. Defaults to global $USER.
     * @return ?string
     */
    public function get_display_string(int $coursemoduleid, ?int $userid = null) {
        if (empty($this->invitation)) {
            return null;
        }

        // If regex patterns are disabled, return the raw zoom meeting invitation.
        if (!get_config('zoom', 'invitationregexenabled')) {
            return $this->invitation;
        }

        $displaystring = $this->invitation;
        try {
            // If setting enabled, strip the invite message.
            if (get_config('zoom', 'invitationremoveinvite')) {
                $displaystring = $this->remove_element($displaystring, 'invite');
            }

            // If setting enabled, strip the iCal link.
            if (get_config('zoom', 'invitationremoveicallink')) {
                $displaystring = $this->remove_element($displaystring, 'icallink');
            }

            // Check user capabilities, and remove parts of the invitation they don't have permission to view.
            if (!has_capability('mod/zoom:viewjoinurl', context_module::instance($coursemoduleid), $userid)) {
                $displaystring = $this->remove_element($displaystring, 'joinurl');
            }

            if (!has_capability('mod/zoom:viewdialin', context_module::instance($coursemoduleid), $userid)) {
                $displaystring = $this->remove_element($displaystring, 'onetapmobile');
                $displaystring = $this->remove_element($displaystring, 'dialin');
                $displaystring = $this->remove_element($displaystring, 'sip');
                $displaystring = $this->remove_element($displaystring, 'h323');
            } else {
                // Fix the formatting of the onetapmobile section if it exists.
                $displaystring = $this->add_paragraph_break_above_element($displaystring, 'onetapmobile');
            }
        } catch (moodle_exception $e) {
            // If the regex parsing fails, log a debugging message and return the whole invitation.
            debugging($e->getMessage(), DEBUG_DEVELOPER);
            return $this->invitation;
        }

        $displaystring = trim($this->clean_paragraphs($displaystring));
        return $displaystring;
    }

    /**
     * Remove instances of a zoom invitation element using a regex pattern.
     *
     * @param string $invitation
     * @param string $element
     * @return string
     *
     * @throws \coding_exception
     * @throws \dml_exception
     * @throws \moodle_exception
     */
    private function remove_element(string $invitation, string $element): string {
        global $PAGE;

        $configregex = $this->get_config_invitation_regex();
        if (!array_key_exists($element, $configregex)) {
            throw new coding_exception('Cannot remove element: ' . $element
                    . '. See mod/zoom/classes/invitation.php:get_default_invitation_regex for valid elements.');
        }

        // If the element pattern is intentionally empty, return the invitation string unaltered.
        if (empty($configregex[$element])) {
            return $invitation;
        }

        $count = 0;
        $invitation = @preg_replace($configregex[$element], "", $invitation, -1, $count);

        // If invitation is null, an error occurred in preg_replace.
        if ($invitation === null) {
            throw new moodle_exception(
                'invitationmodificationfailed',
                'mod_zoom',
                $PAGE->url,
                ['element' => $element, 'pattern' => $configregex[$element]]
            );
        }

        // Add debugging message to assist site administrator in testing regex patterns if no match is found.
        if (empty($count)) {
            debugging(
                get_string(
                    'invitationmatchnotfound',
                    'mod_zoom',
                    ['element' => $element, 'pattern' => $configregex[$element]]
                ),
                DEBUG_DEVELOPER
            );
        }

        return $invitation;
    }

    /**
     * Add a paragraph break above an element defined by a regex pattern in a zoom invitation.
     *
     * @param string $invitation
     * @param string $element
     * @return string
     *
     * @throws \coding_exception
     * @throws \dml_exception
     */
    private function add_paragraph_break_above_element(string $invitation, string $element): string {
        $matches = [];
        $configregex = $this->get_config_invitation_regex();
        // If no pattern found for element, return the invitation string unaltered.
        if (empty($configregex[$element])) {
            return $invitation;
        }

        $result = preg_match($configregex[$element], $invitation, $matches, PREG_OFFSET_CAPTURE);
        // If error occurred in preg_match, show debugging message to help site administrator.
        if ($result === false) {
            debugging(
                get_string(
                    'invitationmodificationfailed',
                    'mod_zoom',
                    ['element' => $element, 'pattern' => $configregex[$element]]
                ),
                DEBUG_DEVELOPER
            );
        }

        // No match found, so return invitation string unaltered.
        if (empty($matches)) {
            return $invitation;
        }

        // Get the position of the element in the full invitation string.
        $pos = $matches[0][1];
        // Inject a paragraph break above element. Use $this->clean_paragraphs() to fix uneven breaks between paragraphs.
        return substr_replace($invitation, "\r\n\r\n", $pos, 0);
    }

    /**
     * Ensure that paragraphs in string have correct spacing.
     *
     * @param string $invitation
     * @return string
     */
    private function clean_paragraphs(string $invitation): string {
        // Replace partial paragraph breaks with exactly two line breaks.
        $invitation = preg_replace("/\r\n\n/m", "\r\n\r\n", $invitation);
        // Replace breaks of more than two line breaks with exactly two.
        $invitation = preg_replace("/\r\n\r\n[\r\n]+/m", "\r\n\r\n", $invitation);
        return $invitation;
    }

    /**
     * Get regex patterns from site config to find the different zoom invitation elements.
     *
     * @return array
     * @throws \dml_exception
     */
    private function get_config_invitation_regex(): array {
        if ($this->configregex !== null) {
            return $this->configregex;
        }

        $config = get_config('zoom');
        $this->configregex = [];
        // Get the regex defined in the plugin settings for each element.
        foreach (self::get_default_invitation_regex() as $element => $pattern) {
            $settingname = self::PREFIX . $element;
            $this->configregex[$element] = $config->$settingname;
        }

        return $this->configregex;
    }

    /**
     * Get default regex patterns to find the different zoom invitation elements.
     *
     * @return string[]
     */
    public static function get_default_invitation_regex(): array {
        return [
            'invite' => '/^.+is inviting you to a scheduled zoom meeting.+$/mi',
            'joinurl' => '/^join zoom meeting.*(\n.*)+?(\nmeeting id.+\npasscode.+)$/mi',
            'onetapmobile' => '/^one tap mobile.*(\n\s*\+.+)+$/mi',
            'dialin' => '/^dial by your location.*(\n\s*\+.+)+(\n.*)+find your local number.+$/mi',
            'sip' => '/^join by sip.*\n.+$/mi',
            'h323' => '/^join by h\.323.*(\n.*)+?(\nmeeting id.+\npasscode.+)$/mi',
            'icallink' => '/^.+download and import the following iCalendar.+$\n.+$/mi',
        ];
    }
}

====================

file: join_meeting_button_clicked.php
path: classes/event/join_meeting_button_clicked.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Contains the event class for when a user clicks a 'Join Meeting' button.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\event;

use coding_exception;
use moodle_url;

/**
 * Records when a join meeting button is clicked.
 */
class join_meeting_button_clicked extends \core\event\base {
    /**
     * Initializes the event.
     */
    protected function init() {
        $this->data['edulevel'] = self::LEVEL_PARTICIPATING;
        $this->data['crud'] = 'r';
        $this->data['objecttable'] = 'zoom';
    }

    /**
     * Validates arguments.
     */
    protected function validate_data() {
        $fieldstovalidate = ['cmid' => "integer", 'meetingid' => "integer", 'userishost' => "boolean"];
        foreach ($fieldstovalidate as $field => $shouldbe) {
            if (is_null($this->other[$field])) {
                throw new coding_exception("The $field value must be set in other.");
            } else if (gettype($this->other[$field]) != $shouldbe) {
                throw new coding_exception("The $field value must be an $shouldbe.");
            }
        }
    }

    /**
     * Returns the name of the event.
     *
     * @return string
     */
    public static function get_name() {
        return get_string('clickjoin', 'mod_zoom');
    }

    /**
     * Returns a short description for the event.
     *
     * @return string
     */
    public function get_description() {
        return "User '$this->userid' " . ($this->other['userishost'] ? 'started' : 'joined') . " meeting with meeting_id '" .
                $this->other['meetingid'] . "' in course '$this->courseid'";
    }

    /**
     * Returns URL to meeting view page.
     *
     * @return moodle_url
     */
    public function get_url() {
        return new moodle_url('/mod/zoom/view.php', ['id' => $this->other['cmid']]);
    }
}

====================

file: course_module_viewed.php
path: classes/event/course_module_viewed.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Defines the view event.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\event;

/**
 * The mod_zoom instance list viewed event class
 *
 * If the view mode needs to be stored as well, you may need to
 * override methods get_url() and get_legacy_log_data(), too.
 */
class course_module_viewed extends \core\event\course_module_viewed {
    /**
     * Initialize the event
     */
    protected function init() {
        $this->data['objecttable'] = 'zoom';
        parent::init();
    }
}

====================

file: course_module_instance_list_viewed.php
path: classes/event/course_module_instance_list_viewed.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * The mod_zoom instance list viewed event.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\event;

/**
 * The mod_zoom instance list viewed event class.
 */
class course_module_instance_list_viewed extends \core\event\course_module_instance_list_viewed {
}

====================

file: bad_request_exception.php
path: classes/bad_request_exception.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Exception class for Zoom API errors.
 *
 * @package   mod_zoom
 * @copyright 2023 Jonathan Champ <jrchamp@ncsu.edu>
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

/**
 * Bad request received by Zoom.
 */
class bad_request_exception extends webservice_exception {
    /**
     * Constructor
     * @param string $response      Web service response message
     * @param int $errorcode     Web service response error code
     */
    public function __construct($response, $errorcode) {
        parent::__construct($response, $errorcode, 'errorwebservice_badrequest', 'mod_zoom', '', $response);
    }
}

====================

file: activity.php
path: classes/search/activity.php
codice:
<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Search area for mod_zoom activities.
 *
 * @package    mod_zoom
 * @copyright  2019 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\search;

use core_search\base_activity;

/**
 * Search area for mod_zoom activities.
 */
class activity extends base_activity {
    /**
     * Returns true if this area uses file indexing.
     *
     * @return bool
     */
    public function uses_file_indexing() {
        return true;
    }
}

====================

file: retry_failed_exception.php
path: classes/retry_failed_exception.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Exception class for Zoom API errors.
 *
 * @package   mod_zoom
 * @copyright 2023 Jonathan Champ <jrchamp@ncsu.edu>
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

use stdClass;

/**
 * Couldn't succeed within the allowed number of retries.
 */
class retry_failed_exception extends webservice_exception {
    /**
     * Constructor
     * @param string $response      Web service response
     * @param int $errorcode     Web service response error code
     */
    public function __construct($response, $errorcode) {
        $a = new stdClass();
        $a->response = $response;
        $a->maxretries = webservice::MAX_RETRIES;
        parent::__construct($response, $errorcode, 'zoomerr_maxretries', 'mod_zoom', '', $a);
    }
}

====================

file: delete_meeting_recordings.php
path: classes/task/delete_meeting_recordings.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * The task for deleting recordings in Moodle if removed from Zoom.
 *
 * @package    mod_zoom
 * @author     Jwalit Shah <jwalitshah@catalyst-au.net>
 * @copyright  2021 Jwalit Shah <jwalitshah@catalyst-au.net>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\task;

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot . '/mod/zoom/locallib.php');

use core\task\scheduled_task;
use moodle_exception;

/**
 * Scheduled task to delete meeting recordings from Moodle.
 */
class delete_meeting_recordings extends scheduled_task {
    /**
     * Returns name of task.
     *
     * @return string
     */
    public function get_name() {
        return get_string('deletemeetingrecordings', 'mod_zoom');
    }

    /**
     * Delete any recordings that have been removed from zoom.
     *
     * @return void
     */
    public function execute() {
        global $DB;

        try {
            $service = zoom_webservice();
        } catch (moodle_exception $exception) {
            mtrace('Skipping task - ', $exception->getMessage());
            return;
        }

        // Required scopes for deleting meeting recordings.
        $requiredscopes = [
            'classic' => [
                'recording:read:admin',
            ],
            'granular' => [
                'cloud_recording:read:list_recording_files:admin',
            ],
        ];

        // Checking for missing scopes.
        $missingscopes = $service->check_scopes($requiredscopes);
        if (!empty($missingscopes)) {
            foreach ($missingscopes as $missingscope) {
                mtrace('Missing scope: ' . $missingscope);
            }
            return;
        }

        // See if we cannot make anymore API calls.
        $retryafter = get_config('zoom', 'retry-after');
        if (!empty($retryafter) && time() < $retryafter) {
            mtrace('Out of API calls, retry after ' . userdate($retryafter, get_string('strftimedaydatetime', 'core_langconfig')));
            return;
        }

        mtrace('Checking if any meeting recordings in Moodle have been removed from Zoom...');

        // Get all recordings stored in Moodle, grouped by meetinguuid.
        $zoomrecordings = zoom_get_meeting_recordings_grouped();
        foreach ($zoomrecordings as $meetinguuid => $recordings) {
            try {
                // Now check which recordings still exist on Zoom.
                $recordinglist = $service->get_recording_url_list($meetinguuid);
                foreach ($recordinglist as $recordinginfo) {
                    $zoomrecordingid = trim($recordinginfo->recordingid);
                    if (isset($recordings[$zoomrecordingid])) {
                        mtrace('Recording id: ' . $zoomrecordingid . ' exist(s)...skipping');
                        unset($recordings[$zoomrecordingid]);
                    }
                }

                // If recordings are in Moodle but not in Zoom, we need to remove them from Moodle as well.
                foreach ($recordings as $zoomrecordingid => $recording) {
                    mtrace('Deleting recording with id: ' . $zoomrecordingid . ' because the recording is no longer in Zoom.');
                    $DB->delete_records('zoom_meeting_recordings', ['zoomrecordingid' => $zoomrecordingid]);
                }
            } catch (moodle_exception $e) {
                mtrace('Exception occurred: ' . $e->getMessage());
            }
        }
    }
}

====================

file: get_meeting_recordings.php
path: classes/task/get_meeting_recordings.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * The task for getting recordings from Zoom to Moodle.
 *
 * @package    mod_zoom
 * @author     Jwalit Shah <jwalitshah@catalyst-au.net>
 * @copyright  2021 Jwalit Shah <jwalitshah@catalyst-au.net>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\task;

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot . '/mod/zoom/locallib.php');

use core\task\scheduled_task;
use moodle_exception;
use stdClass;

/**
 * Scheduled task to get the meeting recordings.
 */
class get_meeting_recordings extends scheduled_task {
    /**
     * Returns name of task.
     *
     * @return string
     */
    public function get_name() {
        return get_string('getmeetingrecordings', 'mod_zoom');
    }

    /**
     * Get any new recordings that have been added on zoom.
     *
     * @return void
     */
    public function execute() {
        global $DB;

        try {
            $service = zoom_webservice();
        } catch (moodle_exception $exception) {
            mtrace('Skipping task - ', $exception->getMessage());
            return;
        }

        $config = get_config('zoom');
        if (empty($config->viewrecordings)) {
            mtrace('Skipping task - ', get_string('zoomerr_viewrecordings_off', 'zoom'));
            return;
        }

        // Required scopes for meeting recordings.
        $requiredscopes = [
            'classic' => [
                'recording:read:admin',
            ],
            'granular' => [
                'cloud_recording:read:list_user_recordings:admin',
                'cloud_recording:read:recording_settings:admin',
            ],
        ];

        // Checking for missing scopes.
        $missingscopes = $service->check_scopes($requiredscopes);
        if (!empty($missingscopes)) {
            foreach ($missingscopes as $missingscope) {
                mtrace('Missing scope: ' . $missingscope);
            }
            return;
        }

        // See if we cannot make anymore API calls.
        $retryafter = get_config('zoom', 'retry-after');
        if (!empty($retryafter) && time() < $retryafter) {
            mtrace('Out of API calls, retry after ' . userdate($retryafter, get_string('strftimedaydatetime', 'core_langconfig')));
            return;
        }

        mtrace('Finding meeting recordings for this account...');

        $localmeetings = zoom_get_all_meeting_records();

        $now = time();
        $from = gmdate('Y-m-d', strtotime('-1 day', $now));
        $to = gmdate('Y-m-d', strtotime('+1 day', $now));

        $hostmeetings = [];

        foreach ($localmeetings as $zoom) {
            // Only get recordings for this meeting if its recurring or already finished.
            if ($zoom->recurring || $now > (intval($zoom->start_time) + intval($zoom->duration))) {
                $hostmeetings[$zoom->host_id][$zoom->meeting_id] = $zoom;
            }
        }

        if (empty($hostmeetings)) {
            mtrace('No meetings need to be processed.');
            return;
        }

        $meetingpasscodes = [];
        $localrecordings = zoom_get_meeting_recordings_grouped();

        foreach ($hostmeetings as $hostid => $meetings) {
            // Fetch all recordings for this user.
            $zoomrecordings = $service->get_user_recordings($hostid, $from, $to);

            foreach ($zoomrecordings as $recordingid => $recording) {
                if (isset($localrecordings[$recording->meetinguuid][$recordingid])) {
                    mtrace('Recording id: ' . $recordingid . ' exists...skipping');
                    $localrecording = $localrecordings[$recording->meetinguuid][$recordingid];

                    if ($localrecording->recordingtype !== $recording->recordingtype) {
                        $updatemeeting = (object) [
                            'id' => $localrecording->id,
                            'recordingtype' => $recording->recordingtype,
                        ];
                        $DB->update_record('zoom_meeting_recordings', $updatemeeting);
                    }
                    continue;
                }

                if (empty($meetings[$recording->meetingid])) {
                    // Skip meetings that are not in Moodle.
                    mtrace('Meeting id: ' . $recording->meetingid . ' does not exist...skipping');
                    continue;
                }

                // As of 2023-09-24, 'password' is not present in the user recordings API response.
                if (empty($meetingpasscodes[$recording->meetinguuid])) {
                    try {
                        $settings = $service->get_recording_settings($recording->meetinguuid);
                        $meetingpasscodes[$recording->meetinguuid] = $settings->password;
                    } catch (moodle_exception $error) {
                        continue;
                    }
                }

                $zoom = $meetings[$recording->meetingid];
                $recordingtype = $recording->recordingtype;

                $record = new stdClass();
                $record->zoomid = $zoom->id;
                $record->meetinguuid = $recording->meetinguuid;
                $record->zoomrecordingid = $recordingid;
                $record->name = $zoom->name;
                $record->externalurl = $recording->url;
                $record->passcode = $meetingpasscodes[$recording->meetinguuid];
                $record->recordingtype = $recordingtype;
                $record->recordingstart = $recording->recordingstart;
                $record->showrecording = $zoom->recordings_visible_default;
                $record->timecreated = $now;
                $record->timemodified = $now;

                $record->id = $DB->insert_record('zoom_meeting_recordings', $record);
                mtrace('Recording id: ' . $recordingid . ' (' . $recordingtype . ') added to the database');
            }
        }
    }
}

====================

file: get_meeting_reports.php.ori
path: classes/task/get_meeting_reports.php.ori
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Task: get_meeting_reports
 *
 * @package    mod_zoom
 * @copyright  2018 UC Regents
 * @author     Kubilay Agi
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\task;

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot . '/mod/zoom/locallib.php');

use context_course;
use core\message\message;
use core\task\scheduled_task;
use core_user;
use dml_exception;
use Exception;
use html_writer;
use mod_zoom\not_found_exception;
use mod_zoom\retry_failed_exception;
use mod_zoom\webservice_exception;
use moodle_exception;
use moodle_url;
use stdClass;

/**
 * Scheduled task to get the meeting participants for each .
 */
class get_meeting_reports extends scheduled_task {
    /**
     * Percentage in which we want similar_text to reach before we consider
     * using its results.
     */
    private const SIMILARNAME_THRESHOLD = 60;

    /**
     * Used to determine if debugging is turned on or off for outputting messages.
     * @var bool
     */
    public $debuggingenabled = false;

    /**
     * The mod_zoom\webservice instance used to query for data. Can be stubbed
     * for unit testing.
     * @var mod_zoom\webservice
     */
    public $service = null;

    /**
     * Sort meetings by end time.
     * @param array $a One meeting/webinar object array to compare.
     * @param array $b Another meeting/webinar object array to compare.
     */
    private function cmp($a, $b) {
        if ($a->end_time == $b->end_time) {
            return 0;
        }

        return ($a->end_time < $b->end_time) ? -1 : 1;
    }

    /**
     * Gets the meeting IDs from the queue, retrieve the information for each
     * meeting, then remove the meeting from the queue.
     *
     * @param string $paramstart    If passed, will find meetings starting on given date. Format is YYYY-MM-DD.
     * @param string $paramend      If passed, will find meetings ending on given date. Format is YYYY-MM-DD.
     * @param array $hostuuids      If passed, will find only meetings for given array of host uuids.
     */
    public function execute($paramstart = null, $paramend = null, $hostuuids = null) {
        try {
            $this->service = zoom_webservice();
        } catch (moodle_exception $exception) {
            mtrace('Skipping task - ', $exception->getMessage());
            return;
        }

        // See if we cannot make anymore API calls.
        $retryafter = get_config('zoom', 'retry-after');
        if (!empty($retryafter) && time() < $retryafter) {
            mtrace('Out of API calls, retry after ' . userdate($retryafter, get_string('strftimedaydatetime', 'core_langconfig')));
            return;
        }

        $this->debuggingenabled = debugging();

        // If running as a task, then record when we last left off if
        // interrupted or finish.
        $runningastask = true;

        if (!empty($hostuuids)) {
            $runningastask = false;
        }

        if (!empty($paramstart)) {
            $starttime = strtotime($paramstart);
            $runningastask = false;
        } else {
            $starttime = get_config('zoom', 'last_call_made_at');
        }

        if (empty($starttime)) {
            // Zoom only provides data from 30 days ago.
            $starttime = strtotime('-30 days');
        }

        if (!empty($paramend)) {
            $endtime = strtotime($paramend);
            $runningastask = false;
        }

        if (empty($endtime)) {
            $endtime = time();
        }

        // Zoom requires this format when passing the to and from arguments.
        // Zoom just returns all the meetings from the day range instead of
        // actual time range specified.
        $start = gmdate('Y-m-d', $starttime);
        $end = gmdate('Y-m-d', $endtime);

        mtrace(sprintf('Finding meetings between %s to %s', $start, $end));

        $recordedallmeetings = true;

        $dashboardscopes = [
            'dashboard_meetings:read:admin',
            'dashboard_webinars:read:admin',
            'dashboard:read:list_meetings:admin',
            'dashboard:read:list_webinars:admin',
        ];

        $reportscopes = [
            'report:read:admin',
            'report:read:list_users:admin',
        ];

        // Can only query on $hostuuids using Report API.
        if (empty($hostuuids) && $this->service->has_scope($dashboardscopes)) {
            $allmeetings = $this->get_meetings_via_dashboard($start, $end);
        } else if ($this->service->has_scope($reportscopes)) {
            $allmeetings = $this->get_meetings_via_reports($start, $end, $hostuuids);
        } else {
            mtrace('Skipping task - missing OAuth scopes required for reports');
            return;
        }

        // Sort all meetings based on end_time so that we know where to pick
        // up again if we run out of API calls.
        $allmeetings = array_map([$this, 'normalize_meeting'], $allmeetings);
        usort($allmeetings, [$this, 'cmp']);

        mtrace("Processing " . count($allmeetings) . " meetings");

        foreach ($allmeetings as $meeting) {
            // Only process meetings if they happened after the time we left off.
            $meetingtime = ($meeting->end_time == intval($meeting->end_time)) ? $meeting->end_time : strtotime($meeting->end_time);
            if ($runningastask && $meetingtime <= $starttime) {
                continue;
            }

            try {
                if (!$this->process_meeting_reports($meeting)) {
                    // If returned false, then ran out of API calls or got
                    // unrecoverable error. Try to pick up where we left off.
                    if ($runningastask) {
                        // Only want to resume if we were processing all reports.
                        $recordedallmeetings = false;
                        set_config('last_call_made_at', $meetingtime - 1, 'zoom');
                    }

                    break;
                }
            } catch (Exception $e) {
                mtrace($e->getMessage());
                mtrace($e->getTraceAsString());
                // Some unknown error, need to handle it so we can record
                // where we left off.
                if ($runningastask) {
                    $recordedallmeetings = false;
                    set_config('last_call_made_at', $meetingtime - 1, 'zoom');
                    break;
                }
            }
        }

        if ($recordedallmeetings && $runningastask) {
            // All finished, so save the time that we set end time for the initial query.
            set_config('last_call_made_at', $endtime, 'zoom');
        }
    }

    /**
     * Formats participants array as a record for the database.
     *
     * @param stdClass $participant Unformatted array received from web service API call.
     * @param int $detailsid The id to link to the zoom_meeting_details table.
     * @param array $names Array that contains mappings of user's moodle ID to the user's name.
     * @param array $emails Array that contains mappings of user's moodle ID to the user's email.
     * @return array Formatted array that is ready to be inserted into the database table.
     */
    public function format_participant($participant, $detailsid, $names, $emails) {
        global $DB;
        $moodleuser = null;
        $moodleuserid = null;
        $name = null;

        // Consolidate fields.
        $participant->name = $participant->name ?? $participant->user_name ?? '';
        $participant->id = $participant->id ?? $participant->participant_user_id ?? '';
        $participant->user_email = $participant->user_email ?? $participant->email ?? '';

        // Cleanup the name. For some reason # gets into the name instead of a comma.
        $participant->name = str_replace('#', ',', $participant->name);

        // Extract the ID and name from the participant's name if it is in the format "(id)Name".
        if (preg_match('/^\((\d+)\)(.+)$/', $participant->name, $matches)) {
            $moodleuserid = $matches[1];
            $name = trim($matches[2]);
        } else {
            $name = $participant->name;
        }

        // Try to see if we successfully queried for this user and found a Moodle id before.
        if (!empty($participant->id)) {
            // Sometimes uuid is blank from Zoom.
            $participantmatches = $DB->get_records(
                'zoom_meeting_participants',
                ['uuid' => $participant->id],
                null,
                'id, userid, name'
            );

            if (!empty($participantmatches)) {
                // Found some previous matches. Find first one with userid set.
                foreach ($participantmatches as $participantmatch) {
                    if (!empty($participantmatch->userid)) {
                        $moodleuserid = $participantmatch->userid;
                        $name = $participantmatch->name;
                        break;
                    }
                }
            }
        }

        // Did not find a previous match.
        if (empty($moodleuserid)) {
            if (!empty($participant->user_email) && ($moodleuserid = array_search(strtoupper($participant->user_email), $emails))) {
                // Found email from list of enrolled users.
                $name = $names[$moodleuserid];
            } else if (!empty($participant->name) && ($moodleuserid = array_search(strtoupper($participant->name), $names))) {
                // Found name from list of enrolled users.
                $name = $names[$moodleuserid];
            } else if (
                !empty($participant->user_email)
                && ($moodleuser = $DB->get_record('user', [
                    'email' => $participant->user_email,
                    'deleted' => 0,
                    'suspended' => 0,
                ], '*', IGNORE_MULTIPLE))
            ) {
                // This is the case where someone attends the meeting, but is not enrolled in the class.
                $moodleuserid = $moodleuser->id;
                $name = strtoupper(fullname($moodleuser));
            } else if (!empty($participant->name) && ($moodleuserid = $this->match_name($participant->name, $names))) {
                // Found name by using fuzzy text search.
                $name = $names[$moodleuserid];
            } else {
                // Did not find any matches, so use what is given by Zoom.
                $name = $participant->name;
                $moodleuserid = null;
            }
        }

        if ($participant->user_email === '') {
            if (!empty($moodleuserid)) {
                $participant->user_email = $DB->get_field('user', 'email', ['id' => $moodleuserid]);
            } else {
                $participant->user_email = null;
            }
        }

        if ($participant->id === '') {
            $participant->id = null;
        }

        return [
            'name' => $name,
            'userid' => $moodleuserid,
            'detailsid' => $detailsid,
            'zoomuserid' => $participant->user_id,
            'uuid' => $participant->id,
            'user_email' => $participant->user_email,
            'join_time' => strtotime($participant->join_time),
            'leave_time' => strtotime($participant->leave_time),
            'duration' => $participant->duration,
        ];
    }

    /**
     * Get enrollment for given course.
     *
     * @param int $courseid
     * @return array    Returns an array of names and emails.
     */
    public function get_enrollments($courseid) {
        // Loop through each user to generate name->uids mapping.
        $coursecontext = context_course::instance($courseid);
        $enrolled = get_enrolled_users($coursecontext);
        $names = [];
        $emails = [];
        foreach ($enrolled as $user) {
            $name = strtoupper(fullname($user));
            $names[$user->id] = $name;
            $emails[$user->id] = strtoupper(zoom_get_api_identifier($user));
        }

        return [$names, $emails];
    }

    /**
     * Get meetings first by querying for active hostuuids for given time
     * period. Then find meetings that host have given in given time period.
     *
     * This is the older method of querying for meetings. It has been superseded
     * by the Dashboard API. However, that API is only available for Business
     * accounts and higher. The Reports API is available for Pro user and up.
     *
     * This method is kept for those users that have Pro accounts and using
     * this plugin.
     *
     * @param string $start    If passed, will find meetings starting on given date. Format is YYYY-MM-DD.
     * @param string $end      If passed, will find meetings ending on given date. Format is YYYY-MM-DD.
     * @param array $hostuuids If passed, will find only meetings for given array of host uuids.
     *
     * @return array
     */
    public function get_meetings_via_reports($start, $end, $hostuuids) {
        global $DB;
        mtrace('Using Reports API');
        if (empty($hostuuids)) {
            $this->debugmsg('Empty hostuuids, querying all hosts');
            // Get all hosts.
            $activehostsuuids = $this->service->get_active_hosts_uuids($start, $end);
        } else {
            $this->debugmsg('Hostuuids passed');
            // Else we just want a specific hosts.
            $activehostsuuids = $hostuuids;
        }

        $allmeetings = [];
        $localhosts = $DB->get_records_menu('zoom', null, '', 'id, host_id');

        mtrace("Processing " . count($activehostsuuids) . " active host uuids");

        foreach ($activehostsuuids as $activehostsuuid) {
            // This API call returns information about meetings and webinars,
            // don't need extra functionality for webinars.
            $usersmeetings = [];
            if (in_array($activehostsuuid, $localhosts)) {
                $this->debugmsg('Getting meetings for host uuid ' . $activehostsuuid);
                try {
                    $usersmeetings = $this->service->get_user_report($activehostsuuid, $start, $end);
                } catch (not_found_exception $e) {
                    // Zoom API returned user not found for a user it said had,
                    // meetings. Have to skip user.
                    $this->debugmsg("Skipping $activehostsuuid because user does not exist on Zoom");
                    continue;
                } catch (retry_failed_exception $e) {
                    // Hit API limit, so cannot continue.
                    mtrace($e->response . ': ' . $e->zoomerrorcode);
                    return;
                }
            } else {
                // Ignore hosts who hosted meetings outside of integration.
                continue;
            }

            $this->debugmsg(sprintf('Found %d meetings for user', count($usersmeetings)));
            foreach ($usersmeetings as $usermeeting) {
                $allmeetings[] = $usermeeting;
            }
        }

        return $allmeetings;
    }

    /**
     * Get meetings and webinars using Dashboard API.
     *
     * @param string $start    If passed, will find meetings starting on given date. Format is YYYY-MM-DD.
     * @param string $end      If passed, will find meetings ending on given date. Format is YYYY-MM-DD.
     *
     * @return array
     */
    public function get_meetings_via_dashboard($start, $end) {
        mtrace('Using Dashboard API');

        $meetingscopes = [
            'dashboard_meetings:read:admin',
            'dashboard:read:list_meetings:admin',
        ];

        $webinarscopes = [
            'dashboard_webinars:read:admin',
            'dashboard:read:list_webinars:admin',
        ];

        $meetings = [];
        if ($this->service->has_scope($meetingscopes)) {
            $meetings = $this->service->get_meetings($start, $end);
        }

        $webinars = [];
        if ($this->service->has_scope($webinarscopes)) {
            $webinars = $this->service->get_webinars($start, $end);
        }

        $allmeetings = array_merge($meetings, $webinars);

        return $allmeetings;
    }

    /**
     * Returns name of task.
     *
     * @return string
     */
    public function get_name() {
        return get_string('getmeetingreports', 'mod_zoom');
    }

    /**
     * Tries to match a given name to the roster using two different fuzzy text
     * matching algorithms and if they match, then returns the match.
     *
     * @param string $nametomatch
     * @param array $rosternames    Needs to be an array larger than 3 for any
     *                              meaningful results.
     *
     * @return int  Returns id for $rosternames. Returns false if no match found.
     */
    private function match_name($nametomatch, $rosternames) {
        if (count($rosternames) < 3) {
            return false;
        }

        $nametomatch = strtoupper($nametomatch);
        $similartextscores = [];
        $levenshteinscores = [];
        foreach ($rosternames as $name) {
            similar_text($nametomatch, $name, $percentage);
            if ($percentage > self::SIMILARNAME_THRESHOLD) {
                $similartextscores[$name] = $percentage;
                $levenshteinscores[$name] = levenshtein($nametomatch, $name);
            }
        }

        // If we did not find any quality matches, then return false.
        if (empty($similartextscores)) {
            return false;
        }

        // Simlar text has better matches with higher numbers.
        arsort($similartextscores);
        reset($similartextscores);  // Make sure key gets first element.
        $stmatch = key($similartextscores);

        // Levenshtein has better matches with lower numbers.
        asort($levenshteinscores);
        reset($levenshteinscores);  // Make sure key gets first element.
        $lmatch = key($levenshteinscores);

        // If both matches, then we can be rather sure that it is the same user.
        if ($stmatch == $lmatch) {
            $moodleuserid = array_search($stmatch, $rosternames);
            return $moodleuserid;
        } else {
            return false;
        }
    }

    /**
     * Outputs finer grained debugging messaging if debug mode is on.
     *
     * @param string $msg
     */
    public function debugmsg($msg) {
        if ($this->debuggingenabled) {
            mtrace($msg);
        }
    }

    /**
     * Saves meeting details and participants for reporting.
     *
     * @param object $meeting    Normalized meeting object
     * @return boolean
     */
    public function process_meeting_reports($meeting) {
        global $DB;

        $this->debugmsg(sprintf(
            'Processing meeting %s|%s that occurred at %s',
            $meeting->meeting_id,
            $meeting->uuid,
            $meeting->start_time
        ));

        // If meeting doesn't exist in the zoom database, the instance is
        // deleted, and we don't need reports for these.
        if (!($zoomrecord = $DB->get_record('zoom', ['meeting_id' => $meeting->meeting_id], '*', IGNORE_MULTIPLE))) {
            mtrace('Meeting does not exist locally; skipping');
            return true;
        }

        $meeting->zoomid = $zoomrecord->id;
        // Insert or update meeting details.
        if (!($DB->record_exists('zoom_meeting_details', ['uuid' => $meeting->uuid]))) {
            $this->debugmsg('Inserting zoom_meeting_details');
	    $detailsid = $DB->insert_record('zoom_meeting_details', $meeting);
	} else {
            // Details entry already exists, so update it.
            $this->debugmsg('Updating zoom_meeting_details');
            $detailsid = $DB->get_field('zoom_meeting_details', 'id', ['uuid' => $meeting->uuid]);
            $meeting->id = $detailsid;
            $DB->update_record('zoom_meeting_details', $meeting);
        }

        try {
            $participants = $this->service->get_meeting_participants($meeting->uuid, $zoomrecord->webinar);
        } catch (not_found_exception $e) {
            mtrace(sprintf('Warning: Cannot find meeting %s|%s; skipping', $meeting->meeting_id, $meeting->uuid));
            return true;    // Not really a show stopping error.
        } catch (webservice_exception $e) {
            mtrace($e->response . ': ' . $e->zoomerrorcode);
            return false;
        }

        // Loop through each user to generate name->uids mapping.
        [$names, $emails] = $this->get_enrollments($zoomrecord->course);

        $this->debugmsg(sprintf('Processing %d participants', count($participants)));

        // Now try to insert new participant records.
        // There is no unique key, so we make sure each record's data is distinct.
        try {
            $transaction = $DB->start_delegated_transaction();

            $count = $DB->count_records('zoom_meeting_participants', ['detailsid' => $detailsid]);
            if (!empty($count)) {
                $this->debugmsg(sprintf('Existing participant records: %d', $count));
                // No need to delete old records, we don't insert matching records.
            }

            // To prevent sending notifications every time the task ran check if there is inserted new records.
            $recordupdated = false;
            foreach ($participants as $rawparticipant) {
                $this->debugmsg(sprintf(
                    'Working on %s (user_id: %d, uuid: %s)',
                    $rawparticipant->name,
                    $rawparticipant->user_id,
                    $rawparticipant->id
                ));
                $participant = $this->format_participant($rawparticipant, $detailsid, $names, $emails);

                // These conditions are enough.
                $conditions = [
                    'name' => $participant['name'],
                    'userid' => $participant['userid'],
                    'detailsid' => $participant['detailsid'],
                    'zoomuserid' => $participant['zoomuserid'],
                    'join_time' => $participant['join_time'],
                    'leave_time' => $participant['leave_time'],
                ];

                // Check if the record already exists.
                if ($record = $DB->get_record('zoom_meeting_participants', $conditions)) {
                    // The exact record already exists, so do nothing.
                    $this->debugmsg('Record already exists ' . $record->id);
                } else {
                    // Insert all new records.
		    $recordid = $DB->insert_record('zoom_meeting_participants', $participant, true);
                    // At least one new record inserted.
                    $recordupdated = true;
                    $this->debugmsg('Inserted record ' . $recordid);
                }
            }

            // If there are new records and the grading method is attendance duration.
            // Check the grading method settings.
            if (!empty($zoomrecord->grading_method)) {
                $gradingmethod = $zoomrecord->grading_method;
            } else if ($defaultgrading = get_config('gradingmethod', 'zoom')) {
                $gradingmethod = $defaultgrading;
            } else {
                $gradingmethod = 'entry';
            }

            if ($recordupdated && $gradingmethod === 'period') {
                // Grade users according to their duration in the meeting.
                $this->grading_participant_upon_duration($zoomrecord, $detailsid);
            }

            $transaction->allow_commit();
        } catch (dml_exception $exception) {
            $transaction->rollback($exception);
            mtrace('ERROR: Cannot insert zoom_meeting_participants: ' . $exception->getMessage());
            return false;
        }

        $this->debugmsg('Finished updating meeting report');
        return true;
    }

    /**
     * Update the grades of users according to their duration in the meeting.
     * @param object $zoomrecord
     * @param int $detailsid
     * @return void
     */
    public function grading_participant_upon_duration($zoomrecord, $detailsid) {
        global $CFG, $DB;

        require_once($CFG->libdir . '/gradelib.php');
        $courseid = $zoomrecord->course;
        $context = context_course::instance($courseid);
        // Get grade list for items.
        $gradelist = grade_get_grades($courseid, 'mod', 'zoom', $zoomrecord->id);

        // Is this meeting is not gradable, return.
        if (empty($gradelist->items)) {
            return;
        }

        $gradeitem = $gradelist->items[0];
        $itemid = $gradeitem->id;
        $grademax = $gradeitem->grademax;
        $oldgrades = $gradeitem->grades;

        // After check and testing, these timings are the actual meeting timings returned from zoom
        // ... (i.e.when the host start and end the meeting).
        // Not like those on 'zoom' table which represent the settings from zoom activity.
        $meetingtime = $DB->get_record('zoom_meeting_details', ['id' => $detailsid], 'start_time, end_time');
        if (empty($zoomrecord->recurring)) {
            $end = min($meetingtime->end_time, $zoomrecord->start_time + $zoomrecord->duration);
            $start = max($meetingtime->start_time, $zoomrecord->start_time);
            $meetingduration = $end - $start;
        } else {
            $meetingduration = $meetingtime->end_time - $meetingtime->start_time;
        }

        // Get the required records again.
        $records = $DB->get_records('zoom_meeting_participants', ['detailsid' => $detailsid], 'join_time ASC');
        // Initialize the data arrays, indexing them later with userids.
        $durations = [];
        $join = [];
        $leave = [];
        // Looping the data to calculate the duration of each user.
        foreach ($records as $record) {
            $userid = $record->userid;
            if (empty($userid)) {
                if (is_numeric($record->name)) {
                    // In case the participant name looks like an integer, we need to avoid a conflict.
                    $userid = '~' . $record->name . '~';
                } else {
                    $userid = $record->name;
                }
            }

            // Check if there is old duration stored for this user.
            if (!empty($durations[$userid])) {
                $old = new stdClass();
                $old->duration = $durations[$userid];
                $old->join_time = $join[$userid];
                $old->leave_time = $leave[$userid];
                // Calculating the overlap time.
                $overlap = $this->get_participant_overlap_time($old, $record);

                // Set the new data for next use.
                $leave[$userid] = max($old->leave_time, $record->leave_time);
                $join[$userid] = min($old->join_time, $record->join_time);
                $durations[$userid] = $old->duration + $record->duration - $overlap;
            } else {
                $leave[$userid] = $record->leave_time;
                $join[$userid] = $record->join_time;
                $durations[$userid] = $record->duration;
            }
        }

        // Used to count the number of users being graded.
        $graded = 0;
        $alreadygraded = 0;

        // Array of unidentified users that need to be graded manually.
        $needgrade = [];

        // Array of found user ids.
        $found = [];

        // Array of non-enrolled users.
        $notenrolled = [];

        // Now check the duration for each user and grade them according to it.
        foreach ($durations as $userid => $userduration) {
            // Setup the grade according to the duration.
            $newgrade = min($userduration * $grademax / $meetingduration, $grademax);

            // Double check that this is a Moodle user.
            if (is_integer($userid) && (isset($found[$userid]) || $DB->record_exists('user', ['id' => $userid]))) {
                // Successfully found this user in Moodle.
                if (!isset($found[$userid])) {
                    $found[$userid] = true;
                }

                $oldgrade = null;
                if (isset($oldgrades[$userid])) {
                    $oldgrade = $oldgrades[$userid]->grade;
                }

                // Check if the user is enrolled before assign the grade.
                if (is_enrolled($context, $userid)) {
                    // Compare with the old grade and only update if the new grade is higher.
                    // Use number_format because the old stored grade only contains 5 decimals.
                    if (empty($oldgrade) || $oldgrade < number_format($newgrade, 5)) {
                        $gradegrade = [
                            'rawgrade' => $newgrade,
                            'userid' => $userid,
                            'usermodified' => $userid,
                            'dategraded' => '',
                            'feedbackformat' => '',
                            'feedback' => '',
                        ];

                        zoom_grade_item_update($zoomrecord, $gradegrade);
                        $graded++;
                        $this->debugmsg('grade updated for user with id: ' . $userid
                                        . ', duration =' . $userduration
                                        . ', maxgrade =' . $grademax
                                        . ', meeting duration =' . $meetingduration
                                        . ', User grade:' . $newgrade);
                    } else {
                        $alreadygraded++;
                        $this->debugmsg('User already has a higher grade. Old grade: ' . $oldgrade
                                        . ', New grade: ' . $newgrade);
                    }
                } else {
                    $notenrolled[$userid] = fullname(core_user::get_user($userid));
                }
            } else {
                // This means that this user was not identified.
                // Provide information about participants that need to be graded manually.
                $a = [
                    'userid' => $userid,
                    'grade' => $newgrade,
                ];
                $needgrade[] = get_string('nonrecognizedusergrade', 'mod_zoom', $a);
            }
        }

        // Get the list of users who clicked join meeting and were not recognized by the participant report.
        $allusers = $this->get_users_clicked_join($zoomrecord);
        $notfound = [];
        foreach ($allusers as $userid) {
            if (!isset($found[$userid])) {
                $notfound[$userid] = fullname(core_user::get_user($userid));
            }
        }

        // Try not to spam the instructors, only notify them when grades have changed.
        if ($graded > 0) {
            // Sending a notification to teachers in this course about grades, and users that need to be graded manually.
            $notifydata = [
                'graded' => $graded,
                'alreadygraded' => $alreadygraded,
                'needgrade' => $needgrade,
                'courseid' => $courseid,
                'zoomid' => $zoomrecord->id,
                'itemid' => $itemid,
                'name' => $zoomrecord->name,
                'notfound' => $notfound,
                'notenrolled' => $notenrolled,
            ];
            $this->notify_teachers($notifydata);
        }
    }

    /**
     * Calculate the overlap time for a participant.
     *
     * @param object $record1 Record data 1.
     * @param object $record2 Record data 2.
     * @return int the overlap time
     */
    public function get_participant_overlap_time($record1, $record2) {
        // Determine which record starts first.
        if ($record1->join_time < $record2->join_time) {
            $old = $record1;
            $new = $record2;
        } else {
            $old = $record2;
            $new = $record1;
        }

        $oldjoin = (int) $old->join_time;
        $oldleave = (int) $old->leave_time;
        $newjoin = (int) $new->join_time;
        $newleave = (int) $new->leave_time;

        // There are three possible cases.
        if ($newjoin >= $oldleave) {
            // First case - No overlap.
            // Example: old(join: 15:00 leave: 15:30), new(join: 15:35 leave: 15:50).
            // No overlap.
            $overlap = 0;
        } else if ($newleave > $oldleave) {
            // Second case - Partial overlap.
            // Example: new(join: 15:15 leave: 15:45), old(join: 15:00 leave: 15:30).
            // 15 min overlap.
            $overlap = $oldleave - $newjoin;
        } else {
            // Third case - Complete overlap.
            // Example:  new(join: 15:15 leave: 15:29), old(join: 15:00 leave: 15:30).
            // 14 min overlap (new duration).
            $overlap = $new->duration;
        }

        return $overlap;
    }

    /**
     * Sending a notification to all teachers in the course notify them about grading
     * also send the names of the users needing a manual grading.
     * return array of messages ids and false if there is no users in this course
     * with the capability of edit grades.
     *
     * @param array $data
     * @return array|bool
     */
    public function notify_teachers($data) {
        // Number of users graded automatically.
        $graded = $data['graded'];
        // Number of users already graded.
        $alreadygraded = $data['alreadygraded'];
        // Number of users need to be graded.
        $needgradenumber = count($data['needgrade']);
        // List of users need grading.
        $needstring = get_string('grading_needgrade', 'mod_zoom');
        $needgrade = (!empty($data['needgrade'])) ? $needstring . implode('<br>', $data['needgrade']) . "\n" : '';

        $zoomid = $data['zoomid'];
        $itemid = $data['itemid'];
        $name = $data['name'];
        $courseid = $data['courseid'];
        $context = context_course::instance($courseid);
        // Get teachers in the course (actually those with the ability to edit grades).
        $teachers = get_enrolled_users($context, 'moodle/grade:edit', 0, 'u.*', null, 0, 0, true);

        // Grading item url.
        $gurl = new moodle_url(
            '/grade/report/singleview/index.php',
            [
                'id' => $courseid,
                'item' => 'grade',
                'itemid' => $itemid,
            ]
        );
        $gradeurl = html_writer::link($gurl, get_string('gradinglink', 'mod_zoom'));

        // Zoom instance url.
        $zurl = new moodle_url('/mod/zoom/view.php', ['id' => $zoomid]);
        $zoomurl = html_writer::link($zurl, $name);

        // Data object used in lang strings.
        $a = (object) [
            'name' => $name,
            'graded' => $graded,
            'alreadygraded' => $alreadygraded,
            'needgrade' => $needgrade,
            'number' => $needgradenumber,
            'gradeurl' => $gradeurl,
            'zoomurl' => $zoomurl,
            'notfound' => '',
            'notenrolled' => '',
        ];
        // Get the list of users clicked join meeting but not graded or reconized.
        // This helps the teacher to grade them manually.
        $notfound = $data['notfound'];
        if (!empty($notfound)) {
            $a->notfound = get_string('grading_notfound', 'mod_zoom');
            foreach ($notfound as $userid => $fullname) {
                $params = ['item' => 'user', 'id' => $courseid, 'userid' => $userid];
                $url = new moodle_url('/grade/report/singleview/index.php', $params);
                $userurl = html_writer::link($url, $fullname . ' (' . $userid . ')');
                $a->notfound .= '<br> ' . $userurl;
            }
        }

        $notenrolled = $data['notenrolled'];
        if (!empty($notenrolled)) {
            $a->notenrolled = get_string('grading_notenrolled', 'mod_zoom');
            foreach ($notenrolled as $userid => $fullname) {
                $userurl = new moodle_url('/user/profile.php', ['id' => $userid]);
                $profile = html_writer::link($userurl, $fullname);
                $a->notenrolled .= '<br>' . $profile;
            }
        }

        // Prepare the message.
        $message = new message();
        $message->component = 'mod_zoom';
        $message->name = 'teacher_notification'; // The notification name from message.php.
        $message->userfrom = core_user::get_noreply_user();

        $message->subject = get_string('gradingmessagesubject', 'mod_zoom', $a);

        $messagebody = get_string('gradingmessagebody', 'mod_zoom', $a);
        $message->fullmessage = $messagebody;

        $message->fullmessageformat = FORMAT_MARKDOWN;
        $message->fullmessagehtml = "<p>$messagebody</p>";
        $message->smallmessage = get_string('gradingsmallmeassage', 'mod_zoom', $a);
        $message->notification = 1;
        $message->contexturl = $gurl; // This link redirect the teacher to the page of item's grades.
        $message->contexturlname = get_string('gradinglink', 'mod_zoom');
        // Email content.
        $content = ['*' => ['header' => $message->subject, 'footer' => '']];
        $message->set_additional_content('email', $content);
        $messageids = [];
        if (!empty($teachers)) {
            foreach ($teachers as $teacher) {
                $message->userto = $teacher;
                // Actually send the message for each teacher.
                $messageids[] = message_send($message);
            }
        } else {
            return false;
        }

        return $messageids;
    }

    /**
     * The meeting object from the Dashboard API differs from the Report API, so
     * normalize the meeting object to conform to what is expected it the
     * database.
     *
     * @param object $meeting
     * @return object   Normalized meeting object
     */
    public function normalize_meeting($meeting) {
        $normalizedmeeting = new stdClass();

        // Returned meeting object will not be using Zoom's id, because it is a
        // primary key in our own tables.
        $normalizedmeeting->meeting_id = $meeting->id;

        // Convert times to Unixtimestamps.
        $normalizedmeeting->start_time = strtotime($meeting->start_time);
        $normalizedmeeting->end_time = strtotime($meeting->end_time);

        // Copy values that are named the same.
        $normalizedmeeting->uuid = $meeting->uuid;
        $normalizedmeeting->topic = $meeting->topic;

        // Dashboard API has duration as H:M:S while report has it in seconds.
        $timeparts = explode(':', $meeting->duration);

        // Convert duration into seconds.
        if (count($timeparts) === 1) {
            // Time is already in seconds.
            $normalizedmeeting->duration = intval($meeting->duration);
        } else if (count($timeparts) === 2) {
            // Time is in MM:SS format.
            $normalizedmeeting->duration = 60 * $timeparts[0] + $timeparts[1];
        } else {
            // Time is in HH:MM:SS format.
            $normalizedmeeting->duration = 3600 * $timeparts[0] + 60 * $timeparts[1] + $timeparts[2];
        }

        // Copy values that are named differently.
        $normalizedmeeting->participants_count = $meeting->participants ?? $meeting->participants_count;

        // Dashboard API does not have total_minutes.
        $normalizedmeeting->total_minutes = $meeting->total_minutes ?? null;

        return $normalizedmeeting;
    }

    /**
     * Get list of all users clicked (join meeting) in a given zoom instance.
     * @param object $zoomrecord
     * @return array<int>
     */
    public function get_users_clicked_join($zoomrecord) {
        global $DB;
        $logmanager = get_log_manager();
        if (!$readers = $logmanager->get_readers('core\log\sql_reader')) {
            // Should be using 2.8, use old class.
            $readers = $logmanager->get_readers('core\log\sql_select_reader');
        }

        $reader = array_pop($readers);
        if ($reader === null) {
            return [];
        }

        $params = [
            'courseid' => $zoomrecord->course,
            'objectid' => $zoomrecord->id,
        ];
        $selectwhere = "eventname = '\\\\mod_zoom\\\\event\\\\join_meeting_button_clicked'
            AND courseid = :courseid
            AND objectid = :objectid";
        $events = $reader->get_events_select($selectwhere, $params, 'userid ASC', 0, 0);

        $userids = [];
        foreach ($events as $event) {
            if (
                $event->other['meetingid'] === $zoomrecord->meeting_id &&
                !in_array($event->userid, $userids, true)
            ) {
                $userids[] = $event->userid;
            }
        }

        return $userids;
    }
}

====================

file: send_ical_notifications.php
path: classes/task/send_ical_notifications.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Task: send_ical_notification
 *
 * @package    mod_zoom
 * @copyright  2025 OPENCOLLAB <info@opencollab.co.za>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\task;

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot . '/calendar/lib.php');
require_once($CFG->libdir . '/bennu/bennu.inc.php');
require_once($CFG->libdir . '/bennu/iCalendar_components.php');
require_once($CFG->dirroot . '/mod/zoom/locallib.php');

use context_module;
use context_user;
use core_availability\info_module;
use core_user;
use core\message\message;
use core\task\scheduled_task;
use moodle_url;
use stdClass;

/**
 * Scheduled task to send ical notifications for zoom meetings that were scheduled within the last 30 minutes.
 */
class send_ical_notifications extends scheduled_task {
    /**
     * Execute the send ical notifications cron function.
     *
     * @return void nothing.
     */
    public function execute() {
        if (get_config('zoom', 'sendicalnotifications')) {
            mtrace('Zoom ical Notifications - Starting cron job.');
            $zoomevents = $this->get_zoom_events_to_notify();
            if ($zoomevents) {
                foreach ($zoomevents as $zoomevent) {
                    $notificationtime = $this->get_notification_time((int) $zoomevent->id);
                    // Only run if it hasn't run before.
                    if ($notificationtime == 0) {
                        mtrace('A notification will be sent for Zoom event with ID ' . $zoomevent->id);
                        $this->send_zoom_ical_notifications($zoomevent);
                        // Set the notification time for this cron job.
                        $this->set_notification_time((int) $zoomevent->id);
                    }
                }
            } else {
                mtrace('Found no zoom event records to process and notify ' .
                       '(created or modified within the last hour that was not notified before).');
            }
            mtrace('Zoom ical Notifications - Cron job Completed.');
        } else {
            mtrace('The Admin Setting for the Send iCal Notification scheduled task ' .
                   'has not been enabled - will not run the cron job.');
        }
    }

    /**
     * Get zoom events created/modified in the last hour, but ignore the last 10 minutes. This allows
     * the user to still make adjustments to the event before the ical invite is sent out.
     * @return array
     */
    private function get_zoom_events_to_notify() {
        global $DB;

        $sql = 'SELECT *
        FROM {event}
        WHERE modulename = :zoommodulename
        AND eventtype = :zoomeventtype
        AND timemodified >= :onehourago
        AND timemodified <= :tenminutesago';

        return $DB->get_records_sql($sql, [
            'zoommodulename' => 'zoom',
            'zoomeventtype' => 'zoom',
            'onehourago' => time() - (60 * 60),
            'tenminutesago' => time() - (60 * 10),
        ]);
    }

    /**
     * Get the notification time (last successful ical notifications sent) for the related zoom event id.
     * @param int $zoomeventid The zoom event id.
     * @return int The timestamp of the last notification sent.
     */
    private function get_notification_time(int $zoomeventid) {
        global $DB;

        $notificationtime = $DB->get_field('zoom_ical_notifications', 'notificationtime', ['zoomeventid' => $zoomeventid]);
        if (!$notificationtime) {
            $notificationtime = 0;
        }
        return (int) $notificationtime;
    }

    /**
     * Set the notification time (the current time) for successful ical notifications sent for the related zoom event id.
     * @param int $zoomeventid The zoom event id.
     */
    private function set_notification_time(int $zoomeventid) {
        global $DB;

        $icalnotifojb = new stdClass();
        $icalnotifojb->zoomeventid = $zoomeventid;
        $icalnotifojb->notificationtime = time();

        $DB->insert_record('zoom_ical_notifications', $icalnotifojb);
    }

    /**
     * The zoom ical notification task.
     * @param stdClass $zoomevent The zoom event record.
     */
    private function send_zoom_ical_notifications(stdClass $zoomevent) {
        global $DB, $CFG;

        $users = $this->get_users_to_notify((int) $zoomevent->instance, (int) $zoomevent->courseid);

        $zoom = $DB->get_record('zoom', ['id' => $zoomevent->instance], 'id,registration,join_url,meeting_id,webinar');

        $filestorage = get_file_storage();

        // Apply filters to event name and description.
        $cminfo = get_coursemodule_from_instance('zoom', (int) $zoomevent->instance, (int) $zoomevent->courseid);
        $formatoptions = [];
        if ($cminfo && !empty($cminfo->id)) {
            $formatoptions['context'] = context_module::instance($cminfo->id);
        }
        $zoomeventname = zoom_apply_filter_on_meeting_name($zoomevent->name, $formatoptions);
        $zoomeventhtmldesc = format_text($zoomevent->description, FORMAT_HTML, $formatoptions);
        $zoomeventhtmldesc .= format_text(
            get_string(
                'meetingactivityurl',
                'mod_zoom',
                $CFG->wwwroot . '/mod/zoom/view.php?id=' . $cminfo->id
            ),
            FORMAT_HTML,
            $formatoptions
        );
        $zoomeventplaindesc = strip_tags($zoomevent->description);

        // Setup zoom event url.
        $zoomurlwrapper = new moodle_url('/mod/zoom/view.php', ['id' => $cminfo->id]);
        $zoomurl = $zoomurlwrapper->out(false);

        foreach ($users as $user) {
            // Check if user has "Disable notifications" set.
            if ($user->emailstop) {
                continue;
            }

            $ical = $this->create_ical_object($zoomevent, $zoom, $zoomeventplaindesc, $zoomurl, $user->email);

            $filerecord = [
                'contextid' => context_user::instance($user->id)->id,
                'component' => 'user',
                'filearea' => 'draft',
                'itemid' => file_get_unused_draft_itemid(),
                'filepath' => '/',
                'filename' => clean_filename('icalexport.ics'),
            ];

            $serializedical = $ical->serialize();
            if (!$serializedical || empty($serializedical)) {
                mtrace('A problem occurred while trying to serialize the ical data for user ID ' .
                        $user->id . ' for zoom event ID ' . $zoomevent->id);
                continue;
            }

            $icalfileattachment = $filestorage->create_file_from_string($filerecord, $serializedical);

            $messagedata = new message();
            $messagedata->component = 'mod_zoom';
            $messagedata->name = 'ical_notifications';
            $messagedata->userfrom = core_user::get_noreply_user();
            $messagedata->userto = $user;
            $messagedata->subject = $zoomeventname;
            $messagedata->fullmessage = $zoomeventhtmldesc;
            $messagedata->fullmessageformat = FORMAT_HTML;
            $messagedata->fullmessagehtml = $zoomeventhtmldesc;
            $messagedata->smallmessage = $zoomeventname . ' - ' . $zoomeventplaindesc;
            $messagedata->notification = true;
            $messagedata->attachment = $icalfileattachment;
            $messagedata->attachname = $icalfileattachment->get_filename();

            $emailsuccess = message_send($messagedata);

            if ($emailsuccess) {
                mtrace('Successfully emailed user ID ' . $user->id .
                        ' for zoom event ID ' . $zoomevent->id);
            } else {
                mtrace('A problem occurred while emailing user ID ' . $user->id .
                        ' for zoom event ID ' . $zoomevent->id);
            }
        }
    }

    /**
     * Create the ical object.
     * @param stdClass $zoomevent The zoom event record.
     * @param stdClass $zoom The zoom record.
     * @param string $zoomeventdescription The zoom event's plain (non-html) description.
     * @param string $zoomurl The un-escaped zoom event url.
     * @param string $email The user's email.
     * @return \iCalendar
     */
    private function create_ical_object(
        stdClass $zoomevent,
        stdClass $zoom,
        string $zoomeventdescription,
        string $zoomurl,
        string $email
    ) {
        global $CFG, $SITE;

        $ical = new \iCalendar();
        $ical->add_property('method', 'PUBLISH');
        $ical->add_property('prodid', '-//Moodle Pty Ltd//NONSGML Moodle Version ' . $CFG->version . '//EN');

        $icalevent = zoom_helper_icalendar_event($zoomevent, $zoomeventdescription);

        if ($zoom->registration == ZOOM_REGISTRATION_OFF) {
            $icalevent->add_property('location', $zoomurl);
        } else {
            $registrantjoinurl = zoom_get_registrant_join_url($email, $zoom->meeting_id, $zoom->webinar);
            if ($registrantjoinurl) {
                $icalevent->add_property('location', $registrantjoinurl);
            } else {
                $icalevent->add_property('location', $zoomurl);
            }
        }

        $noreplyuser = core_user::get_noreply_user();
        $icalevent->add_property('organizer', 'mailto:' . $noreplyuser->email, ['cn' => $SITE->fullname]);
        // Need to strip out the double quotations around the 'organizer' values - probably a bug in the core code.
        $organizervalue = $icalevent->properties['ORGANIZER'][0]->value;
        $icalevent->properties['ORGANIZER'][0]->value = substr($organizervalue, 1, -1);
        $organizercnparam = $icalevent->properties['ORGANIZER'][0]->parameters['CN'];
        $icalevent->properties['ORGANIZER'][0]->parameters['CN'] = substr($organizercnparam, 1, -1);

        // Add the event to the iCal file.
        $ical->add_component($icalevent);

        return $ical;
    }

    /**
     * Get an array of users in the format of userid=>user object.
     * @param int $zoomid The zoom instance id.
     * @param int $courseid The course id of the course in which the zoom event occurred.
     * @return array An array of users.
     */
    private function get_users_to_notify(int $zoomid, int $courseid) {
        $cminfo = get_fast_modinfo($courseid)->instances['zoom'][$zoomid];
        $users = get_users_by_capability($cminfo->context, 'mod/zoom:view');

        if (empty($users)) {
            return [];
        }

        $info = new info_module($cminfo);
        return $info->filter_user_list($users);
    }

    /**
     * Returns the name of the task.
     *
     * @return string task name.
     */
    public function get_name() {
        return get_string('sendicalnotifications', 'mod_zoom');
    }
}

====================

file: update_tracking_fields.php
path: classes/task/update_tracking_fields.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Scheduled task for updating Zoom tracking fields
 *
 * @package    mod_zoom
 * @copyright  2021 Michelle Melton <meltonml@appstate.edu>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\task;

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot . '/mod/zoom/lib.php');
require_once($CFG->dirroot . '/mod/zoom/locallib.php');

use core\task\scheduled_task;
use moodle_exception;

/**
 * Scheduled task to sychronize tracking field data.
 */
class update_tracking_fields extends scheduled_task {
    /**
     * Returns name of task.
     *
     * @return string
     */
    public function get_name() {
        return get_string('updatetrackingfields', 'mod_zoom');
    }

    /**
     * Updates tracking fields.
     *
     * @return boolean
     */
    public function execute() {
        try {
            $service = zoom_webservice();
        } catch (moodle_exception $exception) {
            mtrace('Skipping task - ', $exception->getMessage());
            return;
        }

        // Required scopes for tracking fields.
        $requiredscopes = [
            'classic' => [
                'tracking_fields:read:admin',
            ],
            'granular' => [
                'tracking_field:read:list_tracking_fields:admin',
            ],
        ];

        // Checking for missing scopes.
        $missingscopes = $service->check_scopes($requiredscopes);
        if (!empty($missingscopes)) {
            foreach ($missingscopes as $missingscope) {
                mtrace('Missing scope: ' . $missingscope);
            }
            return;
        }

        // Show trace message.
        mtrace('Starting to process existing Zoom tracking fields ...');

        if (!mod_zoom_update_tracking_fields()) {
            mtrace('Error: Failed to update tracking fields.');
        }

        // Show trace message.
        mtrace('Finished processing existing Zoom tracking fields');

        return true;
    }
}

====================

file: get_meeting_reports.php
path: classes/task/get_meeting_reports.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Task: get_meeting_reports
 *
 * @package    mod_zoom
 * @copyright  2018 UC Regents
 * @author     Kubilay Agi
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\task;

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot . '/mod/zoom/locallib.php');

use context_course;
use core\message\message;
use core\task\scheduled_task;
use core_user;
use dml_exception;
use Exception;
use html_writer;
use mod_zoom\not_found_exception;
use mod_zoom\retry_failed_exception;
use mod_zoom\webservice_exception;
use moodle_exception;
use moodle_url;
use stdClass;

/**
 * Scheduled task to get the meeting participants for each .
 */
class get_meeting_reports extends scheduled_task {
    /**
     * Percentage in which we want similar_text to reach before we consider
     * using its results.
     */
    private const SIMILARNAME_THRESHOLD = 60;

    /**
     * Used to determine if debugging is turned on or off for outputting messages.
     * @var bool
     */
    public $debuggingenabled = false;

    /**
     * The mod_zoom\webservice instance used to query for data. Can be stubbed
     * for unit testing.
     * @var mod_zoom\webservice
     */
    public $service = null;

    /**
     * Sort meetings by end time.
     * @param array $a One meeting/webinar object array to compare.
     * @param array $b Another meeting/webinar object array to compare.
     */
    private function cmp($a, $b) {
        if ($a->end_time == $b->end_time) {
            return 0;
        }

        return ($a->end_time < $b->end_time) ? -1 : 1;
    }

    /**
     * Gets the meeting IDs from the queue, retrieve the information for each
     * meeting, then remove the meeting from the queue.
     *
     * @param string $paramstart    If passed, will find meetings starting on given date. Format is YYYY-MM-DD.
     * @param string $paramend      If passed, will find meetings ending on given date. Format is YYYY-MM-DD.
     * @param array $hostuuids      If passed, will find only meetings for given array of host uuids.
     */
    public function execute($paramstart = null, $paramend = null, $hostuuids = null) {
        try {
            $this->service = zoom_webservice();
        } catch (moodle_exception $exception) {
            mtrace('Skipping task - ', $exception->getMessage());
            return;
        }

        // See if we cannot make anymore API calls.
        $retryafter = get_config('zoom', 'retry-after');
        if (!empty($retryafter) && time() < $retryafter) {
            mtrace('Out of API calls, retry after ' . userdate($retryafter, get_string('strftimedaydatetime', 'core_langconfig')));
            return;
        }

        $this->debuggingenabled = debugging();

        // If running as a task, then record when we last left off if
        // interrupted or finish.
        $runningastask = true;

        if (!empty($hostuuids)) {
            $runningastask = false;
        }

        if (!empty($paramstart)) {
            $starttime = strtotime($paramstart);
            $runningastask = false;
        } else {
            $starttime = get_config('zoom', 'last_call_made_at');
        }

        if (empty($starttime)) {
            // Zoom only provides data from 30 days ago.
            $starttime = strtotime('-30 days');
        }

        if (!empty($paramend)) {
            $endtime = strtotime($paramend);
            $runningastask = false;
        }

        if (empty($endtime)) {
            $endtime = time();
        }

        // Zoom requires this format when passing the to and from arguments.
        // Zoom just returns all the meetings from the day range instead of
        // actual time range specified.
        $start = gmdate('Y-m-d', $starttime);
        $end = gmdate('Y-m-d', $endtime);

        mtrace(sprintf('Finding meetings between %s to %s', $start, $end));

        $recordedallmeetings = true;

        $dashboardscopes = [
            'dashboard_meetings:read:admin',
            'dashboard_webinars:read:admin',
            'dashboard:read:list_meetings:admin',
            'dashboard:read:list_webinars:admin',
        ];

        $reportscopes = [
            'report:read:admin',
            'report:read:list_users:admin',
        ];

        // Can only query on $hostuuids using Report API.
        if (empty($hostuuids) && $this->service->has_scope($dashboardscopes)) {
            $allmeetings = $this->get_meetings_via_dashboard($start, $end);
        } else if ($this->service->has_scope($reportscopes)) {
            $allmeetings = $this->get_meetings_via_reports($start, $end, $hostuuids);
        } else {
            mtrace('Skipping task - missing OAuth scopes required for reports');
            return;
        }

        // Sort all meetings based on end_time so that we know where to pick
        // up again if we run out of API calls.
        $allmeetings = array_map([$this, 'normalize_meeting'], $allmeetings);
        usort($allmeetings, [$this, 'cmp']);

        mtrace("Processing " . count($allmeetings) . " meetings");

        foreach ($allmeetings as $meeting) {
            // Only process meetings if they happened after the time we left off.
            $meetingtime = ($meeting->end_time == intval($meeting->end_time)) ? $meeting->end_time : strtotime($meeting->end_time);
            if ($runningastask && $meetingtime <= $starttime) {
                continue;
            }

            try {
                if (!$this->process_meeting_reports($meeting)) {
                    // If returned false, then ran out of API calls or got
                    // unrecoverable error. Try to pick up where we left off.
                    if ($runningastask) {
                        // Only want to resume if we were processing all reports.
                        $recordedallmeetings = false;
                        set_config('last_call_made_at', $meetingtime - 1, 'zoom');
                    }

                    break;
                }
            } catch (Exception $e) {
                mtrace($e->getMessage());
                mtrace($e->getTraceAsString());
                // Some unknown error, need to handle it so we can record
                // where we left off.
                if ($runningastask) {
                    $recordedallmeetings = false;
                    set_config('last_call_made_at', $meetingtime - 1, 'zoom');
                    break;
                }
            }
        }

        if ($recordedallmeetings && $runningastask) {
            // All finished, so save the time that we set end time for the initial query.
            set_config('last_call_made_at', $endtime, 'zoom');
        }
    }

    /**
     * Formats participants array as a record for the database.
     *
     * @param stdClass $participant Unformatted array received from web service API call.
     * @param int $detailsid The id to link to the zoom_meeting_details table.
     * @param array $names Array that contains mappings of user's moodle ID to the user's name.
     * @param array $emails Array that contains mappings of user's moodle ID to the user's email.
     * @return array Formatted array that is ready to be inserted into the database table.
     */
    public function format_participant($participant, $detailsid, $names, $emails) {
        global $DB;
        $moodleuser = null;
        $moodleuserid = null;
        $name = null;

        // Consolidate fields.
        $participant->name = $participant->name ?? $participant->user_name ?? '';
        $participant->id = $participant->id ?? $participant->participant_user_id ?? '';
        $participant->user_email = $participant->user_email ?? $participant->email ?? '';

        // Cleanup the name. For some reason # gets into the name instead of a comma.
        $participant->name = str_replace('#', ',', $participant->name);

        // Extract the ID and name from the participant's name if it is in the format "(id)Name".
        if (preg_match('/^\((\d+)\)(.+)$/', $participant->name, $matches)) {
            $moodleuserid = $matches[1];
            $name = trim($matches[2]);
        } else {
            $name = $participant->name;
        }

        // Try to see if we successfully queried for this user and found a Moodle id before.
        if (!empty($participant->id)) {
            // Sometimes uuid is blank from Zoom.
            $participantmatches = $DB->get_records(
                'zoom_meeting_participants',
                ['uuid' => $participant->id],
                null,
                'id, userid, name'
            );

            if (!empty($participantmatches)) {
                // Found some previous matches. Find first one with userid set.
                foreach ($participantmatches as $participantmatch) {
                    if (!empty($participantmatch->userid)) {
                        $moodleuserid = $participantmatch->userid;
                        $name = $participantmatch->name;
                        break;
                    }
                }
            }
        }

        // Did not find a previous match.
        if (empty($moodleuserid)) {
            if (!empty($participant->user_email) && ($moodleuserid = array_search(strtoupper($participant->user_email), $emails))) {
                // Found email from list of enrolled users.
                $name = $names[$moodleuserid];
            } else if (!empty($participant->name) && ($moodleuserid = array_search(strtoupper($participant->name), $names))) {
                // Found name from list of enrolled users.
                $name = $names[$moodleuserid];
            } else if (
                !empty($participant->user_email)
                && ($moodleuser = $DB->get_record('user', [
                    'email' => $participant->user_email,
                    'deleted' => 0,
                    'suspended' => 0,
                ], '*', IGNORE_MULTIPLE))
            ) {
                // This is the case where someone attends the meeting, but is not enrolled in the class.
                $moodleuserid = $moodleuser->id;
                $name = strtoupper(fullname($moodleuser));
            } else if (!empty($participant->name) && ($moodleuserid = $this->match_name($participant->name, $names))) {
                // Found name by using fuzzy text search.
                $name = $names[$moodleuserid];
            } else {
                // Did not find any matches, so use what is given by Zoom.
                $name = $participant->name;
                $moodleuserid = null;
            }
        }

        if ($participant->user_email === '') {
            if (!empty($moodleuserid)) {
                $participant->user_email = $DB->get_field('user', 'email', ['id' => $moodleuserid]);
            } else {
                $participant->user_email = null;
            }
        }

        if ($participant->id === '') {
            $participant->id = null;
        }

        return [
            'name' => $name,
            'userid' => $moodleuserid,
            'detailsid' => $detailsid,
            'zoomuserid' => $participant->user_id,
            'uuid' => $participant->id,
            'user_email' => $participant->user_email,
            'join_time' => strtotime($participant->join_time),
            'leave_time' => strtotime($participant->leave_time),
            'duration' => $participant->duration,
        ];
    }

    /**
     * Get enrollment for given course.
     *
     * @param int $courseid
     * @return array    Returns an array of names and emails.
     */
    public function get_enrollments($courseid) {
        // Loop through each user to generate name->uids mapping.
        $coursecontext = context_course::instance($courseid);
        $enrolled = get_enrolled_users($coursecontext);
        $names = [];
        $emails = [];
        foreach ($enrolled as $user) {
            $name = strtoupper(fullname($user));
            $names[$user->id] = $name;
            $emails[$user->id] = strtoupper(zoom_get_api_identifier($user));
        }

        return [$names, $emails];
    }

    /**
     * Get meetings first by querying for active hostuuids for given time
     * period. Then find meetings that host have given in given time period.
     *
     * This is the older method of querying for meetings. It has been superseded
     * by the Dashboard API. However, that API is only available for Business
     * accounts and higher. The Reports API is available for Pro user and up.
     *
     * This method is kept for those users that have Pro accounts and using
     * this plugin.
     *
     * @param string $start    If passed, will find meetings starting on given date. Format is YYYY-MM-DD.
     * @param string $end      If passed, will find meetings ending on given date. Format is YYYY-MM-DD.
     * @param array $hostuuids If passed, will find only meetings for given array of host uuids.
     *
     * @return array
     */
    public function get_meetings_via_reports($start, $end, $hostuuids) {
        global $DB;
        mtrace('Using Reports API');
        if (empty($hostuuids)) {
            $this->debugmsg('Empty hostuuids, querying all hosts');
            // Get all hosts.
            $activehostsuuids = $this->service->get_active_hosts_uuids($start, $end);
        } else {
            $this->debugmsg('Hostuuids passed');
            // Else we just want a specific hosts.
            $activehostsuuids = $hostuuids;
        }

        $allmeetings = [];
        $localhosts = $DB->get_records_menu('zoom', null, '', 'id, host_id');

        mtrace("Processing " . count($activehostsuuids) . " active host uuids");

        foreach ($activehostsuuids as $activehostsuuid) {
            // This API call returns information about meetings and webinars,
            // don't need extra functionality for webinars.
            $usersmeetings = [];
            if (in_array($activehostsuuid, $localhosts)) {
                $this->debugmsg('Getting meetings for host uuid ' . $activehostsuuid);
                try {
                    $usersmeetings = $this->service->get_user_report($activehostsuuid, $start, $end);
                } catch (not_found_exception $e) {
                    // Zoom API returned user not found for a user it said had,
                    // meetings. Have to skip user.
                    $this->debugmsg("Skipping $activehostsuuid because user does not exist on Zoom");
                    continue;
                } catch (retry_failed_exception $e) {
                    // Hit API limit, so cannot continue.
                    mtrace($e->response . ': ' . $e->zoomerrorcode);
                    return;
                }
            } else {
                // Ignore hosts who hosted meetings outside of integration.
                continue;
            }

            $this->debugmsg(sprintf('Found %d meetings for user', count($usersmeetings)));
            foreach ($usersmeetings as $usermeeting) {
                $allmeetings[] = $usermeeting;
            }
        }

        return $allmeetings;
    }

    /**
     * Get meetings and webinars using Dashboard API.
     *
     * @param string $start    If passed, will find meetings starting on given date. Format is YYYY-MM-DD.
     * @param string $end      If passed, will find meetings ending on given date. Format is YYYY-MM-DD.
     *
     * @return array
     */
    public function get_meetings_via_dashboard($start, $end) {
        mtrace('Using Dashboard API');

        $meetingscopes = [
            'dashboard_meetings:read:admin',
            'dashboard:read:list_meetings:admin',
        ];

        $webinarscopes = [
            'dashboard_webinars:read:admin',
            'dashboard:read:list_webinars:admin',
        ];

        $meetings = [];
        if ($this->service->has_scope($meetingscopes)) {
            $meetings = $this->service->get_meetings($start, $end);
        }

        $webinars = [];
        if ($this->service->has_scope($webinarscopes)) {
            $webinars = $this->service->get_webinars($start, $end);
        }

        $allmeetings = array_merge($meetings, $webinars);

        return $allmeetings;
    }

    /**
     * Returns name of task.
     *
     * @return string
     */
    public function get_name() {
        return get_string('getmeetingreports', 'mod_zoom');
    }

    /**
     * Tries to match a given name to the roster using two different fuzzy text
     * matching algorithms and if they match, then returns the match.
     *
     * @param string $nametomatch
     * @param array $rosternames    Needs to be an array larger than 3 for any
     *                              meaningful results.
     *
     * @return int  Returns id for $rosternames. Returns false if no match found.
     */
    private function match_name($nametomatch, $rosternames) {
        if (count($rosternames) < 3) {
            return false;
        }

        $nametomatch = strtoupper($nametomatch);
        $similartextscores = [];
        $levenshteinscores = [];
        foreach ($rosternames as $name) {
            similar_text($nametomatch, $name, $percentage);
            if ($percentage > self::SIMILARNAME_THRESHOLD) {
                $similartextscores[$name] = $percentage;
                $levenshteinscores[$name] = levenshtein($nametomatch, $name);
            }
        }

        // If we did not find any quality matches, then return false.
        if (empty($similartextscores)) {
            return false;
        }

        // Simlar text has better matches with higher numbers.
        arsort($similartextscores);
        reset($similartextscores);  // Make sure key gets first element.
        $stmatch = key($similartextscores);

        // Levenshtein has better matches with lower numbers.
        asort($levenshteinscores);
        reset($levenshteinscores);  // Make sure key gets first element.
        $lmatch = key($levenshteinscores);

        // If both matches, then we can be rather sure that it is the same user.
        if ($stmatch == $lmatch) {
            $moodleuserid = array_search($stmatch, $rosternames);
            return $moodleuserid;
        } else {
            return false;
        }
    }

    /**
     * Outputs finer grained debugging messaging if debug mode is on.
     *
     * @param string $msg
     */
    public function debugmsg($msg) {
        if ($this->debuggingenabled) {
            mtrace($msg);
        }
    }

    /**
     * Saves meeting details and participants for reporting.
     *
     * @param object $meeting    Normalized meeting object
     * @return boolean
     */
    public function process_meeting_reports($meeting) {
        global $DB;

        $this->debugmsg(sprintf(
            'Processing meeting %s|%s that occurred at %s',
            $meeting->meeting_id,
            $meeting->uuid,
            $meeting->start_time
        ));

        // If meeting doesn't exist in the zoom database, the instance is
        // deleted, and we don't need reports for these.
        if (!($zoomrecord = $DB->get_record('zoom', ['meeting_id' => $meeting->meeting_id], '*', IGNORE_MULTIPLE))) {
            mtrace('Meeting does not exist locally; skipping');
            return true;
        }

        $meeting->zoomid = $zoomrecord->id;
        // Insert or update meeting details.
        if (!($DB->record_exists('zoom_meeting_details', ['uuid' => $meeting->uuid]))) {
            $this->debugmsg('Inserting zoom_meeting_details');
	    $detailsid = $DB->insert_record('zoom_meeting_details', $meeting);
	} else {
            // Details entry already exists, so update it.
            $this->debugmsg('Updating zoom_meeting_details');
            $detailsid = $DB->get_field('zoom_meeting_details', 'id', ['uuid' => $meeting->uuid]);
            $meeting->id = $detailsid;
            $DB->update_record('zoom_meeting_details', $meeting);
        }

        try {
            $participants = $this->service->get_meeting_participants($meeting->uuid, $zoomrecord->webinar);
        } catch (not_found_exception $e) {
            mtrace(sprintf('Warning: Cannot find meeting %s|%s; skipping', $meeting->meeting_id, $meeting->uuid));
            return true;    // Not really a show stopping error.
        } catch (webservice_exception $e) {
            mtrace($e->response . ': ' . $e->zoomerrorcode);
            return false;
        }

        // Loop through each user to generate name->uids mapping.
        [$names, $emails] = $this->get_enrollments($zoomrecord->course);

        $this->debugmsg(sprintf('Processing %d participants', count($participants)));

        // Now try to insert new participant records.
        // There is no unique key, so we make sure each record's data is distinct.
        try {
            $transaction = $DB->start_delegated_transaction();

            $count = $DB->count_records('zoom_meeting_participants', ['detailsid' => $detailsid]);
            if (!empty($count)) {
                $this->debugmsg(sprintf('Existing participant records: %d', $count));
                // No need to delete old records, we don't insert matching records.
            }

            // To prevent sending notifications every time the task ran check if there is inserted new records.
            $recordupdated = false;
            foreach ($participants as $rawparticipant) {
                $this->debugmsg(sprintf(
                    'Working on %s (user_id: %d, uuid: %s)',
                    $rawparticipant->name,
                    $rawparticipant->user_id,
                    $rawparticipant->id
                ));
                $participant = $this->format_participant($rawparticipant, $detailsid, $names, $emails);

                // These conditions are enough.
                $conditions = [
                    'name' => $participant['name'],
                    'userid' => $participant['userid'],
                    'detailsid' => $participant['detailsid'],
                    'zoomuserid' => $participant['zoomuserid'],
                    'join_time' => $participant['join_time'],
                    'leave_time' => $participant['leave_time'],
                ];

/* IVF CARLO 2025-10-21 modifica per effettuare un aggiornamento e non solo un nuovo insert
 * INIZIO Codice originale commentato
 
 		// Check if the record already exists.
                if ($record = $DB->get_record('zoom_meeting_participants', $conditions)) {
                    // The exact record already exists, so do nothing.
                    $this->debugmsg('Record already exists ' . $record->id);
                } else {
                    // Insert all new records.
		    $recordid = $DB->insert_record('zoom_meeting_participants', $participant, true);
                    // At least one new record inserted.
                    $recordupdated = true;
                    $this->debugmsg('Inserted record ' . $recordid);
		}
* FINE Codice originale commentato */
// INIZIO Codice modificato per fare upsert (update o insert)
		// Controlla se il record partecipante esiste gi con condizioni univoche (es. uuid, detailsid, join_time, leave_time)
if ($record = $DB->get_record('zoom_meeting_participants', $conditions)) {
    // Assicurarsi che sia coerente il tipo di dato e assegnare id a $participant
    if (is_array($record)) {
        if (is_array($participant)) {
            $participant['id'] = $record['id'];
        } else {
            $participant->id = $record['id'];
        }
    } else {
        if (is_array($participant)) {
            $participant['id'] = $record->id;
        } else {
            $participant->id = $record->id;
        }
    }
    try {
        $DB->update_record('zoom_meeting_participants', $participant);
        $this->debugmsg('Updated record ' . (is_array($record) ? $record['id'] : $record->id));
    } catch (dml_exception $e) {
        mtrace('ERRORE update partecipante: ' . $e->getMessage());
    }
} else {
    try {
        $recordid = $DB->insert_record('zoom_meeting_participants', $participant, true);
        $this->debugmsg('Inserted record ' . $recordid);
    } catch (dml_exception $e) {
        mtrace('ERRORE insert partecipante: ' . $e->getMessage());
    }
}
// FINE Codice modificato		
	    }


            // If there are new records and the grading method is attendance duration.
            // Check the grading method settings.
            if (!empty($zoomrecord->grading_method)) {
                $gradingmethod = $zoomrecord->grading_method;
            } else if ($defaultgrading = get_config('gradingmethod', 'zoom')) {
                $gradingmethod = $defaultgrading;
            } else {
                $gradingmethod = 'entry';
            }

            if ($recordupdated && $gradingmethod === 'period') {
                // Grade users according to their duration in the meeting.
                $this->grading_participant_upon_duration($zoomrecord, $detailsid);
            }

            $transaction->allow_commit();
        } catch (dml_exception $exception) {
            $transaction->rollback($exception);
            mtrace('ERROR: Cannot insert zoom_meeting_participants: ' . $exception->getMessage());
            return false;
        }

        $this->debugmsg('Finished updating meeting report');
        return true;
    }

    /**
     * Update the grades of users according to their duration in the meeting.
     * @param object $zoomrecord
     * @param int $detailsid
     * @return void
     */
    public function grading_participant_upon_duration($zoomrecord, $detailsid) {
        global $CFG, $DB;

        require_once($CFG->libdir . '/gradelib.php');
        $courseid = $zoomrecord->course;
        $context = context_course::instance($courseid);
        // Get grade list for items.
        $gradelist = grade_get_grades($courseid, 'mod', 'zoom', $zoomrecord->id);

        // Is this meeting is not gradable, return.
        if (empty($gradelist->items)) {
            return;
        }

        $gradeitem = $gradelist->items[0];
        $itemid = $gradeitem->id;
        $grademax = $gradeitem->grademax;
        $oldgrades = $gradeitem->grades;

        // After check and testing, these timings are the actual meeting timings returned from zoom
        // ... (i.e.when the host start and end the meeting).
        // Not like those on 'zoom' table which represent the settings from zoom activity.
        $meetingtime = $DB->get_record('zoom_meeting_details', ['id' => $detailsid], 'start_time, end_time');
        if (empty($zoomrecord->recurring)) {
            $end = min($meetingtime->end_time, $zoomrecord->start_time + $zoomrecord->duration);
            $start = max($meetingtime->start_time, $zoomrecord->start_time);
            $meetingduration = $end - $start;
        } else {
            $meetingduration = $meetingtime->end_time - $meetingtime->start_time;
        }

        // Get the required records again.
        $records = $DB->get_records('zoom_meeting_participants', ['detailsid' => $detailsid], 'join_time ASC');
        // Initialize the data arrays, indexing them later with userids.
        $durations = [];
        $join = [];
        $leave = [];
        // Looping the data to calculate the duration of each user.
        foreach ($records as $record) {
            $userid = $record->userid;
            if (empty($userid)) {
                if (is_numeric($record->name)) {
                    // In case the participant name looks like an integer, we need to avoid a conflict.
                    $userid = '~' . $record->name . '~';
                } else {
                    $userid = $record->name;
                }
            }

            // Check if there is old duration stored for this user.
            if (!empty($durations[$userid])) {
                $old = new stdClass();
                $old->duration = $durations[$userid];
                $old->join_time = $join[$userid];
                $old->leave_time = $leave[$userid];
                // Calculating the overlap time.
                $overlap = $this->get_participant_overlap_time($old, $record);

                // Set the new data for next use.
                $leave[$userid] = max($old->leave_time, $record->leave_time);
                $join[$userid] = min($old->join_time, $record->join_time);
                $durations[$userid] = $old->duration + $record->duration - $overlap;
            } else {
                $leave[$userid] = $record->leave_time;
                $join[$userid] = $record->join_time;
                $durations[$userid] = $record->duration;
            }
        }

        // Used to count the number of users being graded.
        $graded = 0;
        $alreadygraded = 0;

        // Array of unidentified users that need to be graded manually.
        $needgrade = [];

        // Array of found user ids.
        $found = [];

        // Array of non-enrolled users.
        $notenrolled = [];

        // Now check the duration for each user and grade them according to it.
        foreach ($durations as $userid => $userduration) {
            // Setup the grade according to the duration.
            $newgrade = min($userduration * $grademax / $meetingduration, $grademax);

            // Double check that this is a Moodle user.
            if (is_integer($userid) && (isset($found[$userid]) || $DB->record_exists('user', ['id' => $userid]))) {
                // Successfully found this user in Moodle.
                if (!isset($found[$userid])) {
                    $found[$userid] = true;
                }

                $oldgrade = null;
                if (isset($oldgrades[$userid])) {
                    $oldgrade = $oldgrades[$userid]->grade;
                }

                // Check if the user is enrolled before assign the grade.
                if (is_enrolled($context, $userid)) {
                    // Compare with the old grade and only update if the new grade is higher.
                    // Use number_format because the old stored grade only contains 5 decimals.
                    if (empty($oldgrade) || $oldgrade < number_format($newgrade, 5)) {
                        $gradegrade = [
                            'rawgrade' => $newgrade,
                            'userid' => $userid,
                            'usermodified' => $userid,
                            'dategraded' => '',
                            'feedbackformat' => '',
                            'feedback' => '',
                        ];

                        zoom_grade_item_update($zoomrecord, $gradegrade);
                        $graded++;
                        $this->debugmsg('grade updated for user with id: ' . $userid
                                        . ', duration =' . $userduration
                                        . ', maxgrade =' . $grademax
                                        . ', meeting duration =' . $meetingduration
                                        . ', User grade:' . $newgrade);
                    } else {
                        $alreadygraded++;
                        $this->debugmsg('User already has a higher grade. Old grade: ' . $oldgrade
                                        . ', New grade: ' . $newgrade);
                    }
                } else {
                    $notenrolled[$userid] = fullname(core_user::get_user($userid));
                }
            } else {
                // This means that this user was not identified.
                // Provide information about participants that need to be graded manually.
                $a = [
                    'userid' => $userid,
                    'grade' => $newgrade,
                ];
                $needgrade[] = get_string('nonrecognizedusergrade', 'mod_zoom', $a);
            }
        }

        // Get the list of users who clicked join meeting and were not recognized by the participant report.
        $allusers = $this->get_users_clicked_join($zoomrecord);
        $notfound = [];
        foreach ($allusers as $userid) {
            if (!isset($found[$userid])) {
                $notfound[$userid] = fullname(core_user::get_user($userid));
            }
        }

        // Try not to spam the instructors, only notify them when grades have changed.
        if ($graded > 0) {
            // Sending a notification to teachers in this course about grades, and users that need to be graded manually.
            $notifydata = [
                'graded' => $graded,
                'alreadygraded' => $alreadygraded,
                'needgrade' => $needgrade,
                'courseid' => $courseid,
                'zoomid' => $zoomrecord->id,
                'itemid' => $itemid,
                'name' => $zoomrecord->name,
                'notfound' => $notfound,
                'notenrolled' => $notenrolled,
            ];
            $this->notify_teachers($notifydata);
        }
    }

    /**
     * Calculate the overlap time for a participant.
     *
     * @param object $record1 Record data 1.
     * @param object $record2 Record data 2.
     * @return int the overlap time
     */
    public function get_participant_overlap_time($record1, $record2) {
        // Determine which record starts first.
        if ($record1->join_time < $record2->join_time) {
            $old = $record1;
            $new = $record2;
        } else {
            $old = $record2;
            $new = $record1;
        }

        $oldjoin = (int) $old->join_time;
        $oldleave = (int) $old->leave_time;
        $newjoin = (int) $new->join_time;
        $newleave = (int) $new->leave_time;

        // There are three possible cases.
        if ($newjoin >= $oldleave) {
            // First case - No overlap.
            // Example: old(join: 15:00 leave: 15:30), new(join: 15:35 leave: 15:50).
            // No overlap.
            $overlap = 0;
        } else if ($newleave > $oldleave) {
            // Second case - Partial overlap.
            // Example: new(join: 15:15 leave: 15:45), old(join: 15:00 leave: 15:30).
            // 15 min overlap.
            $overlap = $oldleave - $newjoin;
        } else {
            // Third case - Complete overlap.
            // Example:  new(join: 15:15 leave: 15:29), old(join: 15:00 leave: 15:30).
            // 14 min overlap (new duration).
            $overlap = $new->duration;
        }

        return $overlap;
    }

    /**
     * Sending a notification to all teachers in the course notify them about grading
     * also send the names of the users needing a manual grading.
     * return array of messages ids and false if there is no users in this course
     * with the capability of edit grades.
     *
     * @param array $data
     * @return array|bool
     */
    public function notify_teachers($data) {
        // Number of users graded automatically.
        $graded = $data['graded'];
        // Number of users already graded.
        $alreadygraded = $data['alreadygraded'];
        // Number of users need to be graded.
        $needgradenumber = count($data['needgrade']);
        // List of users need grading.
        $needstring = get_string('grading_needgrade', 'mod_zoom');
        $needgrade = (!empty($data['needgrade'])) ? $needstring . implode('<br>', $data['needgrade']) . "\n" : '';

        $zoomid = $data['zoomid'];
        $itemid = $data['itemid'];
        $name = $data['name'];
        $courseid = $data['courseid'];
        $context = context_course::instance($courseid);
        // Get teachers in the course (actually those with the ability to edit grades).
        $teachers = get_enrolled_users($context, 'moodle/grade:edit', 0, 'u.*', null, 0, 0, true);

        // Grading item url.
        $gurl = new moodle_url(
            '/grade/report/singleview/index.php',
            [
                'id' => $courseid,
                'item' => 'grade',
                'itemid' => $itemid,
            ]
        );
        $gradeurl = html_writer::link($gurl, get_string('gradinglink', 'mod_zoom'));

        // Zoom instance url.
        $zurl = new moodle_url('/mod/zoom/view.php', ['id' => $zoomid]);
        $zoomurl = html_writer::link($zurl, $name);

        // Data object used in lang strings.
        $a = (object) [
            'name' => $name,
            'graded' => $graded,
            'alreadygraded' => $alreadygraded,
            'needgrade' => $needgrade,
            'number' => $needgradenumber,
            'gradeurl' => $gradeurl,
            'zoomurl' => $zoomurl,
            'notfound' => '',
            'notenrolled' => '',
        ];
        // Get the list of users clicked join meeting but not graded or reconized.
        // This helps the teacher to grade them manually.
        $notfound = $data['notfound'];
        if (!empty($notfound)) {
            $a->notfound = get_string('grading_notfound', 'mod_zoom');
            foreach ($notfound as $userid => $fullname) {
                $params = ['item' => 'user', 'id' => $courseid, 'userid' => $userid];
                $url = new moodle_url('/grade/report/singleview/index.php', $params);
                $userurl = html_writer::link($url, $fullname . ' (' . $userid . ')');
                $a->notfound .= '<br> ' . $userurl;
            }
        }

        $notenrolled = $data['notenrolled'];
        if (!empty($notenrolled)) {
            $a->notenrolled = get_string('grading_notenrolled', 'mod_zoom');
            foreach ($notenrolled as $userid => $fullname) {
                $userurl = new moodle_url('/user/profile.php', ['id' => $userid]);
                $profile = html_writer::link($userurl, $fullname);
                $a->notenrolled .= '<br>' . $profile;
            }
        }

        // Prepare the message.
        $message = new message();
        $message->component = 'mod_zoom';
        $message->name = 'teacher_notification'; // The notification name from message.php.
        $message->userfrom = core_user::get_noreply_user();

        $message->subject = get_string('gradingmessagesubject', 'mod_zoom', $a);

        $messagebody = get_string('gradingmessagebody', 'mod_zoom', $a);
        $message->fullmessage = $messagebody;

        $message->fullmessageformat = FORMAT_MARKDOWN;
        $message->fullmessagehtml = "<p>$messagebody</p>";
        $message->smallmessage = get_string('gradingsmallmeassage', 'mod_zoom', $a);
        $message->notification = 1;
        $message->contexturl = $gurl; // This link redirect the teacher to the page of item's grades.
        $message->contexturlname = get_string('gradinglink', 'mod_zoom');
        // Email content.
        $content = ['*' => ['header' => $message->subject, 'footer' => '']];
        $message->set_additional_content('email', $content);
        $messageids = [];
        if (!empty($teachers)) {
            foreach ($teachers as $teacher) {
                $message->userto = $teacher;
                // Actually send the message for each teacher.
                $messageids[] = message_send($message);
            }
        } else {
            return false;
        }

        return $messageids;
    }

    /**
     * The meeting object from the Dashboard API differs from the Report API, so
     * normalize the meeting object to conform to what is expected it the
     * database.
     *
     * @param object $meeting
     * @return object   Normalized meeting object
     */
    public function normalize_meeting($meeting) {
        $normalizedmeeting = new stdClass();

        // Returned meeting object will not be using Zoom's id, because it is a
        // primary key in our own tables.
        $normalizedmeeting->meeting_id = $meeting->id;

        // Convert times to Unixtimestamps.
        $normalizedmeeting->start_time = strtotime($meeting->start_time);
        $normalizedmeeting->end_time = strtotime($meeting->end_time);

        // Copy values that are named the same.
        $normalizedmeeting->uuid = $meeting->uuid;
        $normalizedmeeting->topic = $meeting->topic;

        // Dashboard API has duration as H:M:S while report has it in seconds.
        $timeparts = explode(':', $meeting->duration);

        // Convert duration into seconds.
        if (count($timeparts) === 1) {
            // Time is already in seconds.
            $normalizedmeeting->duration = intval($meeting->duration);
        } else if (count($timeparts) === 2) {
            // Time is in MM:SS format.
            $normalizedmeeting->duration = 60 * $timeparts[0] + $timeparts[1];
        } else {
            // Time is in HH:MM:SS format.
            $normalizedmeeting->duration = 3600 * $timeparts[0] + 60 * $timeparts[1] + $timeparts[2];
        }

        // Copy values that are named differently.
        $normalizedmeeting->participants_count = $meeting->participants ?? $meeting->participants_count;

        // Dashboard API does not have total_minutes.
        $normalizedmeeting->total_minutes = $meeting->total_minutes ?? null;

        return $normalizedmeeting;
    }

    /**
     * Get list of all users clicked (join meeting) in a given zoom instance.
     * @param object $zoomrecord
     * @return array<int>
     */
    public function get_users_clicked_join($zoomrecord) {
        global $DB;
        $logmanager = get_log_manager();
        if (!$readers = $logmanager->get_readers('core\log\sql_reader')) {
            // Should be using 2.8, use old class.
            $readers = $logmanager->get_readers('core\log\sql_select_reader');
        }

        $reader = array_pop($readers);
        if ($reader === null) {
            return [];
        }

        $params = [
            'courseid' => $zoomrecord->course,
            'objectid' => $zoomrecord->id,
        ];
        $selectwhere = "eventname = '\\\\mod_zoom\\\\event\\\\join_meeting_button_clicked'
            AND courseid = :courseid
            AND objectid = :objectid";
        $events = $reader->get_events_select($selectwhere, $params, 'userid ASC', 0, 0);

        $userids = [];
        foreach ($events as $event) {
            if (
                $event->other['meetingid'] === $zoomrecord->meeting_id &&
                !in_array($event->userid, $userids, true)
            ) {
                $userids[] = $event->userid;
            }
        }

        return $userids;
    }
}

====================

file: update_meetings.php
path: classes/task/update_meetings.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Task: update_meetings
 *
 * @package    mod_zoom
 * @copyright  2018 UC Regents
 * @author     Rohan Khajuria
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom\task;

defined('MOODLE_INTERNAL') || die();

require_once($CFG->libdir . '/modinfolib.php');
require_once($CFG->dirroot . '/mod/zoom/lib.php');
require_once($CFG->dirroot . '/mod/zoom/locallib.php');

use core\task\scheduled_task;
use mod_zoom\not_found_exception;
use moodle_exception;
use moodle_url;

/**
 * Scheduled task to sychronize meeting data.
 */
class update_meetings extends scheduled_task {
    /**
     * Returns name of task.
     *
     * @return string
     */
    public function get_name() {
        return get_string('updatemeetings', 'mod_zoom');
    }

    /**
     * Updates meetings that are not expired.
     *
     * @return boolean
     */
    public function execute() {
        global $DB;

        try {
            $service = zoom_webservice();
        } catch (moodle_exception $exception) {
            mtrace('Skipping task - ', $exception->getMessage());
            return;
        }

        // Required scopes for reading meeting information.
        $requiredscopes = [
            'classic' => [
                'meeting:read:admin',
            ],
            'granular' => [
                'meeting:read:meeting:admin',
            ],
        ];

        // Checking for missing scopes.
        $missingmeetingscopes = $service->check_scopes($requiredscopes);
        foreach ($missingmeetingscopes as $missingscope) {
            mtrace('Missing scope: ' . $missingscope);
        }

        // Required scopes for reading webinar information.
        $requiredscopes = [
            'classic' => [
                'webinar:read:admin',
            ],
            'granular' => [
                'webinar:read:webinar:admin',
            ],
        ];

        // Checking for missing scopes.
        $missingwebinarscopes = $service->check_scopes($requiredscopes);
        foreach ($missingwebinarscopes as $missingscope) {
            mtrace('Missing scope: ' . $missingscope);
        }

        // Exit if we have neither meeting scopes nor webinar scopes.
        if (!empty($missingmeetingscopes) && !empty($missingwebinarscopes)) {
            return;
        }

        // Show trace message.
        mtrace('Starting to process existing Zoom meeting activities ...');

        // Check all meetings, in case they were deleted/changed on Zoom.
        $zoomstoupdate = $DB->get_records('zoom', ['exists_on_zoom' => ZOOM_MEETING_EXISTS]);
        $courseidstoupdate = [];
        $calendarfields = ['intro', 'introformat', 'start_time', 'duration', 'recurring'];

        foreach ($zoomstoupdate as $zoom) {
            // Show trace message.
            mtrace('Processing next Zoom meeting activity ...');
            mtrace('  Zoom meeting ID: ' . $zoom->meeting_id);
            mtrace('  Zoom meeting title: ' . $zoom->name);
            $zoomactivityurl = new moodle_url('/mod/zoom/view.php', ['n' => $zoom->id]);
            mtrace('  Zoom meeting activity URL: ' . $zoomactivityurl->out());
            mtrace('  Moodle course ID: ' . $zoom->course);

            $gotinfo = false;
            try {
                $response = $service->get_meeting_webinar_info($zoom->meeting_id, $zoom->webinar);
                $gotinfo = true;
            } catch (not_found_exception $error) {
                $zoom->exists_on_zoom = ZOOM_MEETING_EXPIRED;
                $DB->update_record('zoom', $zoom);

                // Show trace message.
                mtrace('  => Marked Zoom meeting activity for Zoom meeting ID ' . $zoom->meeting_id .
                        ' as not existing anymore on Zoom');
            } catch (moodle_exception $error) {
                // Show trace message.
                mtrace('  !! Error updating Zoom meeting activity for Zoom meeting ID ' . $zoom->meeting_id . ': ' . $error);
            }

            if ($gotinfo) {
                $changed = false;
                $newzoom = populate_zoom_from_response($zoom, $response);

                // Iterate over all Zoom meeting fields.
                foreach ((array) $zoom as $field => $value) {
                    // The start_url has a parameter that always changes, so it doesn't really count as a change.
                    // Similarly, the timemodified parameter does not count as change if nothing else has changed.
                    if ($field === 'start_url' || $field === 'timemodified') {
                        continue;
                    }

                    // For doing a better comparison and for easing mtrace() output, convert booleans from the Zoom response
                    // to strings like they are stored in the Moodle database for the existing activity.
                    $newfieldvalue = $newzoom->$field;
                    if (is_bool($newfieldvalue)) {
                        $newfieldvalue = $newfieldvalue ? '1' : '0';
                    }

                    // If the field value has changed.
                    if ($newfieldvalue != $value) {
                        // Show trace message.
                        mtrace('  => Field "' . $field . '" has changed from "' . $value . '" to "' . $newfieldvalue . '"');

                        // Remember this meeting as changed.
                        $changed = true;
                    }
                }

                if ($changed) {
                    $newzoom->timemodified = time();
                    $DB->update_record('zoom', $newzoom);

                    // Show trace message.
                    mtrace('  => Updated Zoom meeting activity for Zoom meeting ID ' . $zoom->meeting_id);

                    // If the topic/title was changed, mark this course for cache clearing.
                    if ($zoom->name != $newzoom->name) {
                        $courseidstoupdate[] = $newzoom->course;
                    }
                } else {
                    // Show trace message.
                    mtrace('  => Skipped Zoom meeting activity for Zoom meeting ID ' . $zoom->meeting_id . ' as unchanged');
                }

                // Update the calendar events.
                if (!$zoom->recurring && $changed) {
                    // Check if calendar needs updating.
                    foreach ($calendarfields as $field) {
                        if ($zoom->$field != $newzoom->$field) {
                            zoom_calendar_item_update($newzoom);

                            // Show trace message.
                            mtrace('  => Updated calendar item for Zoom meeting ID ' . $zoom->meeting_id);

                            break;
                        }
                    }
                } else if ($zoom->recurring) {
                    // Show trace message.
                    mtrace('  => Updated calendar items for recurring Zoom meeting ID ' . $zoom->meeting_id);
                    zoom_calendar_item_update($newzoom);
                }

                // Update tracking fields for meeting.
                mtrace('  => Updated tracking fields for Zoom meeting ID ' . $zoom->meeting_id);
                zoom_sync_meeting_tracking_fields($zoom->id, $response->tracking_fields ?? []);
            }
        }

        // Show trace message.
        mtrace('Finished to process existing Zoom meetings');

        // Show trace message.
        mtrace('Starting to rebuild course caches ...');

        // Clear caches for meetings whose topic/title changed (and rebuild as needed).
        foreach ($courseidstoupdate as $courseid) {
            rebuild_course_cache($courseid, true);
        }

        // Show trace message.
        mtrace('Finished to rebuild course caches');

        return true;
    }
}

====================

file: api_limit_exception.php
path: classes/api_limit_exception.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Exception class for Zoom API errors.
 *
 * @package   mod_zoom
 * @copyright 2023 Jonathan Champ <jrchamp@ncsu.edu>
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

use stdClass;

/**
 * Exceeded daily API limit.
 */
class api_limit_exception extends webservice_exception {
    /**
     * Unix timestamp of next time to API can be called.
     * @var int
     */
    public $retryafter = null;

    /**
     * Constructor
     * @param string $response  Web service response
     * @param int $errorcode    Web service response error code
     * @param int $retryafter   Unix timestamp of next time to API can be called.
     */
    public function __construct($response, $errorcode, $retryafter) {
        $this->retryafter = $retryafter;

        $a = new stdClass();
        $a->response = $response;
        parent::__construct(
            $response,
            $errorcode,
            'zoomerr_apilimit',
            'mod_zoom',
            '',
            userdate($retryafter, get_string('strftimedaydatetime', 'core_langconfig'))
        );
    }
}

====================

file: not_found_exception.php
path: classes/not_found_exception.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Exception class for Zoom API errors.
 *
 * @package   mod_zoom
 * @copyright 2023 Jonathan Champ <jrchamp@ncsu.edu>
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

/**
 * Entry not found on Zoom.
 */
class not_found_exception extends webservice_exception {
    /**
     * Constructor
     * @param string $response      Web service response message
     * @param int $errorcode     Web service response error code
     */
    public function __construct($response, $errorcode) {
        parent::__construct($response, $errorcode, 'errorwebservice_notfound', 'mod_zoom', '', $response);
    }
}

====================

file: recordings.php
path: recordings.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Adding, updating, and deleting zoom meeting recordings.
 *
 * @package    mod_zoom
 * @copyright  2020 UC Regents
 * @author     2021 Jwalit Shah <jwalitshah@catalyst-au.net>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

require(__DIR__ . '/../../config.php');
require_once(__DIR__ . '/lib.php');
require_once(__DIR__ . '/locallib.php');

[$course, $cm, $zoom] = zoom_get_instance_setup();

require_login($course, true, $cm);

if (!get_config('zoom', 'viewrecordings')) {
    throw new moodle_exception('recordingnotvisible', 'mod_zoom', get_string('recordingnotvisible', 'zoom'));
}

$context = context_module::instance($cm->id);
// Set up the page.
$params = ['id' => $cm->id];
$url = new moodle_url('/mod/zoom/recordings.php', $params);
$PAGE->set_url($url);

$strname = $zoom->name;
$PAGE->set_title("$course->shortname: $strname");
$PAGE->set_heading($course->fullname);
$PAGE->set_pagelayout('incourse');

echo $OUTPUT->header();
echo $OUTPUT->heading($strname);

$iszoommanager = has_capability('mod/zoom:addinstance', $context);

// Set up html table.
$table = new html_table();
$table->attributes['class'] = 'generaltable mod_view';
if ($iszoommanager) {
    $table->align = ['left', 'left', 'left', 'left'];
    $table->head = [
        get_string('recordingdate', 'mod_zoom'),
        get_string('recordinglink', 'mod_zoom'),
        get_string('recordingpasscode', 'mod_zoom'),
        get_string('recordingshowtoggle', 'mod_zoom'),
    ];
} else {
    $table->align = ['left', 'left', 'left'];
    $table->head = [
        get_string('recordingdate', 'mod_zoom'),
        get_string('recordinglink', 'mod_zoom'),
        get_string('recordingpasscode', 'mod_zoom'),
    ];
}

// Find all entries for this meeting in the database.
$recordings = zoom_get_meeting_recordings_grouped($zoom->id);
if (empty($recordings)) {
    $cell = new html_table_cell();
    $cell->colspan = count($table->head);
    $cell->text = get_string('norecordings', 'mod_zoom');
    $cell->style = 'text-align: center';
    $row = new html_table_row([$cell]);
    $table->data = [$row];
} else {
    foreach ($recordings as $grouping) {
        // Output the related recordings into the same row.
        $recordingdate = '';
        $recordinghtml = '';
        $recordingpasscode = '';
        $recordingshowhtml = '';
        foreach ($grouping as $recording) {
            // If zoom admin -> show all recordings.
            // Or if visible to students.
            if ($iszoommanager || intval($recording->showrecording) === 1) {
                if (empty($recordingdate)) {
                    $recordingdate = date('F j, Y, g:i:s a \P\T', $recording->recordingstart);
                }

                if (empty($recordingpasscode)) {
                    $recordingpasscode = $recording->passcode;
                }

                if ($iszoommanager && empty($recordingshowhtml)) {
                    $isrecordinghidden = intval($recording->showrecording) === 0;
                    $urlparams = [
                        'id' => $cm->id,
                        'meetinguuid' => $recording->meetinguuid,
                        'recordingstart' => $recording->recordingstart,
                        'showrecording' => ($isrecordinghidden) ? 1 : 0,
                        'sesskey' => sesskey(),
                    ];
                    // If the user is a zoom admin, show the button to toggle whether students can see the recording or not.
                    $recordingshowurl = new moodle_url('/mod/zoom/showrecording.php', $urlparams);
                    $recordingshowtext = get_string('recordinghide', 'mod_zoom');
                    if ($isrecordinghidden) {
                        $recordingshowtext = get_string('recordingshow', 'mod_zoom');
                    }

                    $btnclass = 'btn btn-';
                    $btnclass .= $isrecordinghidden ? 'dark' : 'primary';
                    $recordingshowbutton = html_writer::div($recordingshowtext, $btnclass);
                    $recordingshowbuttonhtml = html_writer::link($recordingshowurl, $recordingshowbutton);
                    $recordingshowhtml = html_writer::div($recordingshowbuttonhtml);
                }

                $recordingname = trim($recording->name) . ' (' . zoom_get_recording_type_string($recording->recordingtype) . ')';
                $params = ['id' => $cm->id, 'recordingid' => $recording->id];
                $recordingurl = new moodle_url('/mod/zoom/loadrecording.php', $params);
                $recordinglink = html_writer::link($recordingurl, $recordingname);
                $recordinglinkhtml = html_writer::span($recordinglink, 'recording-link', ['style' => 'margin-right:1rem']);
                $recordinghtml .= html_writer::div($recordinglinkhtml, 'recording', ['style' => 'margin-bottom:.5rem']);
            }
        }

        // Output only one row per grouping.
        $table->data[] = [$recordingdate, $recordinghtml, htmlspecialchars($recordingpasscode), $recordingshowhtml];
    }
}

/**
 * Get the display name for a Zoom recording type.
 *
 * @package mod_zoom
 * @param string $recordingtype Zoom recording type.
 * @return string
 */
function zoom_get_recording_type_string($recordingtype) {
    $recordingtypestringmap = [
        'active_speaker' => 'recordingtype_active_speaker',
        'audio_interpretation' => 'recordingtype_audio_interpretation',
        'audio_only' => 'recordingtype_audio_only',
        'audio_transcript' => 'recordingtype_audio_transcript',
        'chat_file' => 'recordingtype_chat',
        'closed_caption' => 'recordingtype_closed_caption',
        'gallery_view' => 'recordingtype_gallery',
        'poll' => 'recordingtype_poll',
        'production_studio' => 'recordingtype_production_studio',
        'shared_screen' => 'recordingtype_shared',
        'shared_screen_with_gallery_view' => 'recordingtype_shared_gallery',
        'shared_screen_with_speaker_view' => 'recordingtype_shared_speaker',
        'shared_screen_with_speaker_view(CC)' => 'recordingtype_shared_speaker_cc',
        'sign_interpretation' => 'recordingtype_sign',
        'speaker_view' => 'recordingtype_speaker',
        'summary' => 'recordingtype_summary',
        'summary_next_steps' => 'recordingtype_summary_next_steps',
        'summary_smart_chapters' => 'recordingtype_summary_smart_chapters',
        'timeline' => 'recordingtype_timeline',
    ];

    // Return some default string in case new recordingtype values are added in the future.
    if (empty($recordingtypestringmap[$recordingtype])) {
        return $recordingtype;
    }

    return get_string($recordingtypestringmap[$recordingtype], 'mod_zoom');
}

echo html_writer::table($table);

echo $OUTPUT->footer();

====================

file: exportical.php
path: exportical.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Export ical file for a zoom meeting.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

require(__DIR__ . '/../../config.php');
require_once($CFG->libdir . '/moodlelib.php');
require_once(__DIR__ . '/locallib.php');
require_once($CFG->libdir . '/bennu/bennu.inc.php');

// Course_module ID.
$id = required_param('id', PARAM_INT);
if ($id) {
    $cm = get_coursemodule_from_id('zoom', $id, 0, false, MUST_EXIST);
    $course = get_course($cm->course);
    $zoom = $DB->get_record('zoom', ['id' => $cm->instance], '*', MUST_EXIST);
} else {
    throw new moodle_exception('zoomerr_id_missing', 'mod_zoom');
}

require_login($course, true, $cm);

$context = context_module::instance($cm->id);
$PAGE->set_context($context);

require_capability('mod/zoom:view', $context);

// Get config.
$config = get_config('zoom');

// Check if the admin did not disable the feature.
if ($config->showdownloadical == ZOOM_DOWNLOADICAL_DISABLE) {
    $disabledredirecturl = new moodle_url('/mod/zoom/view.php', ['id' => $id]);
    throw new moodle_exception('err_downloadicaldisabled', 'mod_zoom', $disabledredirecturl);
}

// Check if we are dealing with a recurring meeting with no fixed time.
if ($zoom->recurring && $zoom->recurrence_type == ZOOM_RECURRINGTYPE_NOTIME) {
    $errorredirecturl = new moodle_url('/mod/zoom/view.php', ['id' => $id]);
    throw new moodle_exception('err_downloadicalrecurringnofixed', 'mod_zoom', $errorredirecturl);
}

// Start ical file.
$ical = new iCalendar();
$ical->add_property('method', 'PUBLISH');
$ical->add_property('prodid', '-//Moodle Pty Ltd//NONSGML Moodle Version ' . $CFG->version . '//EN');

// Get the meeting invite note to add to the description property.
$meetinginvite = zoom_webservice()->get_meeting_invitation($zoom)->get_display_string($cm->id);

// Compute and add description property to event.
$convertedtext = html_to_text($zoom->intro);
$descriptiontext = get_string('calendarjoinurl', 'mod_zoom', $CFG->wwwroot . '/mod/zoom/view.php?id=' . $cm->id);
if (!empty($convertedtext)) {
    $descriptiontext .= get_string('calendardescriptionintro', 'mod_zoom', $convertedtext);
}

if (!empty($meetinginvite)) {
    $descriptiontext .= "\n\n" . $meetinginvite;
}

// Get all occurrences of the meeting from the DB.
$params = ['modulename' => 'zoom', 'instance' => $zoom->id];
$events = $DB->get_records('event', $params, 'timestart ASC');

// If we haven't got at least a single occurrence.
if (empty($events)) {
    // We could handle this case in a nicer way ans return an empty iCal file without events,
    // but as this case should not happen in real life anyway, return a fatal error to make clear that something is wrong.
    $errorredirecturl = new moodle_url('/mod/zoom/view.php', ['id' => $id]);
    throw new moodle_exception('err_downloadicalrecurringempty', 'mod_zoom', $errorredirecturl);
}

// Iterate over all events.
// We will add each event as an individual iCal event.
foreach ($events as $event) {
    $icalevent = zoom_helper_icalendar_event($event, $descriptiontext);
    // Add the event to the iCal file.
    $ical->add_component($icalevent);
}

// Start output of iCal file.
$serialized = $ical->serialize();
$filename = 'icalexport.ics';

// Create headers.
header('Last-Modified: ' . gmdate('D, d M Y H:i:s', time()) . ' GMT');
header('Cache-Control: private, must-revalidate, pre-check=0, post-check=0, max-age=0');
header('Expires: ' . gmdate('D, d M Y H:i:s', 0) . 'GMT');
header('Pragma: no-cache');
header('Accept-Ranges: none'); // Comment out if PDFs do not work...
header('Content-disposition: attachment; filename=' . $filename);
header('Content-length: ' . strlen($serialized));
header('Content-type: text/calendar; charset=utf-8');

echo $serialized;

====================

file: get_meeting_report.php
path: console/get_meeting_report.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Console page to output the results of the CLI to get the Zoom meeting reports.
 *
 * @package    mod_zoom
 * @copyright  2020 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

require(__DIR__ . '/../../../config.php');
require_once($CFG->libdir . '/moodlelib.php');

// Force debugging errors.
error_reporting(E_ALL);
ini_set('display_errors', '1');

$courseid = required_param('courseid', PARAM_INT);
$startdate = optional_param('start', date('Y-m-d', strtotime('-3 days')), PARAM_ALPHANUMEXT);
$enddate = optional_param('end', date('Y-m-d'), PARAM_ALPHANUMEXT);

$course = $DB->get_record('course', ['id' => $courseid], '*', MUST_EXIST);

require_course_login($course);

$context = context_course::instance($course->id);
require_capability('mod/zoom:view', $context);
require_capability('mod/zoom:refreshsessions', $context);

// Set up the moodle page.
$PAGE->set_url('/mod/zoom/console/');

echo html_writer::tag('h1', get_string('getmeetingreports', 'mod_zoom'));
$output = null;
$arguments = implode(
    ' ',
    [
        '--start=' . escapeshellarg($startdate),
        '--end=' . escapeshellarg($enddate),
        '--courseid=' . escapeshellarg($courseid),
    ]
);
exec("php $CFG->dirroot/mod/zoom/cli/get_meeting_report.php $arguments", $output);
echo '<pre>';
echo implode("\n", $output);
echo '</pre>';

====================

file: .phpcs.xml
path: .phpcs.xml
codice:
<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="MoodleCore">
  <rule ref="./phpcs.xml"/>
  <rule ref="moodle-extra">
  </rule>
</ruleset>

====================

file: .gitignore
path: .gitignore
codice:
# This file specifies intentionally untracked files that all Moodle git
# repositories should ignore. It is recommended not to modify this file in your
# local clone. Instead, use .git/info/exclude and add new records there as
# needed.
#
# Example: if you deploy a contributed plugin mod/foobar into your site, put
# the following line into .git/info/exclude file in your Moodle clone:
# /mod/foobar/
#
# See gitignore(5) man page for more details
#
/.sass-cache
/lib/editor/tinymce/extra/tools/temp/
*~
*.swp
/tags
/TAGS
/cscope.*
/.patches/
/.idea/
/nbproject/
CVS
.DS_Store
/.settings/
/.project
/.buildpath
/.cache
phpunit.xml
# Composer support - only composer.json is to be in git, the rest is installed in each checkout.
composer.phar
composer.lock
/behat.yml

====================

file: participants.php
path: participants.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * List all zoom meetings.
 *
 * @package    mod_zoom
 * @copyright  2015 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

require(__DIR__ . '/../../config.php');
require_once(__DIR__ . '/lib.php');
require_once(__DIR__ . '/locallib.php');
require_once($CFG->libdir . '/accesslib.php');
require_once($CFG->libdir . '/moodlelib.php');

require_login();
// Additional access checks in zoom_get_instance_setup().
[$course, $cm, $zoom] = zoom_get_instance_setup();

global $DB;

// Check capability.
$context = context_module::instance($cm->id);
require_capability('mod/zoom:addinstance', $context);

$uuid = required_param('uuid', PARAM_RAW);
$export = optional_param('export', null, PARAM_ALPHA);

$PAGE->set_url('/mod/zoom/participants.php', ['id' => $cm->id, 'uuid' => $uuid, 'export' => $export]);

$strname = $zoom->name;
$strtitle = get_string('participants', 'mod_zoom');
$PAGE->navbar->add($strtitle);
$PAGE->set_title("$course->shortname: $strname");
$PAGE->set_heading($course->fullname);
$PAGE->set_pagelayout('incourse');

$maskparticipantdata = get_config('zoom', 'maskparticipantdata');
// If participant data is masked then display a message stating as such and be done with it.
if ($maskparticipantdata) {
    zoom_fatal_error(
        'participantdatanotavailable_help',
        'mod_zoom',
        new moodle_url('/mod/zoom/report.php', ['id' => $cm->id])
    );
}

$sessions = zoom_get_sessions_for_display($zoom->id);
$participants = $sessions[$uuid]['participants'];

// Display the headers/etc if we're not exporting, or if there is no data.
if (empty($export) || empty($participants)) {
    echo $OUTPUT->header();
    echo $OUTPUT->heading($strname);
    echo $OUTPUT->heading($strtitle, 4);

    // Stop if there is no data.
    if (empty($participants)) {
        notice(get_string('noparticipants', 'mod_zoom'), new moodle_url('/mod/zoom/report.php', ['id' => $cm->id]));
        echo $OUTPUT->footer();
        exit();
    }
}

// Loop through each user to generate id->idnumber mapping.
$coursecontext = context_course::instance($course->id);
$enrolled = get_enrolled_users($coursecontext);
$moodleidtouids = [];
foreach ($enrolled as $user) {
    $moodleidtouids[$user->id] = $user->idnumber;
}

$table = new html_table();
// If we are exporting, then put email as a separate column.
if (!empty($export)) {
    $table->head = [
        get_string('idnumber'),
        get_string('name'),
        get_string('email'),
        get_string('jointime', 'mod_zoom'),
        get_string('leavetime', 'mod_zoom'),
        get_string('duration', 'mod_zoom'),
    ];
} else {
    $table->head = [
        get_string('idnumber'),
        get_string('name'),
        get_string('jointime', 'mod_zoom'),
        get_string('leavetime', 'mod_zoom'),
        get_string('duration', 'mod_zoom'),
    ];
}

foreach ($participants as $p) {
    $row = [];

    // Gets moodleuser so we can try to match information to Moodle database.
    $moodleuser = new stdClass();
    if (!empty($p->userid)) {
        $moodleuser = $DB->get_record('user', ['id' => $p->userid], 'idnumber, email');
    }

    // ID number.
    if (array_key_exists($p->userid, $moodleidtouids)) {
        $row[] = $moodleidtouids[$p->userid];
    } else if (isset($moodleuser->idnumber)) {
        $row[] = $moodleuser->idnumber;
    } else {
        $row[] = '';
    }

    // Name/email.
    $name = $p->name;
    $email = '';
    if (!empty($moodleuser->email)) {
        $email = $moodleuser->email;
    } else if (!empty($p->user_email)) {
        $email = $p->user_email;
    }

    // Put email in separate column if we are exporting to Excel.
    if (!empty($export)) {
        $row[] = $name;
        $row[] = $email;
    } else if (!empty($email)) {
        $row[] = html_writer::link("mailto:$email", $name);
    } else {
        $row[] = $name;
    }

    // Join/leave times.
    $row[] = userdate($p->join_time, get_string('strftimedatetimeshort', 'langconfig'));
    $row[] = userdate($p->leave_time, get_string('strftimedatetimeshort', 'langconfig'));

    // Duration.
    $row[] = format_time($p->duration);

    $table->data[] = $row;
}

if ($export != 'xls') {
    echo html_writer::table($table);

    $exporturl = new moodle_url('/mod/zoom/participants.php', [
        'id' => $cm->id,
        'uuid' => $uuid,
        'export' => 'xls',
    ]);
    $xlsstring = get_string('application/vnd.ms-excel', 'mimetypes');
    $xlsicon = html_writer::img(
        $OUTPUT->image_url('f/spreadsheet'),
        $xlsstring,
        ['title' => $xlsstring, 'class' => 'mimetypeicon']
    );
    echo get_string('export', 'mod_zoom') . ': ' . html_writer::link($exporturl, $xlsicon);

    echo $OUTPUT->footer();
} else {
    require_once($CFG->libdir . '/excellib.class.php');

    $workbook = new MoodleExcelWorkbook("zoom_participants_{$zoom->meeting_id}");
    $worksheet = $workbook->add_worksheet($strtitle);
    $boldformat = $workbook->add_format();
    $boldformat->set_bold(true);
    $row = $col = 0;

    foreach ($table->head as $colname) {
        $worksheet->write_string($row, $col++, $colname, $boldformat);
    }

    $row++;
    $col = 0;

    foreach ($table->data as $entry) {
        foreach ($entry as $value) {
            $worksheet->write_string($row, $col++, $value);
        }

        $row++;
        $col = 0;
    }

    $workbook->close();
    exit();
}

====================

file: restore_zoom_stepslib.php
path: backup/moodle2/restore_zoom_stepslib.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Define all the restore steps that will be used by the restore_zoom_activity_task
 *
 * @package   mod_zoom
 * @category  backup
 * @copyright 2015 UC Regents
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot . '/mod/zoom/locallib.php');

use moodle_exception;
use restore_path_element;

/**
 * Structure step to restore one zoom activity
 */
class restore_activity_structure_step extends \restore_activity_structure_step {
    /**
     * Defines structure of path elements to be processed during the restore
     *
     * @return array of restore_path_element
     */
    protected function define_structure() {
        $paths = [];
        $paths[] = new restore_path_element('zoom', '/activity/zoom');
        $paths[] = new restore_path_element('zoom_tracking_field', '/activity/zoom/trackingfields/trackingfield');

        // Return the paths wrapped into standard activity structure.
        return $this->prepare_activity_structure($paths);
    }

    /**
     * Process the given restore path element data
     *
     * @param array $data parsed element data
     */
    protected function process_zoom($data) {
        global $DB;

        $data = (object) $data;

        // Update start_time before attempting to create a new meeting.
        $data->start_time = $this->apply_date_offset($data->start_time);

        // Either create a new meeting or set meeting as expired.
        try {
            // FIXME: Do we provide course context? That won't have the right activity names etc.
            $cmid = null;
            $updateddata = zoom_webservice()->create_meeting($data, $cmid);
            $data = populate_zoom_from_response($data, $updateddata);
            $data->exists_on_zoom = ZOOM_MEETING_EXISTS;
        } catch (moodle_exception $e) {
            $data->join_url = '';
            $data->meeting_id = 0;
            $data->exists_on_zoom = ZOOM_MEETING_EXPIRED;
        }

        $data->course = $this->get_courseid();

        if (empty($data->timemodified)) {
            $data->timemodified = time();
        }

        if ($data->grade < 0) {
            // Scale found, get mapping.
            $data->grade = -($this->get_mappingid('scale', abs($data->grade)));
        }

        // Create the zoom instance.
        $newitemid = $DB->insert_record('zoom', $data);
        $this->apply_activity_instance($newitemid);

        // Create the calendar events for the new meeting.
        $data->id = $newitemid;
        zoom_calendar_item_update($data);
    }

    /**
     * Process the zoom tracking fields.
     *
     * @param array $data
     */
    protected function process_zoom_tracking_field($data) {
        global $DB;

        $data = (object) $data;
        $oldid = $data->id;

        $data->meeting_id = $this->get_new_parentid('zoom');

        $defaulttrackingfields = zoom_clean_tracking_fields();

        if (isset($defaulttrackingfields[$data->tracking_field])) {
            $newitemid = $DB->insert_record('zoom_meeting_tracking_fields', $data);
            $this->set_mapping('zoom_tracking_field', $oldid, $newitemid);
        }
    }

    /**
     * Post-execution actions
     */
    protected function after_execute() {
        // Add zoom related files, no need to match by itemname (just internally handled context).
        $this->add_related_files('mod_zoom', 'intro', null);
    }
}

====================

file: backup_zoom_activity_task.class.php
path: backup/moodle2/backup_zoom_activity_task.class.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Defines backup_zoom_activity_task class
 *
 * @package   mod_zoom
 * @category  backup
 * @copyright 2015 UC Regents
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die;

require_once($CFG->dirroot . '/mod/zoom/backup/moodle2/backup_zoom_stepslib.php');

use mod_zoom\backup_activity_structure_step;

/**
 * Provides the steps to perform one complete backup of the zoom instance
 */
class backup_zoom_activity_task extends backup_activity_task {
    /**
     * No specific settings for this activity
     */
    protected function define_my_settings() {
    }

    /**
     * Defines a backup step to store the instance data in the zoom.xml file
     */
    protected function define_my_steps() {
        $this->add_step(new backup_activity_structure_step('zoom_structure', 'zoom.xml'));
    }

    /**
     * Encodes URLs to the index.php and view.php scripts
     *
     * @param string $content some HTML text that eventually contains URLs to the activity instance scripts
     * @return string the content with the URLs encoded
     */
    public static function encode_content_links($content) {
        global $CFG;

        $base = preg_quote($CFG->wwwroot, '/');

        // Link to the list of zooms.
        $search = '/(' . $base . '\/mod\/zoom\/index.php\?id\=)([0-9]+)/';
        $content = preg_replace($search, '$@ZOOMINDEX*$2@$', $content);

        // Link to zoom view by moduleid.
        $search = '/(' . $base . '\/mod\/zoom\/view.php\?id\=)([0-9]+)/';
        $content = preg_replace($search, '$@ZOOMVIEWBYID*$2@$', $content);

        return $content;
    }
}

====================

file: restore_zoom_activity_task.class.php
path: backup/moodle2/restore_zoom_activity_task.class.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Provides the restore activity task class
 *
 * @package   mod_zoom
 * @category  backup
 * @copyright 2015 UC Regents
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot . '/mod/zoom/backup/moodle2/restore_zoom_stepslib.php');

use mod_zoom\restore_activity_structure_step;

/**
 * Restore task for the zoom activity module
 *
 * Provides all the settings and steps to perform complete restore of the activity.
 */
class restore_zoom_activity_task extends restore_activity_task {
    /**
     * Define (add) particular settings this activity can have
     */
    protected function define_my_settings() {
        // No particular settings for this activity.
    }

    /**
     * Define (add) particular steps this activity can have
     */
    protected function define_my_steps() {
        // We have just one structure step here.
        $this->add_step(new restore_activity_structure_step('zoom_structure', 'zoom.xml'));
    }

    /**
     * Define the contents in the activity that must be
     * processed by the link decoder
     */
    public static function define_decode_contents() {
        $contents = [];

        $contents[] = new restore_decode_content('zoom', ['intro'], 'zoom');

        return $contents;
    }

    /**
     * Define the decoding rules for links belonging
     * to the activity to be executed by the link decoder
     */
    public static function define_decode_rules() {
        $rules = [];

        $rules[] = new restore_decode_rule('ZOOMVIEWBYID', '/mod/zoom/view.php?id=$1', 'course_module');
        $rules[] = new restore_decode_rule('ZOOMINDEX', '/mod/zoom/index.php?id=$1', 'course_module');

        return $rules;
    }

    /**
     * Define the restore log rules that will be applied by the
     * restore_logs_processor when restoring zoom logs. It must return one array
     * of restore_log_rule objects
     */
    public static function define_restore_log_rules() {
        $rules = [];

        $rules[] = new restore_log_rule('zoom', 'add', 'view.php?id={course_module}', '{zoom}');
        $rules[] = new restore_log_rule('zoom', 'update', 'view.php?id={course_module}', '{zoom}');
        $rules[] = new restore_log_rule('zoom', 'view', 'view.php?id={course_module}', '{zoom}');

        return $rules;
    }

    /**
     * Define the restore log rules that will be applied by the
     * restore_logs_processor when restoring course logs. It must return one
     * array of restore_log_rule objects
     *
     * Note this rules are applied when restoring course logs
     * by the restore final task, but are defined here at
     * activity level. All them are rules not linked to any module instance (cmid = 0)
     */
    public static function define_restore_log_rules_for_course() {
        $rules = [];

        $rules[] = new restore_log_rule('zoom', 'view all', 'index.php?id={course}', null);

        return $rules;
    }
}

====================

file: backup_zoom_stepslib.php
path: backup/moodle2/backup_zoom_stepslib.php
codice:
<?php
// This file is part of the Zoom plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Defines backup_activity_structure_step class.
 *
 * @package   mod_zoom
 * @category  backup
 * @copyright 2015 UC Regents
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace mod_zoom;

use backup;
use backup_nested_element;

/**
 * Define the complete zoom structure for backup, with file and id annotations.
 */
class backup_activity_structure_step extends \backup_activity_structure_step {
    /**
     * Defines the backup structure of the module.
     *
     * @return backup_nested_element
     */
    protected function define_structure() {
        // Define the root element describing the zoom instance.
        $zoom = new backup_nested_element('zoom', ['id'], [
            'intro', 'introformat', 'grade', 'grading_method', 'meeting_id', 'join_url', 'created_at', 'host_id', 'name',
            'start_time', 'timemodified', 'recurring', 'recurrence_type', 'repeat_interval', 'weekly_days', 'monthly_day',
            'monthly_week', 'monthly_week_day', 'monthly_repeat_option', 'end_times', 'end_date_time', 'end_date_option',
            'webinar', 'duration', 'timezone', 'password', 'option_jbh', 'option_start_type', 'option_host_video',
            'option_participants_video', 'option_audio', 'option_mute_upon_entry', 'option_waiting_room',
            'option_authenticated_users', 'option_encryption_type', 'exists_on_zoom', 'alternative_hosts',
            'recordings_visible_default', 'show_schedule', 'show_security', 'show_media', 'option_auto_recording',
            'registration',
        ]);

        $trackingfields = new backup_nested_element('trackingfields');

        $trackingfield = new backup_nested_element('trackingfield', ['id'], ['meeting_id', 'tracking_field', 'value']);

        // If we had more elements, we would build the tree here.
        $zoom->add_child($trackingfields);
        $trackingfields->add_child($trackingfield);

        // Define data sources.
        $zoom->set_source_table('zoom', ['id' => backup::VAR_ACTIVITYID]);
        $trackingfield->set_source_table('zoom_meeting_tracking_fields', ['meeting_id' => backup::VAR_ACTIVITYID]);

        // If we were referring to other tables, we would annotate the relation
        // with the element's annotate_ids() method.

        // Define file annotations.
        // Intro does not need itemid.
        $zoom->annotate_files('mod_zoom', 'intro', null);

        // Return the root element (zoom), wrapped into standard activity structure.
        return $this->prepare_activity_structure($zoom);
    }
}

====================

